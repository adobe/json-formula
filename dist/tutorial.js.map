{"version":3,"file":"tutorial.js","mappings":"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","sources":["webpack://JSONFormula/webpack/bootstrap","webpack://JSONFormula/webpack/runtime/make namespace object","webpack://JSONFormula/./jmespath.js/openFormulaFunctions.js","webpack://JSONFormula/./jmespath.js/dataTypes.js","webpack://JSONFormula/./jmespath.js/functions.js","webpack://JSONFormula/./jmespath.js/jmespath.js","webpack://JSONFormula/./src/Form.js","webpack://JSONFormula/./src/tutorial.js","webpack://JSONFormula/./src/json-formula.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import dataTypes from './dataTypes';\n\nexport default function openFormulaFunctions(interpreter, valueOf, toString) {\n  return {\n    and: {\n      _func: resolveArgs => !!valueOf(resolveArgs[0]) && !!valueOf(resolveArgs[1]),\n      _signature: [{ types: [dataTypes.TYPE_ANY] }, { types: [dataTypes.TYPE_ANY] }],\n    },\n\n    or: {\n      _func: resolveArgs => !!valueOf(resolveArgs[0]) || !!valueOf(resolveArgs[1]),\n      _signature: [{ types: [dataTypes.TYPE_ANY] }, { types: [dataTypes.TYPE_ANY] }],\n    },\n\n    not: {\n      _func: resolveArgs => !valueOf(resolveArgs[0]),\n      _signature: [{ types: [dataTypes.TYPE_ANY] }],\n    },\n\n    true: {\n      _func: () => true,\n      _signature: [],\n    },\n\n    false: {\n      _func: () => false,\n      _signature: [],\n    },\n\n    if: {\n      _func: (unresolvedArgs, data) => {\n        const conditionNode = unresolvedArgs[0];\n        const leftBranchNode = unresolvedArgs[1];\n        const rightBranchNode = unresolvedArgs[2];\n        const condition = interpreter.visit(conditionNode, data);\n        if (valueOf(condition)) {\n          return interpreter.visit(leftBranchNode, data);\n        }\n        return interpreter.visit(rightBranchNode, data);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] }],\n    },\n\n    // SUBSTITUTE(Text T ; Text Old ; Text New [; Number Which ])\n    substitute: {\n      _func: args => {\n        const src = args[0].toString();\n        const old = args[1].toString();\n        const replacement = args[2].toString();\n        // no third parameter? replace all instances\n        if (args.length <= 3) return src.replace(new RegExp(old, 'g'), replacement);\n        const whch = args[3].valueOf();\n        // find the instance to replace\n        let pos = -1;\n        for (let i = 0; i < whch; i += 1) {\n          pos += 1;\n          const nextFind = src.slice(pos).indexOf(old);\n          // no instance to match 'Which'\n          if (nextFind === -1) return src;\n          pos += nextFind;\n        }\n        const result = src.slice(0, pos) + src.slice(pos).replace(old, replacement);\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    value: {\n      _func: args => {\n        const obj = args[0] || {};\n        const index = args[1];\n        const result = obj[index];\n        return result === undefined ? null : result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_OBJECT, dataTypes.TYPE_ARRAY, dataTypes.TYPE_NULL] },\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    lower: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toLowerCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    upper: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toUpperCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    exp: {\n      _func: args => {\n        const value = args[0];\n        return Math.exp(value);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    power: {\n      _func: args => {\n        const base = args[0];\n        const power = args[1];\n        return base ** power;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    find: {\n      _func: args => {\n        const text = args[0];\n        const query = args[1];\n        const startPos = args.length > 2 ? args[2] : 0;\n        return text.indexOf(query, startPos);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    left: {\n      _func: args => {\n        const text = args[0];\n        const numChars = args.length > 1 ? args[1] : 1;\n        if (numChars < 0) {\n          return null;\n        }\n        return text.substr(0, numChars);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    right: {\n      _func: args => {\n        const text = args[0];\n        const numChars = args.length > 1 ? args[1] : 1;\n        if (numChars < 0) {\n          return null;\n        }\n        const start = text.length - numChars;\n        return text.substr(start, numChars);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    mid: {\n      _func: args => {\n        const text = args[0];\n        const startPos = args[1];\n        if (startPos < 0) {\n          return null;\n        }\n        const numChars = args[2];\n        return text.substr(startPos, numChars);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    proper: {\n      _func: args => {\n        const text = args[0];\n        const words = text.split(' ');\n        const properWords = words.map(word => word.charAt(0).toUpperCase()\n          + word.slice(1).toLowerCase());\n        return properWords.join(' ');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    rept: {\n      _func: args => {\n        const text = args[0];\n        const count = args[1];\n        if (count < 0) {\n          return null;\n        }\n        return text.repeat(count);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    replace: {\n      _func: args => {\n        const oldText = args[0];\n        const startNum = args[1];\n        const numChars = args[2];\n        const newText = args[3];\n        if (startNum < 0) {\n          return null;\n        }\n\n        const lhs = oldText.substr(0, startNum);\n        const rhs = oldText.substr(startNum + numChars);\n        return lhs + newText + rhs;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    round: {\n      _func: args => {\n        const number = args[0];\n        const digits = args[1];\n        return Math.round(number * 10 ** digits) / 10 ** digits;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    sqrt: {\n      _func: args => {\n        const result = Math.sqrt(args[0]);\n        if (Number.isNaN(result)) {\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    stdevp: {\n      _func: args => {\n        const values = args[0];\n        if (values.length === 0) {\n          return null;\n        }\n        const mean = values.reduce((a, b) => a + b, 0) / values.length;\n        const meanSumSquare = values.reduce((a, b) => a + b * b, 0) / values.length;\n        const result = Math.sqrt(meanSumSquare - mean * mean);\n        if (Number.isNaN(result)) {\n        // this would never happen\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n    stdev: {\n      _func: args => {\n        const values = args[0];\n        if (values.length <= 1) {\n          return null;\n        }\n        const mean = values.reduce((a, b) => a + b, 0) / values.length;\n        const sumSquare = values.reduce((a, b) => a + b * b, 0);\n        const result = Math.sqrt((sumSquare - values.length * mean * mean) / (values.length - 1));\n        if (Number.isNaN(result)) {\n        // this would never happen\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n    trim: {\n      _func: args => {\n        const text = args[0];\n        // only removes the space character\n        // other whitespace characters like \\t \\n left intact\n        const trimmed = text.split(' ').filter(x => x).join(' ');\n        return trimmed;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    trunc: {\n      _func: args => {\n        const number = args[0];\n        const digits = args.length > 1 ? args[1] : 0;\n        const method = number >= 0 ? Math.floor : Math.ceil;\n        return method(number * 10 ** digits) / 10 ** digits;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    charCode: {\n      _func: args => {\n        const code = args[0];\n        if (!Number.isInteger(code)) {\n          return null;\n        }\n        return String.fromCharCode(code);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    codePoint: {\n      _func: args => {\n        const text = args[0];\n        if (text.length === 0) {\n          return null;\n        }\n        return text.codePointAt(0);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n  };\n}\n","// Type constants used to define functions.\nexport default {\n  TYPE_NUMBER: 0,\n  TYPE_ANY: 1,\n  TYPE_STRING: 2,\n  TYPE_ARRAY: 3,\n  TYPE_OBJECT: 4,\n  TYPE_BOOLEAN: 5,\n  TYPE_EXPREF: 6,\n  TYPE_NULL: 7,\n  TYPE_ARRAY_NUMBER: 8,\n  TYPE_ARRAY_STRING: 9,\n  TYPE_CLASS: 10,\n};\n","/* eslint-disable no-underscore-dangle */\nimport dataTypes from './dataTypes';\n\nexport default function functions(\n  interpreter,\n  isObject,\n  isArray,\n  toNumber,\n  getTypeName,\n  valueOf,\n  toString,\n) {\n  const {\n    TYPE_NUMBER,\n    TYPE_ANY,\n    TYPE_STRING,\n    TYPE_ARRAY,\n    TYPE_OBJECT,\n    TYPE_BOOLEAN,\n    TYPE_EXPREF,\n    TYPE_NULL,\n    TYPE_ARRAY_NUMBER,\n    TYPE_ARRAY_STRING,\n  } = dataTypes;\n\n  function createKeyFunction(exprefNode, allowedTypes) {\n    const keyFunc = x => {\n      const current = interpreter.visit(exprefNode, x);\n      if (allowedTypes.indexOf(getTypeName(current)) < 0) {\n        const msg = `TypeError: expected one of ${allowedTypes\n        }, received ${getTypeName(current)}`;\n        throw new Error(msg);\n      }\n      return current;\n    };\n    return keyFunc;\n  }\n\n  return {\n    // name: [function, <signature>]\n    // The <signature> can be:\n    //\n    // {\n    //   args: [[type1, type2], [type1, type2]],\n    //   variadic: true|false\n    // }\n    //\n    // Each arg in the arg list is a list of valid types\n    // (if the function is overloaded and supports multiple\n    // types.  If the type is \"any\" then no type checking\n    // occurs on the argument.  Variadic is optional\n    // and if not provided is assumed to be false.\n    abs: {\n      _func: resolvedArgs => Math.abs(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    avg: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        const inputArray = resolvedArgs[0];\n        for (let i = 0; i < inputArray.length; i += 1) {\n          sum += inputArray[i];\n        }\n        return sum / inputArray.length;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n    ceil: {\n      _func: resolvedArgs => Math.ceil(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    contains: {\n      _func: resolvedArgs => valueOf(resolvedArgs[0]).indexOf(valueOf(resolvedArgs[1])) >= 0,\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] },\n        { types: [TYPE_ANY] }],\n    },\n    endsWith: {\n      _func: resolvedArgs => {\n        const searchStr = valueOf(resolvedArgs[0]);\n        const suffix = valueOf(resolvedArgs[1]);\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n      },\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    floor: {\n      _func: resolvedArgs => Math.floor(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    length: {\n      _func: resolvedArgs => {\n        const arg = valueOf(resolvedArgs[0]);\n        if (isObject(arg)) return Object.keys(arg).length;\n\n        return isArray(arg) ? arg.length : toString(arg).length;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],\n    },\n\n    map: {\n      _func: resolvedArgs => {\n        const mapped = [];\n        const exprefNode = resolvedArgs[0];\n        const elements = resolvedArgs[1];\n        for (let i = 0; i < elements.length; i += 1) {\n          mapped.push(interpreter.visit(exprefNode, elements[i]));\n        }\n        return mapped;\n      },\n      _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }],\n    },\n\n    max: {\n      _func: resolvedArgs => {\n        if (resolvedArgs[0].length > 0) {\n          const typeName = getTypeName(resolvedArgs[0][0]);\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0].reduce(\n              (prev, cur) => (toNumber(prev) >= toNumber(cur) ? prev : cur),\n              resolvedArgs[0][0],\n            );\n          }\n          return resolvedArgs[0].reduce(\n            (a, b) => (toString(b).localeCompare(toString(a)) < 0 ? a : b),\n            resolvedArgs[0][0],\n          );\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n    },\n\n    merge: {\n      _func: resolvedArgs => {\n        const merged = {};\n        for (let i = 0; i < resolvedArgs.length; i += 1) {\n          const current = resolvedArgs[i];\n          Object.keys(current).forEach(key => {\n            merged[key] = current[key];\n          });\n        }\n        return merged;\n      },\n      _signature: [{ types: [TYPE_OBJECT], variadic: true }],\n    },\n\n    maxBy: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        const resolvedArray = resolvedArgs[0];\n        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n        let maxNumber = -Infinity;\n        let maxRecord;\n        let current;\n        for (let i = 0; i < resolvedArray.length; i += 1) {\n          current = keyFunction(resolvedArray[i]);\n          if (current > maxNumber) {\n            maxNumber = current;\n            maxRecord = resolvedArray[i];\n          }\n        }\n        return maxRecord;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    sum: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        const listToSum = resolvedArgs[0];\n        for (let i = 0; i < listToSum.length; i += 1) {\n          sum += listToSum[i] * 1;\n        }\n        return sum;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n\n    startsWith: {\n      _func: resolvedArgs => valueOf(resolvedArgs[0]).lastIndexOf(valueOf(resolvedArgs[1])) === 0,\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    min: {\n      _func: resolvedArgs => {\n        if (resolvedArgs[0].length > 0) {\n          const typeName = getTypeName(resolvedArgs[0][0]);\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0].reduce(\n              (prev, cur) => (toNumber(prev) <= toNumber(cur) ? prev : cur),\n              resolvedArgs[0][0],\n            );\n          }\n          const elements = resolvedArgs[0];\n          let minElement = elements[0];\n          for (let i = 1; i < elements.length; i += 1) {\n            if (toString(elements[i]).localeCompare(toString(minElement)) < 0) {\n              minElement = elements[i];\n            }\n          }\n          return minElement;\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n    },\n\n    minBy: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        const resolvedArray = resolvedArgs[0];\n        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n        let minNumber = Infinity;\n        let minRecord;\n        let current;\n        for (let i = 0; i < resolvedArray.length; i += 1) {\n          current = keyFunction(resolvedArray[i]);\n          if (current < minNumber) {\n            minNumber = current;\n            minRecord = resolvedArray[i];\n          }\n        }\n        return minRecord;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    type: {\n      _func: resolvedArgs => ({\n        [TYPE_NUMBER]: 'number',\n        [TYPE_STRING]: 'string',\n        [TYPE_ARRAY]: 'array',\n        [TYPE_OBJECT]: 'object',\n        [TYPE_BOOLEAN]: 'boolean',\n        [TYPE_EXPREF]: 'expref',\n        [TYPE_NULL]: 'null',\n      }[getTypeName(resolvedArgs[0])]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    keys: {\n      _func: resolvedArgs => Object.keys(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    values: {\n      _func: resolvedArgs => Object.values(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    sort: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length > 0) {\n          const normalize = getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER ? toNumber : toString;\n          sortedArray.sort((a, b) => {\n            const va = normalize(a);\n            const vb = normalize(b);\n            if (va < vb) return -1;\n            if (va > vb) return 1;\n            return 0;\n          });\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }],\n    },\n\n    sortBy: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n          return sortedArray;\n        }\n        const exprefNode = resolvedArgs[1];\n        const requiredType = getTypeName(\n          interpreter.visit(exprefNode, sortedArray[0]),\n        );\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n          throw new Error('TypeError');\n        }\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        const decorated = [];\n        for (let i = 0; i < sortedArray.length; i += 1) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort((a, b) => {\n          const exprA = interpreter.visit(exprefNode, a[1]);\n          const exprB = interpreter.visit(exprefNode, b[1]);\n          if (getTypeName(exprA) !== requiredType) {\n            throw new Error(\n              `TypeError: expected ${requiredType}, received ${\n                getTypeName(exprA)}`,\n            );\n          } else if (getTypeName(exprB) !== requiredType) {\n            throw new Error(\n              `TypeError: expected ${requiredType}, received ${\n                getTypeName(exprB)}`,\n            );\n          }\n          if (exprA > exprB) {\n            return 1;\n          }\n          if (exprA < exprB) {\n            return -1;\n          }\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        });\n        // Undecorate: extract out the original list elements.\n        for (let j = 0; j < decorated.length; j += 1) {\n          [, sortedArray[j]] = decorated[j];\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    join: {\n      _func: resolvedArgs => {\n        const joinChar = resolvedArgs[0];\n        const listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n      },\n      _signature: [\n        { types: [TYPE_STRING] },\n        { types: [TYPE_ARRAY_STRING] },\n      ],\n    },\n\n    reverse: {\n      _func: resolvedArgs => {\n        const originalStr = valueOf(resolvedArgs[0]);\n        const typeName = getTypeName(originalStr);\n        if (typeName === TYPE_STRING) {\n          let reversedStr = '';\n          for (let i = originalStr.length - 1; i >= 0; i -= 1) {\n            reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        }\n        const reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],\n    },\n\n    toArray: {\n      _func: resolvedArgs => {\n        if (getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n          return resolvedArgs[0];\n        }\n        return [resolvedArgs[0]];\n      },\n\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    toString: {\n      _func: resolvedArgs => {\n        if (getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n          return resolvedArgs[0];\n        }\n        return JSON.stringify(resolvedArgs[0]);\n      },\n\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    toNumber: {\n      _func: resolvedArgs => {\n        const typeName = getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_NUMBER) {\n          return resolvedArgs[0];\n        }\n        if (typeName === TYPE_STRING) {\n          return toNumber(resolvedArgs[0]);\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    notNull: {\n      _func: resolvedArgs => {\n        for (let i = 0; i < resolvedArgs.length; i += 1) {\n          if (getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n            return resolvedArgs[i];\n          }\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ANY], variadic: true }],\n    },\n  };\n}\n","/* eslint-disable no-restricted-syntax */\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-underscore-dangle */\nimport dataTypes from './dataTypes';\nimport openFormulaFunctions from './openFormulaFunctions';\nimport functions from './functions';\n\n// Type constants used to define functions.\nconst {\n  TYPE_NUMBER,\n  TYPE_ANY,\n  TYPE_STRING,\n  TYPE_ARRAY,\n  TYPE_OBJECT,\n  TYPE_BOOLEAN,\n  TYPE_EXPREF,\n  TYPE_NULL,\n  TYPE_ARRAY_NUMBER,\n  TYPE_ARRAY_STRING,\n  TYPE_CLASS,\n} = dataTypes;\n\nfunction JsonFormula() {\n  const TOK_EOF = 'EOF';\n  const TOK_UNQUOTEDIDENTIFIER = 'UnquotedIdentifier';\n  const TOK_QUOTEDIDENTIFIER = 'QuotedIdentifier';\n  const TOK_RBRACKET = 'Rbracket';\n  const TOK_RPAREN = 'Rparen';\n  const TOK_COMMA = 'Comma';\n  const TOK_COLON = 'Colon';\n  const TOK_CONCATENATE = 'Concatenate';\n  const TOK_RBRACE = 'Rbrace';\n  const TOK_NUMBER = 'Number';\n  const TOK_CURRENT = 'Current';\n  const TOK_GLOBAL = 'Global';\n  const TOK_FIELD = 'Field';\n  const TOK_EXPREF = 'Expref';\n  const TOK_PIPE = 'Pipe';\n  const TOK_OR = 'Or';\n  const TOK_AND = 'And';\n  const TOK_ADD = 'Add';\n  const TOK_SUBTRACT = 'Subtract';\n  const TOK_MULTIPLY = 'Multiply';\n  const TOK_POWER = 'Power';\n  const TOK_DIVIDE = 'Divide';\n  const TOK_EQ = 'EQ';\n  const TOK_GT = 'GT';\n  const TOK_LT = 'LT';\n  const TOK_GTE = 'GTE';\n  const TOK_LTE = 'LTE';\n  const TOK_NE = 'NE';\n  const TOK_FLATTEN = 'Flatten';\n  const TOK_STAR = 'Star';\n  const TOK_FILTER = 'Filter';\n  const TOK_DOT = 'Dot';\n  const TOK_NOT = 'Not';\n  const TOK_LBRACE = 'Lbrace';\n  const TOK_LBRACKET = 'Lbracket';\n  const TOK_LPAREN = 'Lparen';\n  const TOK_LITERAL = 'Literal';\n\n  const TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>',\n  };\n\n  let globalTokens = {};\n\n  function isNum(ch, includeSign) {\n    return (ch >= '0' && ch <= '9')\n             || (includeSign && ch === '-')\n             || (ch === '.');\n  }\n\n  function isAlphaNum(ch) {\n    return (ch >= 'a' && ch <= 'z')\n             || (ch >= 'A' && ch <= 'Z')\n             || (ch >= '0' && ch <= '9')\n             || ch === '_';\n  }\n\n  function isOperator(tok) {\n    return [\n      TOK_CONCATENATE,\n      TOK_OR,\n      TOK_AND,\n      TOK_ADD,\n      TOK_SUBTRACT,\n      TOK_MULTIPLY,\n      TOK_POWER,\n      TOK_DIVIDE,\n      TOK_EQ,\n      TOK_GT,\n      TOK_LT,\n      TOK_GTE,\n      TOK_LTE,\n      TOK_NE].includes(tok);\n  }\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n    return false;\n  }\n\n  function valueOf(a) {\n    if (a === null || a === undefined) return a;\n    if (isArray(a)) {\n      return a.map(i => valueOf(i));\n    }\n    return a.valueOf();\n  }\n\n  function toString(a) {\n    if (a === null || a === undefined) return '';\n    return a.toString();\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === '[object Object]';\n    }\n    return false;\n  }\n  function isClass(obj) {\n    if (obj === null) return false;\n    if (Array.isArray(obj)) return false;\n    return typeof obj === 'object' && obj.constructor.name !== 'Object';\n  }\n\n  function matchClass(arg, expectedList) {\n    return isClass(arg) && expectedList.includes(TYPE_CLASS);\n  }\n\n  function getTypeName(inputObj, useValueOf = true) {\n    if (inputObj === null) return TYPE_NULL;\n    const obj = useValueOf ? inputObj.valueOf() : inputObj;\n    switch (Object.prototype.toString.call(obj)) {\n      case '[object String]':\n        return TYPE_STRING;\n      case '[object Number]':\n        return TYPE_NUMBER;\n      case '[object Array]':\n        return TYPE_ARRAY;\n      case '[object Boolean]':\n        return TYPE_BOOLEAN;\n      case '[object Null]':\n        return TYPE_NULL;\n      case '[object Object]':\n        // Check if it's an expref.  If it has, it's been\n        // tagged with a jmespathType attr of 'Expref';\n        if (obj.jmespathType === TOK_EXPREF) {\n          return TYPE_EXPREF;\n        }\n        return TYPE_OBJECT;\n      default:\n        return TYPE_OBJECT;\n    }\n  }\n\n  function getTypeNames(inputObj) {\n    // return the types with and without using valueOf\n    // needed for the cases where we really need an object passed to a function -- not it's value\n    const type1 = getTypeName(inputObj);\n    const type2 = getTypeName(inputObj, false);\n    return [type1, type2];\n  }\n\n  function strictDeepEqual(lhs, rhs) {\n    const first = valueOf(lhs);\n    const second = valueOf(rhs);\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    const firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (let i = 0; i < first.length; i += 1) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      const keysSeen = {};\n      for (const key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (const key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(value) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n    // (new) use JS truthy evaluation.  This changes the spec behavior.\n    // Where in the past a zero (0) would be True, it's now false\n\n    // First check the scalar values.\n    if (value === null) return true;\n    // in case it's an object with a valueOf defined\n    const obj = valueOf(value);\n    if (obj === '' || obj === false || obj === null) {\n      return true;\n    }\n    if (isArray(obj) && obj.length === 0) {\n      // Check for an empty array.\n      return true;\n    }\n    if (isObject(obj)) {\n      // Check for an empty object.\n      for (const key in obj) {\n        // If there are any keys, then\n        // the object is not empty so the object\n        // is not false.\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return !obj;\n  }\n\n  function objValues(obj) {\n    const keys = Object.keys(obj);\n    const values = [];\n    for (let i = 0; i < keys.length; i += 1) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function toNumber(value) {\n    const n = valueOf(value); // in case it's an object that implements valueOf()\n    if (n === null) return null;\n    if (n instanceof Array) return 0;\n    if (typeof n === 'number') return n;\n    if (typeof n === 'string') {\n      const temp = parseFloat(n);\n      return Number.isNaN(temp) ? 0 : temp;\n    }\n    if (typeof n === 'boolean') return n ? 1 : 0;\n\n    // more coercions needed...\n    throw new Error('need to coerce number');\n  }\n\n  function applyOperator(first, second, operator) {\n    // TODO: fill in remaining operators\n    if (isArray(first) && isArray(second)) {\n      const len = Math.min(first.length, second.length);\n      const result = [];\n      let i;\n      for (i = 0; i < len; i += 1) {\n        if (isArray(first[i]) || isArray(second[i])) {\n          result.push(applyOperator(first[i], second[i], operator));\n        } else if (operator === '*') {\n          result.push(first[i] * second[i]);\n        } else if (operator === '&') {\n          result.push(first[i] + second[i]);\n        } else throw new Error('unimplemented');\n      }\n      for (i = len; i < Math.max(first.length, second.length); i += 1) {\n        // Result of the operator applied with 'null'\n        if (operator === '&') result.push('');\n        else if (operator === '*') result.push(0);\n      }\n      return result;\n    }\n\n    if (isArray(first) || isArray(second)) {\n      const [arr, scalar] = isArray(first) ? [first, second] : [second, first];\n      if (operator === '*') return arr.map(a => toNumber(a) * toNumber(scalar));\n      if (operator === '&') return arr.map(a => a + scalar);\n    }\n    if (operator === '*') return toNumber(first) * toNumber(second);\n    if (operator === '&') return first + second;\n    throw new Error(`unimplemented array operator: ${operator}`);\n  }\n  function matchType(actuals, expectedList, argValue, context) {\n    const actual = actuals[0];\n    if (expectedList.findIndex(\n      type => type === TYPE_ANY || actual === type,\n    ) !== -1\n    ) return argValue;\n    // Can't coerce Objects to any other type\n    if (actual === TYPE_OBJECT) {\n      throw new Error(`TypeError: ${context} expected argument to be type ${TYPE_NAME_TABLE[expectedList[0]]} but received type ${TYPE_NAME_TABLE[actual]} instead.`);\n    }\n    // no exact match in the list of possible types, see if we can coerce an array type\n    let expected = -1;\n    if (actual === TYPE_ARRAY) {\n      if (expectedList.includes(TYPE_ARRAY_STRING) && expectedList.includes(TYPE_ARRAY_NUMBER)) {\n        // choose the array type based on the first element\n        if (argValue.length > 0 && typeof argValue[0] === 'string') expected = TYPE_ARRAY_STRING;\n        else expected = TYPE_ARRAY_NUMBER;\n      }\n    }\n    if (expected === -1 && [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(actual)) {\n      expected = expectedList.find(\n        e => [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(e),\n      );\n    }\n    // no match, just take the first type\n    if (expected === -1) [expected] = expectedList;\n    if (expected === TYPE_ANY) return argValue;\n    if (expected === TYPE_ARRAY_STRING\n        || expected === TYPE_ARRAY_NUMBER\n        || expected === TYPE_ARRAY) {\n      if (expected === TYPE_ARRAY) {\n        if (actual === TYPE_ARRAY_NUMBER || actual === TYPE_ARRAY_STRING) return argValue;\n        return argValue === null ? [] : [argValue];\n      }\n      // The expected type can either just be array,\n      // or it can require a specific subtype (array of numbers).\n      const subtype = expected === TYPE_ARRAY_NUMBER ? TYPE_NUMBER : TYPE_STRING;\n      if (actual === TYPE_ARRAY) {\n        // Otherwise we need to check subtypes.\n        // We're going to modify the array, so take a copy\n        const returnArray = argValue.slice();\n        for (let i = 0; i < returnArray.length; i += 1) {\n          const indexType = getTypeNames(returnArray[i]);\n          returnArray[i] = matchType(indexType, [subtype], returnArray[i], context);\n        }\n        return returnArray;\n      }\n      if ([TYPE_NUMBER, TYPE_STRING, TYPE_NULL, TYPE_BOOLEAN].includes(subtype)) {\n        return [matchType(actuals, [subtype], argValue, context)];\n      }\n    } else {\n      if (expected === TYPE_NUMBER) {\n        if ([TYPE_STRING, TYPE_BOOLEAN, TYPE_NULL].includes(actual)) return toNumber(argValue);\n        /* TYPE_ARRAY, TYPE_EXPREF, TYPE_OBJECT, TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING */\n        return 0;\n      }\n      if (expected === TYPE_STRING) {\n        if (actual === TYPE_NULL || actual === TYPE_OBJECT) return '';\n        return argValue.toString();\n      }\n      if (expected === TYPE_BOOLEAN) {\n        return !!argValue;\n      }\n      if (expected === TYPE_OBJECT && actuals[1] === TYPE_OBJECT) {\n        return argValue;\n      }\n    }\n    throw new Error('unhandled argument');\n  }\n\n  let trimLeft;\n  if (typeof String.prototype.trimLeft === 'function') {\n    trimLeft = str => str.trimLeft();\n  } else {\n    trimLeft = str => str.match(/^\\s*(.*)/)[1];\n  }\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  const basicTokens = {\n    '.': TOK_DOT,\n    // \"*\": TOK_STAR,\n    ',': TOK_COMMA,\n    ':': TOK_COLON,\n    '{': TOK_LBRACE,\n    '}': TOK_RBRACE,\n    ']': TOK_RBRACKET,\n    '(': TOK_LPAREN,\n    ')': TOK_RPAREN,\n    '@': TOK_CURRENT,\n  };\n\n  const globalStartToken = '$';\n  const operatorStartToken = {\n    '<': true,\n    '>': true,\n    '=': true,\n    '!': true,\n  };\n\n  const skipChars = {\n    ' ': true,\n    '\\t': true,\n    '\\n': true,\n  };\n\n  function isIdentifier(stream, pos) {\n    const ch = stream[pos];\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    if (ch === '$') {\n      return stream.length > pos && isAlphaNum(stream[pos + 1]);\n    }\n    // return whether character 'isAlpha'\n    return (ch >= 'a' && ch <= 'z')\n            || (ch >= 'A' && ch <= 'Z')\n            || ch === '_';\n  }\n\n  function isGlobal(prev, stream, pos) {\n    // global tokens occur only at the start of an expression\n    if (prev !== null && prev === TOK_DOT) return false;\n    const ch = stream[pos];\n    if (ch !== globalStartToken) return false;\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    let i = pos + 1;\n    while (i < stream.length && isAlphaNum(stream[i])) i += 1;\n    const global = stream.slice(pos, i);\n    return !!globalTokens[global];\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n    tokenize(stream) {\n      const tokens = [];\n      this._current = 0;\n      let start;\n      let identifier;\n      let token;\n      while (this._current < stream.length) {\n        const prev = tokens.length ? tokens.slice(-1)[0].type : null;\n\n        if (isGlobal(prev, stream, this._current)) {\n          tokens.push(this._consumeGlobal(stream));\n        } else if (isIdentifier(stream, this._current)) {\n          start = this._current;\n          identifier = this._consumeUnquotedIdentifier(stream);\n          tokens.push({\n            type: TOK_UNQUOTEDIDENTIFIER,\n            value: identifier,\n            start,\n          });\n        } else if (basicTokens[stream[this._current]] !== undefined) {\n          tokens.push({\n            type: basicTokens[stream[this._current]],\n            value: stream[this._current],\n            start: this._current,\n          });\n          this._current += 1;\n        } else if ((stream[this._current] === '-' && !(prev === TOK_NUMBER || prev === TOK_RPAREN)) || isNum(stream[this._current], false)) {\n          token = this._consumeNumber(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === '[') {\n          // No need to increment this._current.  This happens\n          // in _consumeLBracket\n          token = this._consumeLBracket(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === '\"') {\n          start = this._current;\n          identifier = this._consumeQuotedIdentifier(stream);\n          tokens.push({\n            type: TOK_QUOTEDIDENTIFIER,\n            value: identifier,\n            start,\n          });\n        } else if (stream[this._current] === \"'\") {\n          start = this._current;\n          identifier = this._consumeRawStringLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: identifier,\n            start,\n          });\n        } else if (stream[this._current] === '`') {\n          start = this._current;\n          const literal = this._consumeLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: literal,\n            start,\n          });\n        } else if (operatorStartToken[stream[this._current]] !== undefined) {\n          tokens.push(this._consumeOperator(stream));\n        } else if (skipChars[stream[this._current]] !== undefined) {\n          // Ignore whitespace.\n          this._current += 1;\n        } else if (stream[this._current] === '&') {\n          start = this._current;\n          this._current += 1;\n          if (stream[this._current] === '&') {\n            this._current += 1;\n            tokens.push({ type: TOK_AND, value: '&&', start });\n          } else if (prev === TOK_COMMA || prev === TOK_LPAREN) {\n            // based on previous token we'll know if this & is a JMESPath expression-type\n            // or if it's a concatenation operator\n            // if we're a function arg then it's an expression-type\n            tokens.push({ type: TOK_EXPREF, value: '&', start });\n          } else {\n            tokens.push({ type: TOK_CONCATENATE, value: '&', start });\n          }\n        } else if (stream[this._current] === '+') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_ADD, value: '+', start });\n        } else if (stream[this._current] === '-') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_SUBTRACT, value: '-', start });\n        } else if (stream[this._current] === '*') {\n          start = this._current;\n          this._current += 1;\n          // based on previous token we'll know if this asterix is a star -- not a multiply\n          // might be better to list the prev tokens that are valid for multiply?\n          const prevToken = tokens.length && tokens.slice(-1)[0].type;\n          if (tokens.length === 0 || [\n            TOK_LBRACKET,\n            TOK_DOT,\n            TOK_PIPE,\n            TOK_AND,\n            TOK_OR,\n            TOK_COMMA,\n            TOK_COLON,\n          ].includes(prevToken)) {\n            tokens.push({ type: TOK_STAR, value: '*', start });\n          } else {\n            tokens.push({ type: TOK_MULTIPLY, value: '*', start });\n          }\n        } else if (stream[this._current] === '/') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_DIVIDE, value: '/', start });\n        } else if (stream[this._current] === '^') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_POWER, value: '^', start });\n        } else if (stream[this._current] === '|') {\n          start = this._current;\n          this._current += 1;\n          if (stream[this._current] === '|') {\n            this._current += 1;\n            tokens.push({ type: TOK_OR, value: '||', start });\n          } else {\n            tokens.push({ type: TOK_PIPE, value: '|', start });\n          }\n        } else {\n          const error = new Error(`Unknown character:${stream[this._current]}`);\n          error.name = 'LexerError';\n          throw error;\n        }\n      }\n      return tokens;\n    },\n\n    _consumeUnquotedIdentifier(stream) {\n      const start = this._current;\n      this._current += 1;\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n        this._current += 1;\n      }\n      return stream.slice(start, this._current);\n    },\n\n    _consumeQuotedIdentifier(stream) {\n      const start = this._current;\n      this._current += 1;\n      const maxLength = stream.length;\n      while (stream[this._current] !== '\"' && this._current < maxLength) {\n        // You can escape a double quote and you can escape an escape.\n        let current = this._current;\n        if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                               || stream[current + 1] === '\"')) {\n          current += 2;\n        } else {\n          current += 1;\n        }\n        this._current = current;\n      }\n      this._current += 1;\n      return JSON.parse(stream.slice(start, this._current));\n    },\n\n    _consumeRawStringLiteral(stream) {\n      const start = this._current;\n      this._current += 1;\n      const maxLength = stream.length;\n      while (stream[this._current] !== \"'\" && this._current < maxLength) {\n        // You can escape a single quote and you can escape an escape.\n        let current = this._current;\n        if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                               || stream[current + 1] === \"'\")) {\n          current += 2;\n        } else {\n          current += 1;\n        }\n        this._current = current;\n      }\n      this._current += 1;\n      const literal = stream.slice(start + 1, this._current - 1);\n      return literal.replace(\"\\\\'\", \"'\");\n    },\n\n    _consumeNumber(stream) {\n      const start = this._current;\n      this._current += 1;\n      const maxLength = stream.length;\n      while (isNum(stream[this._current], false) && this._current < maxLength) {\n        this._current += 1;\n      }\n      const n = stream.slice(start, this._current);\n      let value;\n      if (n.includes('.')) {\n        value = parseFloat(n);\n      } else {\n        value = parseInt(n, 10);\n      }\n      return { type: TOK_NUMBER, value, start };\n    },\n\n    _consumeLBracket(stream) {\n      const start = this._current;\n      this._current += 1;\n      if (stream[this._current] === '?') {\n        this._current += 1;\n        return { type: TOK_FILTER, value: '[?', start };\n      }\n      if (stream[this._current] === ']') {\n        this._current += 1;\n        return { type: TOK_FLATTEN, value: '[]', start };\n      }\n      return { type: TOK_LBRACKET, value: '[', start };\n    },\n\n    _consumeGlobal(stream) {\n      const start = this._current;\n      this._current += 1;\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) this._current += 1;\n      const global = stream.slice(start, this._current);\n\n      return { type: TOK_GLOBAL, value: globalTokens[global], start };\n    },\n\n    _consumeOperator(stream) {\n      const start = this._current;\n      const startingChar = stream[start];\n      this._current += 1;\n      if (startingChar === '!') {\n        if (stream[this._current] === '=') {\n          this._current += 1;\n          return { type: TOK_NE, value: '!=', start };\n        }\n        return { type: TOK_NOT, value: '!', start };\n      }\n      if (startingChar === '<') {\n        if (stream[this._current] === '=') {\n          this._current += 1;\n          return { type: TOK_LTE, value: '<=', start };\n        }\n        return { type: TOK_LT, value: '<', start };\n      }\n      if (startingChar === '>') {\n        if (stream[this._current] === '=') {\n          this._current += 1;\n          return { type: TOK_GTE, value: '>=', start };\n        }\n        return { type: TOK_GT, value: '>', start };\n      }\n      // startingChar is '='\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_EQ, value: '==', start };\n      }\n      return { type: TOK_EQ, value: '=', start };\n    },\n\n    _consumeLiteral(stream) {\n      this._current += 1;\n      const start = this._current;\n      const maxLength = stream.length;\n      let literal;\n      while (stream[this._current] !== '`' && this._current < maxLength) {\n        // You can escape a literal char or you can escape the escape.\n        let current = this._current;\n        if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                               || stream[current + 1] === '`')) {\n          current += 2;\n        } else {\n          current += 1;\n        }\n        this._current = current;\n      }\n      let literalString = trimLeft(stream.slice(start, this._current));\n      literalString = literalString.replace('\\\\`', '`');\n      if (this._looksLikeJSON(literalString)) {\n        literal = JSON.parse(literalString);\n      } else {\n        // Try to JSON parse it as \"<literal>\"\n        literal = JSON.parse(`\"${literalString}\"`);\n      }\n      // +1 gets us to the ending \"`\", +1 to move on to the next char.\n      this._current += 1;\n      return literal;\n    },\n\n    _looksLikeJSON(literalString) {\n      const startingChars = '[{\"';\n      const jsonLiterals = ['true', 'false', 'null'];\n      const numberLooking = '-0123456789';\n\n      if (literalString === '') {\n        return false;\n      }\n      if (startingChars.indexOf(literalString[0]) >= 0) {\n        return true;\n      }\n      if (jsonLiterals.indexOf(literalString) >= 0) {\n        return true;\n      }\n      if (numberLooking.indexOf(literalString[0]) >= 0) {\n        try {\n          JSON.parse(literalString);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    },\n  };\n\n  const bindingPower = {};\n  bindingPower[TOK_EOF] = 0;\n  bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_RBRACKET] = 0;\n  bindingPower[TOK_RPAREN] = 0;\n  bindingPower[TOK_COMMA] = 0;\n  bindingPower[TOK_RBRACE] = 0;\n  bindingPower[TOK_NUMBER] = 0;\n  bindingPower[TOK_CURRENT] = 0;\n  bindingPower[TOK_GLOBAL] = 0;\n  bindingPower[TOK_FIELD] = 0;\n  bindingPower[TOK_EXPREF] = 0;\n  bindingPower[TOK_PIPE] = 1;\n  bindingPower[TOK_OR] = 2;\n  bindingPower[TOK_AND] = 3;\n  bindingPower[TOK_ADD] = 6;\n  bindingPower[TOK_SUBTRACT] = 6;\n  bindingPower[TOK_CONCATENATE] = 7;\n  bindingPower[TOK_MULTIPLY] = 7;\n  bindingPower[TOK_DIVIDE] = 7;\n  bindingPower[TOK_POWER] = 7;\n  bindingPower[TOK_EQ] = 5;\n  bindingPower[TOK_GT] = 5;\n  bindingPower[TOK_LT] = 5;\n  bindingPower[TOK_GTE] = 5;\n  bindingPower[TOK_LTE] = 5;\n  bindingPower[TOK_NE] = 5;\n  bindingPower[TOK_FLATTEN] = 9;\n  bindingPower[TOK_STAR] = 20;\n  bindingPower[TOK_FILTER] = 21;\n  bindingPower[TOK_DOT] = 40;\n  bindingPower[TOK_NOT] = 45;\n  bindingPower[TOK_LBRACE] = 50;\n  bindingPower[TOK_LBRACKET] = 55;\n  bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n    parse(expression) {\n      this._loadTokens(expression);\n      this.index = 0;\n      const ast = this.expression(0);\n      if (this._lookahead(0) !== TOK_EOF) {\n        const t = this._lookaheadToken(0);\n        const error = new Error(\n          `Unexpected token type: ${t.type}, value: ${t.value}`,\n        );\n        error.name = 'ParserError';\n        throw error;\n      }\n      return ast;\n    },\n\n    _loadTokens(expression) {\n      const lexer = new Lexer();\n      const tokens = lexer.tokenize(expression);\n      tokens.push({ type: TOK_EOF, value: '', start: expression.length });\n      this.tokens = tokens;\n    },\n\n    expression(rbp) {\n      const leftToken = this._lookaheadToken(0);\n      this._advance();\n      let left = this.nud(leftToken);\n      let currentToken = this._lookahead(0);\n      while (rbp < bindingPower[currentToken]) {\n        this._advance();\n        left = this.led(currentToken, left);\n        currentToken = this._lookahead(0);\n      }\n      return left;\n    },\n\n    _lookahead(number) {\n      return this.tokens[this.index + number].type;\n    },\n\n    _lookaheadToken(number) {\n      return this.tokens[this.index + number];\n    },\n\n    _advance() {\n      this.index += 1;\n    },\n\n    // eslint-disable-next-line consistent-return\n    nud(token) {\n      let left;\n      let right;\n      let expression;\n      let node;\n      let args;\n      switch (token.type) {\n        case TOK_LITERAL:\n          return { type: 'Literal', value: token.value };\n        case TOK_NUMBER:\n          return { type: 'Number', value: token.value };\n        case TOK_UNQUOTEDIDENTIFIER:\n          return { type: 'Field', name: token.value };\n        case TOK_QUOTEDIDENTIFIER:\n          node = { type: 'Field', name: token.value };\n          if (this._lookahead(0) === TOK_LPAREN) {\n            throw new Error('Quoted identifier not allowed for function names.');\n          }\n          return node;\n        case TOK_NOT:\n          right = this.expression(bindingPower.Not);\n          return { type: 'NotExpression', children: [right] };\n        case TOK_STAR:\n          left = { type: 'Identity' };\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            // This can happen in a multiselect,\n            // [a, b, *]\n            right = { type: 'Identity' };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Star);\n          }\n          return { type: 'ValueProjection', children: [left, right] };\n        case TOK_FILTER:\n          return this.led(token.type, { type: 'Identity' });\n        case TOK_LBRACE:\n          return this._parseMultiselectHash();\n        case TOK_FLATTEN:\n          left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };\n          right = this._parseProjectionRHS(bindingPower.Flatten);\n          return { type: 'Projection', children: [left, right] };\n        case TOK_LBRACKET:\n          // seeing a comma means that we are not a projection -- assume a list\n          // but the cases of [0] and [] are still ambiguous\n          // the better solution is to force us down the index expression path\n          // after pipe and after identifier\n          if (this._lookahead(1) === TOK_COMMA || isOperator(this._lookahead(1))) {\n            return this._parseMultiselectList();\n          }\n          if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice({ type: 'Identity' }, right);\n          }\n          if (this._lookahead(0) === TOK_STAR\n                       && this._lookahead(1) === TOK_RBRACKET) {\n            this._advance();\n            this._advance();\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: 'Projection',\n              children: [{ type: 'Identity' }, right],\n            };\n          }\n          return this._parseMultiselectList();\n        case TOK_CURRENT:\n          return { type: TOK_CURRENT };\n        case TOK_GLOBAL:\n          return { type: TOK_GLOBAL, value: token.value };\n        case TOK_FIELD:\n          return { type: TOK_FIELD };\n        case TOK_EXPREF:\n          expression = this.expression(bindingPower.Expref);\n          return { type: 'ExpressionReference', children: [expression] };\n        case TOK_LPAREN:\n          args = [];\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = { type: TOK_CURRENT };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          return args[0];\n        default:\n          this._errorToken(token);\n      }\n    },\n\n    // eslint-disable-next-line consistent-return\n    led(tokenName, left) {\n      let condition;\n      let right;\n      let name;\n      let args;\n      let expression;\n      let node;\n      let rbp;\n      let leftNode;\n      let rightNode;\n      let token;\n      switch (tokenName) {\n        case TOK_CONCATENATE:\n          right = this.expression(bindingPower.Concatenate);\n          return { type: 'ConcatenateExpression', children: [left, right] };\n        case TOK_DOT:\n          rbp = bindingPower.Dot;\n          if (this._lookahead(0) !== TOK_STAR) {\n            right = this._parseDotRHS(rbp);\n            return { type: 'Subexpression', children: [left, right] };\n          }\n          // Creating a projection.\n          this._advance();\n          right = this._parseProjectionRHS(rbp);\n          return { type: 'ValueProjection', children: [left, right] };\n        case TOK_PIPE:\n          right = this.expression(bindingPower.Pipe);\n          return { type: TOK_PIPE, children: [left, right] };\n        case TOK_OR:\n          right = this.expression(bindingPower.Or);\n          return { type: 'OrExpression', children: [left, right] };\n        case TOK_AND:\n          right = this.expression(bindingPower.And);\n          return { type: 'AndExpression', children: [left, right] };\n        case TOK_ADD:\n          right = this.expression(bindingPower.Add);\n          return { type: 'AddExpression', children: [left, right] };\n        case TOK_SUBTRACT:\n          right = this.expression(bindingPower.Subtract);\n          return { type: 'SubtractExpression', children: [left, right] };\n        case TOK_MULTIPLY:\n          right = this.expression(bindingPower.Multiply);\n          return { type: 'MultiplyExpression', children: [left, right] };\n        case TOK_DIVIDE:\n          right = this.expression(bindingPower.Divide);\n          return { type: 'DivideExpression', children: [left, right] };\n        case TOK_POWER:\n          right = this.expression(bindingPower.Power);\n          return { type: 'PowerExpression', children: [left, right] };\n        case TOK_LPAREN:\n          name = left.name;\n          args = [];\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = { type: TOK_CURRENT };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          node = { type: 'Function', name, children: args };\n          return node;\n        case TOK_FILTER:\n          condition = this.expression(0);\n          this._match(TOK_RBRACKET);\n          if (this._lookahead(0) === TOK_FLATTEN) {\n            right = { type: 'Identity' };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Filter);\n          }\n          return { type: 'FilterProjection', children: [left, right, condition] };\n        case TOK_FLATTEN:\n          leftNode = { type: TOK_FLATTEN, children: [left] };\n          rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n          return { type: 'Projection', children: [leftNode, rightNode] };\n        case TOK_EQ:\n        case TOK_NE:\n        case TOK_GT:\n        case TOK_GTE:\n        case TOK_LT:\n        case TOK_LTE:\n          return this._parseComparator(left, tokenName);\n        case TOK_LBRACKET:\n          token = this._lookaheadToken(0);\n          if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice(left, right);\n          }\n          this._match(TOK_STAR);\n          this._match(TOK_RBRACKET);\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return { type: 'Projection', children: [left, right] };\n        default:\n          this._errorToken(this._lookaheadToken(0));\n      }\n    },\n\n    _match(tokenType) {\n      if (this._lookahead(0) === tokenType) {\n        this._advance();\n      } else {\n        const t = this._lookaheadToken(0);\n        const error = new Error(`Expected ${tokenType}, got: ${t.type}`);\n        error.name = 'ParserError';\n        throw error;\n      }\n    },\n\n    _errorToken(token) {\n      const error = new Error(`Invalid token (${\n        token.type}): \"${\n        token.value}\"`);\n      error.name = 'ParserError';\n      throw error;\n    },\n\n    _parseIndexExpression() {\n      if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n        return this._parseSliceExpression();\n      }\n      const node = {\n        type: 'Index',\n        value: this._lookaheadToken(0).value,\n      };\n      this._advance();\n      this._match(TOK_RBRACKET);\n      return node;\n    },\n\n    _projectIfSlice(left, right) {\n      const indexExpr = { type: 'IndexExpression', children: [left, right] };\n      if (right.type === 'Slice') {\n        return {\n          type: 'Projection',\n          children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],\n        };\n      }\n      return indexExpr;\n    },\n\n    _parseSliceExpression() {\n      // [start:end:step] where each part is optional, as well as the last\n      // colon.\n      const parts = [null, null, null];\n      let index = 0;\n      let currentToken = this._lookahead(0);\n      while (currentToken !== TOK_RBRACKET && index < 3) {\n        if (currentToken === TOK_COLON) {\n          index += 1;\n          this._advance();\n        } else if (currentToken === TOK_NUMBER) {\n          parts[index] = this._lookaheadToken(0).value;\n          this._advance();\n        } else {\n          const t = this._lookahead(0);\n          const error = new Error(`Syntax error, unexpected token: ${\n            t.value}(${t.type})`);\n          error.name = 'Parsererror';\n          throw error;\n        }\n        currentToken = this._lookahead(0);\n      }\n      this._match(TOK_RBRACKET);\n      return {\n        type: 'Slice',\n        children: parts,\n      };\n    },\n\n    _parseComparator(left, comparator) {\n      const right = this.expression(bindingPower[comparator]);\n      return { type: 'Comparator', name: comparator, children: [left, right] };\n    },\n\n    // eslint-disable-next-line consistent-return\n    _parseDotRHS(rbp) {\n      const lookahead = this._lookahead(0);\n      const exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n      if (exprTokens.indexOf(lookahead) >= 0) {\n        return this.expression(rbp);\n      }\n      if (lookahead === TOK_LBRACKET) {\n        this._match(TOK_LBRACKET);\n        return this._parseMultiselectList();\n      }\n      if (lookahead === TOK_LBRACE) {\n        this._match(TOK_LBRACE);\n        return this._parseMultiselectHash();\n      }\n    },\n\n    _parseProjectionRHS(rbp) {\n      let right;\n      if (bindingPower[this._lookahead(0)] < 10) {\n        right = { type: 'Identity' };\n      } else if (this._lookahead(0) === TOK_LBRACKET) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_FILTER) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_DOT) {\n        this._match(TOK_DOT);\n        right = this._parseDotRHS(rbp);\n      } else {\n        const t = this._lookaheadToken(0);\n        const error = new Error(`Sytanx error, unexpected token: ${\n          t.value}(${t.type})`);\n        error.name = 'ParserError';\n        throw error;\n      }\n      return right;\n    },\n\n    _parseMultiselectList() {\n      const expressions = [];\n      while (this._lookahead(0) !== TOK_RBRACKET) {\n        const expression = this.expression(0);\n        expressions.push(expression);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            throw new Error('Unexpected token Rbracket');\n          }\n        }\n      }\n      this._match(TOK_RBRACKET);\n      return { type: 'MultiSelectList', children: expressions };\n    },\n\n    _parseMultiselectHash() {\n      const pairs = [];\n      const identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n      let keyToken; let keyName; let value; let\n        node;\n      for (;;) {\n        keyToken = this._lookaheadToken(0);\n        if (identifierTypes.indexOf(keyToken.type) < 0) {\n          throw new Error(`Expecting an identifier token, got: ${\n            keyToken.type}`);\n        }\n        keyName = keyToken.value;\n        this._advance();\n        this._match(TOK_COLON);\n        value = this.expression(0);\n        node = { type: 'KeyValuePair', name: keyName, value };\n        pairs.push(node);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n        } else if (this._lookahead(0) === TOK_RBRACE) {\n          this._match(TOK_RBRACE);\n          break;\n        }\n      }\n      return { type: 'MultiSelectHash', children: pairs };\n    },\n  };\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n    search(node, value) {\n      return this.visit(node, value);\n    },\n\n    visit(node, value) {\n      let matched;\n      let current;\n      let result;\n      let first;\n      let second;\n      let field;\n      let left;\n      let right;\n      let collected;\n      let i;\n      let child;\n      let base;\n      let index;\n      let sliceParams;\n      let computed;\n      let start;\n      let stop;\n      let step;\n      let values;\n      let filtered;\n      let finalResults;\n      let original;\n      let merged;\n      let resolvedArgs;\n      let refNode;\n\n      switch (node.type) {\n        case 'Field':\n          if (value !== null && isObject(value)) {\n            field = value[node.name];\n            if (field === undefined) {\n              return null;\n            }\n            return field;\n          }\n          return null;\n        case 'Subexpression':\n          result = this.visit(node.children[0], value);\n          for (i = 1; i < node.children.length; i += 1) {\n            result = this.visit(node.children[1], result);\n            if (result === null) {\n              return null;\n            }\n          }\n          return result;\n        case 'IndexExpression':\n          left = this.visit(node.children[0], value);\n          right = this.visit(node.children[1], left);\n          return right;\n        case 'Index':\n          if (!isArray(value)) {\n            return null;\n          }\n          index = node.value;\n          if (index < 0) {\n            index = value.length + index;\n          }\n          result = value[index];\n          if (result === undefined) {\n            result = null;\n          }\n          return result;\n        case 'Slice':\n          if (!isArray(value)) {\n            return null;\n          }\n          sliceParams = node.children.slice(0);\n          computed = this.computeSliceParams(value.length, sliceParams);\n          [start, stop, step] = computed;\n          result = [];\n          if (step > 0) {\n            for (i = start; i < stop; i += step) {\n              result.push(value[i]);\n            }\n          } else {\n            for (i = start; i > stop; i += step) {\n              result.push(value[i]);\n            }\n          }\n          return result;\n        case 'Projection':\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < base.length; i += 1) {\n            current = this.visit(node.children[1], base[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case 'ValueProjection':\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n          if (!isObject(valueOf(base))) {\n            return null;\n          }\n          collected = [];\n          values = objValues(base);\n          for (i = 0; i < values.length; i += 1) {\n            current = this.visit(node.children[1], values[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case 'FilterProjection':\n          base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          filtered = [];\n          finalResults = [];\n          for (i = 0; i < base.length; i += 1) {\n            matched = this.visit(node.children[2], base[i]);\n            if (!isFalse(matched)) {\n              filtered.push(base[i]);\n            }\n          }\n          for (let j = 0; j < filtered.length; j += 1) {\n            current = this.visit(node.children[1], filtered[j]);\n            if (current !== null) {\n              finalResults.push(current);\n            }\n          }\n          return finalResults;\n        case 'Comparator':\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          switch (node.name) {\n            case TOK_EQ:\n              result = strictDeepEqual(first, second);\n              break;\n            case TOK_NE:\n              result = !strictDeepEqual(first, second);\n              break;\n            case TOK_GT:\n              result = first > second;\n              break;\n            case TOK_GTE:\n              result = first >= second;\n              break;\n            case TOK_LT:\n              result = first < second;\n              break;\n            case TOK_LTE:\n              result = first <= second;\n              break;\n            default:\n              throw new Error(`Unknown comparator: ${node.name}`);\n          }\n          return result;\n        case TOK_FLATTEN:\n          original = this.visit(node.children[0], value);\n          if (!isArray(original)) {\n            return null;\n          }\n          merged = [];\n          for (i = 0; i < original.length; i += 1) {\n            current = original[i];\n            if (isArray(current)) {\n              merged.push(...current);\n            } else {\n              merged.push(current);\n            }\n          }\n          return merged;\n        case 'Identity':\n          return value;\n        case 'MultiSelectList':\n          if (value === null) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < node.children.length; i += 1) {\n            collected.push(this.visit(node.children[i], value));\n          }\n          return collected;\n        case 'MultiSelectHash':\n          if (value === null) {\n            return null;\n          }\n          collected = {};\n          for (i = 0; i < node.children.length; i += 1) {\n            child = node.children[i];\n            collected[child.name] = this.visit(child.value, value);\n          }\n          return collected;\n        case 'OrExpression':\n          matched = this.visit(node.children[0], value);\n          if (isFalse(matched)) {\n            matched = this.visit(node.children[1], value);\n          }\n          return matched;\n        case 'AndExpression':\n          first = this.visit(node.children[0], value);\n\n          if (isFalse(first) === true) {\n            return first;\n          }\n          return this.visit(node.children[1], value);\n        case 'AddExpression':\n          first = this.visit(node.children[0], value);\n          return toNumber(first) + toNumber(this.visit(node.children[1], value));\n        case 'ConcatenateExpression':\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          first = matchType(getTypeNames(first), [TYPE_STRING, TYPE_ARRAY_STRING], first, 'concatenate');\n          second = matchType(getTypeNames(second), [TYPE_STRING, TYPE_ARRAY_STRING], second, 'concatenate');\n          return applyOperator(first, second, '&');\n        case 'SubtractExpression':\n          first = this.visit(node.children[0], value);\n          return first - this.visit(node.children[1], value);\n        case 'MultiplyExpression':\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          return applyOperator(first, second, '*');\n        case 'DivideExpression':\n          first = this.visit(node.children[0], value);\n          return first / this.visit(node.children[1], value);\n        case 'PowerExpression':\n          first = this.visit(node.children[0], value);\n          return first ** this.visit(node.children[1], value);\n        case 'NotExpression':\n          first = this.visit(node.children[0], value);\n          return isFalse(first);\n        case 'Literal':\n          return node.value;\n        case 'Number':\n          return node.value;\n        case TOK_PIPE:\n          left = this.visit(node.children[0], value);\n          return this.visit(node.children[1], left);\n        case TOK_CURRENT:\n          return value;\n        case TOK_GLOBAL:\n          return node.value;\n        case 'Function':\n          // Special case for if()\n          // we need to make sure the results are called only after the condition is evaluated\n          // Otherwise we end up with both results invoked -- which could include side effects\n          if (node.name === 'if') {\n            return this.runtime.callFunction(node.name, node.children, value);\n          }\n          resolvedArgs = [];\n          for (i = 0; i < node.children.length; i += 1) {\n            resolvedArgs.push(this.visit(node.children[i], value));\n          }\n          return this.runtime.callFunction(node.name, resolvedArgs);\n        case 'ExpressionReference':\n          [refNode] = node.children;\n          // Tag the node with a specific attribute so the type\n          // checker verify the type.\n          refNode.jmespathType = TOK_EXPREF;\n          return refNode;\n        default:\n          throw new Error(`Unknown node type: ${node.type}`);\n      }\n    },\n\n    computeSliceParams(arrayLength, sliceParams) {\n      let start = sliceParams[0];\n      let stop = sliceParams[1];\n      let step = sliceParams[2];\n      const computed = [null, null, null];\n      if (step === null) {\n        step = 1;\n      } else if (step === 0) {\n        const error = new Error('Invalid slice, step cannot be 0');\n        error.name = 'RuntimeError';\n        throw error;\n      }\n      const stepValueNegative = step < 0;\n\n      if (start === null) {\n        start = stepValueNegative ? arrayLength - 1 : 0;\n      } else {\n        start = this.capSliceRange(arrayLength, start, step);\n      }\n\n      if (stop === null) {\n        stop = stepValueNegative ? -1 : arrayLength;\n      } else {\n        stop = this.capSliceRange(arrayLength, stop, step);\n      }\n      computed[0] = start;\n      computed[1] = stop;\n      computed[2] = step;\n      return computed;\n    },\n\n    capSliceRange(arrayLength, actualValue, step) {\n      if (actualValue < 0) {\n        actualValue += arrayLength;\n        if (actualValue < 0) {\n          actualValue = step < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLength) {\n        actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n      }\n      return actualValue;\n    },\n  };\n\n  function Runtime() {}\n\n  Runtime.prototype = {\n    addFunctions(customFunctions = {}) {\n      this.functionTable = {\n        ...functions(\n          this._interpreter,\n          isObject,\n          isArray,\n          toNumber,\n          getTypeName,\n          valueOf,\n          toString,\n        ),\n        ...openFormulaFunctions(this._interpreter, valueOf, toString),\n        ...customFunctions,\n      };\n    },\n\n    callFunction(name, resolvedArgs, data) {\n      const functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n        throw new Error(`Unknown function: ${name}()`);\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs, data);\n    },\n\n    _validateArgs(name, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      if (signature.length === 0) {\n        return;\n      }\n      let pluralized;\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? ' argument' : ' arguments';\n          throw new Error(`ArgumentError: ${name}() `\n                                + `takes at least${signature.length}${pluralized\n                                } but received ${args.length}`);\n        }\n      } else if (args.length !== signature.length && !signature[signature.length - 1].optional) {\n        pluralized = signature.length === 1 ? ' argument' : ' arguments';\n        throw new Error(`ArgumentError: ${name}() `\n                            + `takes ${signature.length}${pluralized\n                            } but received ${args.length}`);\n      }\n      let currentSpec;\n      let actualType;\n      const limit = Math.min(signature.length, args.length);\n      for (let i = 0; i < limit; i += 1) {\n        currentSpec = signature[i].types;\n        // First check for a match using matchClass\n        // this check will not call valueOf or toString on the object, and so\n        // will not trigger a dependency\n        if (!matchClass(args[i], currentSpec)) {\n          actualType = getTypeNames(args[i]);\n          args[i] = matchType(actualType, currentSpec, args[i], name);\n        }\n      }\n    },\n  };\n\n  function compile(stream) {\n    const parser = new Parser();\n    const ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n    const lexer = new Lexer();\n    return lexer.tokenize(stream);\n  }\n\n  function search(data, globals, expression, customFunctions) {\n    const parser = new Parser();\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    const runtime = new Runtime(customFunctions);\n    const interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    runtime.addFunctions(customFunctions);\n    if (globals) globalTokens = globals;\n    const node = parser.parse(expression);\n    return interpreter.search(node, data);\n  }\n  this.tokenize = tokenize;\n  this.compile = compile;\n  this.search = search;\n  this.strictDeepEqual = strictDeepEqual;\n}\n\nexport default new JsonFormula();\n","/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable class-methods-use-this */\n/*\n    Field class allows objects to evaluate correctly according to context.\n    - if used in an expression, will return a value or string.\n    - for JSON.stringify() returns a scalar\n    - BUT also allows explicit access to properties. e.g. field.required, field.name etc.\n\n    Should allow us to eliminate getFieldProperty()\n  */\n\nfunction createField(name, value, readonly = false, required = true) {\n  class Field {\n    valueOf() { return value; }\n\n    toString() { return value.toString(); }\n\n    toJSON() { return value; }\n\n    // Use getters and scope variables so that the children are not enumerable\n    get '$value'() { return value; }\n\n    get '$name'() { return name; }\n\n    get '$readonly'() { return readonly; }\n\n    get '$required'() { return required; }\n  }\n  const newField = new Field();\n  return newField;\n}\n\nfunction createFields(parent, childref, child) {\n  const result = [];\n  if (child instanceof Array) {\n    parent[childref] = [];\n    child.forEach((item, index) => {\n      const fields = createFields(parent[childref], index, item);\n      result.push(...fields);\n    });\n  } else if (child !== null && typeof child === 'object') {\n    parent[childref] = {};\n    Object.keys(child).forEach(k => {\n      const fields = createFields(parent[childref], k, child[k]);\n      result.push(...fields);\n    });\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    const field = createField(childref, child);\n    parent[childref] = field;\n    result.push(field);\n  }\n  return result;\n}\n\nexport default class Form {\n  constructor(fieldData, dataRoot) {\n    this.fieldData = fieldData;\n    this.allFields = createFields(fieldData, 'data', dataRoot);\n    Object.keys(fieldData.data).forEach(k => {\n      this[k] = fieldData.data[k];\n    });\n  }\n\n  valueOf() { return this.fieldData; }\n\n  stringify() { return JSON.stringify(this.fieldData.data, null, 2); }\n\n  get '$fields'() { return this.allFields; }\n}\n","/* eslint-disable no-param-reassign */\n/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n/* global window, document, fetch */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable-next-line max-classes-per-file */\nimport { jsonFormula } from './json-formula';\nimport Form from './Form';\n\nwindow.addEventListener('load', () => {\n  const dataElement = document.getElementById('data');\n  const expression = document.getElementById('expression');\n  const result = document.getElementById('result');\n\n  const d = window.localStorage.getItem('data');\n  if (d) dataElement.value = d;\n  const exp = window.localStorage.getItem('expression');\n  if (exp) expression.value = exp;\n\n  function run() {\n    // save for next time...\n    window.localStorage.setItem('data', dataElement.value);\n    window.localStorage.setItem('expression', expression.value);\n    const input = expression.value;\n    const useFields = document.getElementById('use-fields').checked;\n    let root = null;\n    const fieldData = {};\n    let jsonData;\n    try {\n      jsonData = JSON.parse(dataElement.value);\n      if (useFields) {\n        root = new Form(fieldData, jsonData);\n      }\n    } catch (e) {\n      result.value = e.toString();\n      return;\n    }\n\n    try {\n      const jsonResult = jsonFormula(\n        useFields ? fieldData.data : jsonData,\n        { $form: root, $: {} },\n        input,\n        true,\n      );\n      const r = jsonResult === null || jsonResult === undefined ? jsonResult : jsonResult.valueOf();\n      if (typeof r === 'object') {\n        result.value = JSON.stringify(r, null, 2);\n      } else {\n        result.value = r;\n      }\n    } catch (e) {\n      result.value = e.toString();\n    }\n  }\n\n  dataElement.addEventListener('blur', run);\n  expression.addEventListener('blur', run);\n  run();\n\n  fetch('../antlr/JSONFormula.g4').then(r => {\n    r.text().then(g4 => {\n      document.getElementById('grammar-out').innerHTML = g4;\n    });\n  });\n});\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport jmespath from '../jmespath.js/jmespath';\n\n// eslint-disable-next-line import/prefer-default-export\nexport function jsonFormula(json, globals, expression, customFunctions = {}) {\n  const x = jmespath.search(json, globals, expression, { ...customFunctions });\n  return x;\n}\n"],"names":["exports","Symbol","toStringTag","Object","defineProperty","value","openFormulaFunctions","interpreter","valueOf","toString","and","_func","resolveArgs","_signature","types","or","not","true","false","if","unresolvedArgs","data","conditionNode","leftBranchNode","rightBranchNode","condition","visit","substitute","args","src","old","replacement","length","replace","RegExp","whch","pos","i","nextFind","slice","indexOf","optional","result","undefined","lower","toLowerCase","upper","toUpperCase","exp","Math","power","base","find","text","query","startPos","left","numChars","substr","right","start","mid","proper","split","map","word","charAt","join","rept","count","repeat","oldText","startNum","newText","round","number","digits","sqrt","Number","isNaN","stdevp","values","mean","reduce","a","b","meanSumSquare","stdev","sumSquare","trim","filter","x","trunc","floor","ceil","charCode","code","isInteger","String","fromCharCode","codePoint","codePointAt","functions","isObject","isArray","toNumber","getTypeName","TYPE_NUMBER","TYPE_STRING","createKeyFunction","exprefNode","allowedTypes","current","msg","Error","abs","resolvedArgs","avg","sum","inputArray","contains","endsWith","searchStr","suffix","arg","keys","mapped","elements","push","max","prev","cur","localeCompare","merge","merged","forEach","key","variadic","maxBy","maxRecord","resolvedArray","keyFunction","maxNumber","listToSum","startsWith","lastIndexOf","min","minElement","minBy","minRecord","minNumber","Infinity","type","sort","sortedArray","normalize","va","vb","sortBy","requiredType","decorated","exprA","exprB","j","joinChar","reverse","originalStr","reversedStr","reversedArray","toArray","JSON","stringify","typeName","notNull","TYPE_ARRAY","TYPE_BOOLEAN","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","trimLeft","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_CONCATENATE","TOK_RBRACE","TOK_NUMBER","TOK_CURRENT","TOK_GLOBAL","TOK_FIELD","TOK_EXPREF","TOK_PIPE","TOK_OR","TOK_AND","TOK_ADD","TOK_SUBTRACT","TOK_MULTIPLY","TOK_POWER","TOK_DIVIDE","TOK_EQ","TOK_GT","TOK_LT","TOK_GTE","TOK_LTE","TOK_NE","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_DOT","TOK_LBRACE","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","TYPE_NAME_TABLE","globalTokens","isNum","ch","includeSign","isAlphaNum","obj","prototype","call","inputObj","useValueOf","jmespathType","getTypeNames","strictDeepEqual","lhs","rhs","first","second","keysSeen","hasOwnProperty","key2","isFalse","n","Array","temp","parseFloat","applyOperator","operator","len","arr","scalar","matchType","actuals","expectedList","argValue","context","actual","findIndex","expected","includes","e","subtype","returnArray","indexType","str","match","basicTokens","operatorStartToken","skipChars","isIdentifier","stream","isGlobal","global","Lexer","tokenize","identifier","token","tokens","this","_current","_consumeGlobal","_consumeUnquotedIdentifier","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","prevToken","error","name","maxLength","parse","parseInt","startingChar","literalString","_looksLikeJSON","ex","bindingPower","Parser","TreeInterpreter","runtime","Runtime","expression","_loadTokens","index","ast","_lookahead","t","_lookaheadToken","rbp","leftToken","_advance","nud","currentToken","led","node","tok","children","Not","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseMultiselectList","_parseIndexExpression","_projectIfSlice","Expref","_match","_errorToken","tokenName","Concatenate","Dot","_parseDotRHS","Pipe","Or","And","Add","Subtract","Multiply","Divide","Power","Filter","_parseComparator","tokenType","_parseSliceExpression","indexExpr","parts","comparator","lookahead","expressions","keyToken","keyName","pairs","identifierTypes","search","matched","field","collected","child","sliceParams","stop","step","filtered","finalResults","original","refNode","computeSliceParams","objValues","callFunction","arrayLength","computed","stepValueNegative","capSliceRange","actualValue","addFunctions","customFunctions","functionTable","_interpreter","functionEntry","_validateArgs","signature","pluralized","currentSpec","actualType","limit","constructor","compile","globals","parser","createFields","parent","childref","item","fields","k","readonly","required","createField","Form","fieldData","dataRoot","allFields","window","addEventListener","dataElement","document","getElementById","d","localStorage","getItem","run","setItem","jsonData","input","useFields","checked","root","jsonResult","json","jmespath","jsonFormula","$form","$","r","fetch","then","g4","innerHTML"],"sourceRoot":""}