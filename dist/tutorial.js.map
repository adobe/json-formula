{"version":3,"file":"tutorial.js","mappings":"mCACA,I,KCAwB,CAACA,IACH,oBAAXC,QAA0BA,OAAOC,aAC1CC,OAAOC,eAAeJ,EAASC,OAAOC,YAAa,CAAEG,MAAO,WAE7DF,OAAOC,eAAeJ,EAAS,aAAc,CAAEK,OAAO,K,ICJvD,MCCA,GAEEC,WAAY,CACVC,MAAO,SAAAC,GACL,IAAMC,EAAMD,EAAK,GAAGE,WACdC,EAAMH,EAAK,GAAGE,WACdE,EAAcJ,EAAK,GAAGE,WAE5B,GAAIF,EAAKK,QAAU,EAAG,OAAOJ,EAAIK,QAAQ,IAAIC,OAAOJ,EAAK,KAAMC,GAI/D,IAHA,IAAMI,EAAOR,EAAK,GAAGS,UAEjBC,GAAO,EACFC,EAAI,EAAGA,EAAIH,EAAMG,GAAK,EAAG,CAChCD,GAAO,EACP,IAAME,EAAWX,EAAIY,MAAMH,GAAKI,QAAQX,GAExC,IAAkB,IAAdS,EAAiB,OAAOX,EAC5BS,GAAOE,EAGT,OADeX,EAAIY,MAAM,EAAGH,GAAOT,EAAIY,MAAMH,GAAKJ,QAAQH,EAAKC,IAGjEW,WAAY,CACV,CAAEC,MAAO,CDrBA,ICsBT,CAAEA,MAAO,CDtBA,ICuBT,CAAEA,MAAO,CDvBA,ICwBT,CAAEA,MAAO,CD1BA,GC0ByBC,UAAU,M,gnDCrBlD,IACEC,EFNa,EEQbC,EFNa,EEObC,EFNY,EEQZC,EFNc,EEQdC,EFNW,EEOXC,EFNmB,EEOnBC,EFNmB,EE08DrB,YAj8DA,WACE,IA8VIC,EA7VEC,EAAyB,qBACzBC,EAAuB,mBACvBC,EAAe,WACfC,EAAa,SACbC,EAAY,QACZC,EAAY,QACZC,EAAkB,cAClBC,EAAa,SACbC,EAAa,SACbC,EAAc,UACdC,EAAa,SACbC,EAAY,QACZC,EAAa,SACbC,EAAW,OACXC,EAAS,KACTC,EAAU,MACVC,EAAU,MACVC,EAAe,WACfC,EAAe,WACfC,EAAY,QACZC,EAAa,SACbC,EAAS,KACTC,EAAS,KACTC,EAAS,KACTC,EAAU,MACVC,EAAU,MACVC,EAAS,KACTC,EAAc,UACdC,EAAW,OACXC,EAAa,SACbC,EAAU,MAEVC,EAAa,SACbC,EAAe,WACfC,EAAa,SACbC,EAAc,UAEdC,EAAkB,CACtB,EAAG,SACH,EAAG,MACH,EAAG,SACH,EAAG,QACH,EAAG,SACH,EAAG,UACH,EAAG,aACH,EAAG,OACH,EAAG,gBACH,EAAG,iBAGDC,EAAe,GAEnB,SAASC,EAAMC,EAAIC,GACjB,OAAQD,GAAM,KAAOA,GAAM,KACdC,GAAsB,MAAPD,GACR,MAAPA,EAGf,SAASE,EAAWF,GAClB,OAAQA,GAAM,KAAOA,GAAM,KACdA,GAAM,KAAOA,GAAM,KACnBA,GAAM,KAAOA,GAAM,KACb,MAAPA,EAoBd,SAASG,EAAQC,GACf,OAAY,OAARA,GAC6C,mBAAxCzE,OAAO0E,UAAUnE,SAASoE,KAAKF,GAK1C,SAAS3D,EAAQ8D,GACf,OAAIA,MAAAA,EAAsCA,EACtCJ,EAAQI,GACHA,EAAEC,KAAI,SAAA7D,GAAC,OAAIF,EAAQE,MAErB4D,EAAE9D,UAGX,SAASP,GAASqE,GAChB,OAAIA,MAAAA,EAAsC,GACnCA,EAAErE,WAGX,SAASuE,GAASL,GAChB,OAAY,OAARA,GAC6C,oBAAxCzE,OAAO0E,UAAUnE,SAASoE,KAAKF,GAK1C,SAASM,GAAYC,GACnB,GAAiB,OAAbA,EAAmB,OAAOrD,EAC9B,IAAM8C,EAAMO,EAASlE,UACrB,OAAQd,OAAO0E,UAAUnE,SAASoE,KAAKF,IACrC,IAAK,kBACH,OAAOjD,EACT,IAAK,kBACH,OAAOD,EACT,IAAK,iBACH,OAAOE,EACT,IAAK,mBACH,OAAOC,EACT,IAAK,gBACH,OAAOC,EACT,IAAK,kBAGH,OAAI8C,EAAIQ,eAAiBtC,EF5IlB,EAFA,EEkJT,QACE,OFnJO,GEuJb,SAASuC,GAAgBC,EAAKC,GAC5B,IAAMC,EAAQvE,EAAQqE,GAChBG,EAASxE,EAAQsE,GAEvB,GAAIC,IAAUC,EACZ,OAAO,EAKT,GADkBtF,OAAO0E,UAAUnE,SAASoE,KAAKU,KAC/BrF,OAAO0E,UAAUnE,SAASoE,KAAKW,GAC/C,OAAO,EAIT,IAAuB,IAAnBd,EAAQa,GAAiB,CAE3B,GAAIA,EAAM3E,SAAW4E,EAAO5E,OAC1B,OAAO,EAET,IAAK,IAAIM,EAAI,EAAGA,EAAIqE,EAAM3E,OAAQM,GAAK,EACrC,IAA6C,IAAzCkE,GAAgBG,EAAMrE,GAAIsE,EAAOtE,IACnC,OAAO,EAGX,OAAO,EAET,IAAwB,IAApB8D,GAASO,GAAiB,CAE5B,IAAME,EAAW,GACjB,IAAK,IAAMC,KAAOH,EAChB,GAAII,eAAed,KAAKU,EAAOG,GAAM,CACnC,IAAiD,IAA7CN,GAAgBG,EAAMG,GAAMF,EAAOE,IACrC,OAAO,EAETD,EAASC,IAAO,EAKpB,IAAK,IAAME,KAAQJ,EACjB,GAAIG,eAAed,KAAKW,EAAQI,KACP,IAAnBH,EAASG,GACX,OAAO,EAIb,OAAO,EAET,OAAO,EAGT,SAASC,GAAQzF,GAYf,GAAc,OAAVA,EAAgB,OAAO,EAE3B,IAAMuE,EAAM3D,EAAQZ,GACpB,GAAY,KAARuE,IAAsB,IAARA,GAAyB,OAARA,EACjC,OAAO,EAET,GAAID,EAAQC,IAAuB,IAAfA,EAAI/D,OAEtB,OAAO,EAET,GAAIoE,GAASL,GAAM,CAEjB,IAAK,IAAMe,KAAOf,EAIhB,GAAIzE,OAAO0E,UAAUe,eAAed,KAAKF,EAAKe,GAC5C,OAAO,EAGX,OAAO,EAET,OAAQf,EAYV,SAASmB,GAAS1F,GAChB,IAAM2F,EAAI/E,EAAQZ,GAClB,GAAU,OAAN2F,EAAY,OAAO,EACvB,GAAIA,aAAaC,MAAO,OAAO,EAC/B,GAAiB,iBAAND,EAAgB,OAAOA,EAClC,GAAiB,iBAANA,EAAgB,CACzB,IAAME,EAAOC,WAAWH,GACxB,OAAOI,OAAOC,MAAMH,GAAQ,EAAIA,EAElC,GAAiB,kBAANF,EAAiB,OAAOA,EAAI,EAAI,EAG3C,MAAM,IAAIM,MAAM,yBAGlB,SAASC,GAAcf,EAAOC,EAAQe,GAEpC,GAAI7B,EAAQa,IAAUb,EAAQc,GAAS,CACrC,IAEItE,EAFEsF,EAAMC,KAAKC,IAAInB,EAAM3E,OAAQ4E,EAAO5E,QACpC+F,EAAS,GAEf,IAAKzF,EAAI,EAAGA,EAAIsF,EAAKtF,GAAK,EACxB,GAAIwD,EAAQa,EAAMrE,KAAOwD,EAAQc,EAAOtE,IACtCyF,EAAOC,KAAKN,GAAcf,EAAMrE,GAAIsE,EAAOtE,GAAIqF,SAC1C,GAAiB,MAAbA,EACTI,EAAOC,KAAKrB,EAAMrE,GAAKsE,EAAOtE,QACzB,IAAiB,MAAbqF,EAEJ,MAAM,IAAIF,MAAM,iBADrBM,EAAOC,KAAKrB,EAAMrE,GAAKsE,EAAOtE,IAGlC,IAAKA,EAAIsF,EAAKtF,EAAIuF,KAAKI,IAAItB,EAAM3E,OAAQ4E,EAAO5E,QAASM,GAAK,EAE3C,MAAbqF,EAAkBI,EAAOC,KAAK,IACZ,MAAbL,GAAkBI,EAAOC,KAAK,GAEzC,OAAOD,EAGT,GAAIjC,EAAQa,IAAUb,EAAQc,GAAS,CACrC,QAAsBd,EAAQa,GAAS,CAACA,EAAOC,GAAU,CAACA,EAAQD,GAAlE,GAAOuB,EAAP,KAAYC,EAAZ,KACA,GAAiB,MAAbR,EAAkB,OAAOO,EAAI/B,KAAI,SAAAD,GAAC,OAAIgB,GAAShB,GAAKgB,GAASiB,MACjE,GAAiB,MAAbR,EAAkB,OAAOO,EAAI/B,KAAI,SAAAD,GAAC,OAAIA,EAAIiC,KAEhD,GAAiB,MAAbR,EAAkB,OAAOT,GAASP,GAASO,GAASN,GACxD,GAAiB,MAAbe,EAAkB,OAAOhB,EAAQC,EACrC,MAAM,IAAIa,MAAJ,wCAA2CE,IAEnD,SAASS,GAAUC,EAAQC,EAAcC,EAAUC,GACjD,IAEO,IAFHF,EAAaG,WACf,SAAAC,GAAI,OF7SE,IE6SEA,GAAqBL,IAAWK,KAExC,OAAOH,EAET,GF9SW,IE8SPF,EACF,MAAM,IAAIZ,MAAJ,qBAAwBe,EAAxB,yCAAgEhD,EAAgB8C,EAAa,IAA7F,8BAAsH9C,EAAgB6C,GAAtI,cAGR,IAAIM,GAAY,EAehB,GAdIN,IAAWtF,GACTuF,EAAaM,SAASzF,IAAsBmF,EAAaM,SAAS1F,KAERyF,EAAxDJ,EAASvG,OAAS,GAA4B,iBAAhBuG,EAAS,GAA4BpF,EACvDD,IAGF,IAAdyF,GAAmB,CAACxF,EAAmBD,EAAmBH,GAAY6F,SAASP,KACjFM,EAAWL,EAAaO,MACtB,SAAAC,GAAC,MAAI,CAAC3F,EAAmBD,EAAmBH,GAAY6F,SAASE,QAInD,IAAdH,IAAkBA,EAAtB,EAAkCL,EAAlC,OACIK,IAAaxF,GACVwF,IAAazF,GACbyF,IAAa5F,EAAY,CAC9B,GAAI4F,IAAa5F,EACf,OAAIsF,IAAWnF,GAAqBmF,IAAWlF,EAA0BoF,EACrD,OAAbA,EAAoB,GAAK,CAACA,GAInC,IAAMQ,EAAUJ,IAAazF,EAAoBL,EAAcC,EAC/D,GAAIuF,IAAWtF,EAAY,CAIzB,IADA,IAAMiG,EAAcT,EAAS/F,QACpBF,EAAI,EAAGA,EAAI0G,EAAYhH,OAAQM,GAAK,EAAG,CAC9C,IAAM2G,EAAY5C,GAAY2C,EAAY1G,IAC1C0G,EAAY1G,GAAK8F,GAAUa,EAAW,CAACF,GAAUC,EAAY1G,GAAIkG,GAEnE,OAAOQ,EAET,GAAI,CAACnG,EAAaC,EAAaG,EAAWD,GAAc4F,SAASG,GAC/D,MAAO,CAACX,GAAUC,EAAQ,CAACU,GAAUR,EAAUC,QAE5C,CACL,GAAIG,IAAa9F,EACf,OAAIwF,IAAWvF,EACNoE,GAASqB,GAEdF,IAAWrF,GAAqBuF,EAAW,EACd,EAInC,GAAII,IAAa7F,EACf,OAAIuF,IAAWpF,GFnWR,IEmWqBoF,EAA+B,GACpDE,EAAS1G,WAElB,GAAI8G,IAAa3F,EACf,QAASuF,EAGb,MAAM,IAAId,MAAM,sBAKhBrE,EADuC,mBAA9B8F,OAAOlD,UAAU5C,SACf,SAAA+F,GAAG,OAAIA,EAAI/F,YAEX,SAAA+F,GAAG,OAAIA,EAAIC,MAAM,YAAY,IAS1C,IAAMC,GAAc,CAClB,IAAKlE,EAEL,IAAK1B,EACL,IAAKC,EACL,IAAK0B,EACL,IAAKxB,EACL,IAAKL,EACL,IAAK+B,EACL,IAAK9B,EACL,IAAKM,GAIDwF,GAAqB,CACzB,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAGDC,GAAY,CAChB,KAAK,EACL,MAAM,EACN,MAAM,GAGR,SAASC,GAAaC,EAAQpH,GAC5B,IAAMsD,EAAK8D,EAAOpH,GAElB,MAAW,MAAPsD,EACK8D,EAAOzH,OAASK,GAAOwD,EAAW4D,EAAOpH,EAAM,IAGhDsD,GAAM,KAAOA,GAAM,KACfA,GAAM,KAAOA,GAAM,KACb,MAAPA,EAGb,SAAS+D,GAASC,EAAMF,EAAQpH,GAE9B,GAAa,OAATsH,GAAiBA,IAASxE,EAAS,OAAO,EAE9C,GA9BuB,MA6BZsE,EAAOpH,GACW,OAAO,EAGpC,IADA,IAAIC,EAAID,EAAM,EACPC,EAAImH,EAAOzH,QAAU6D,EAAW4D,EAAOnH,KAAKA,GAAK,EACxD,IAAMsH,EAASH,EAAOjH,MAAMH,EAAKC,GACjC,QAASmD,EAAamE,GAGxB,SAASC,MAETA,GAAM7D,UAAY,CAChB8D,SADgB,SACPL,GACP,IAEIM,EACAC,EACAC,EAJEC,EAAS,GAKf,IAJAC,KAAKC,SAAW,EAITD,KAAKC,SAAWX,EAAOzH,QAAQ,CACpC,IAAM2H,EAAOO,EAAOlI,OAASkI,EAAO1H,OAAO,GAAG,GAAGkG,KAAO,KAExD,GAAIgB,GAASC,EAAMF,EAAQU,KAAKC,UAC9BF,EAAOlC,KAAKmC,KAAKE,eAAeZ,SAC3B,GAAID,GAAaC,EAAQU,KAAKC,UACnCL,EAAQI,KAAKC,SACbJ,EAAaG,KAAKG,2BAA2Bb,GAC7CS,EAAOlC,KAAK,CACVU,KAAMrF,EACN7B,MAAOwI,EACPD,MAAAA,SAEG,QAA2CQ,IAAvClB,GAAYI,EAAOU,KAAKC,WACjCF,EAAOlC,KAAK,CACVU,KAAMW,GAAYI,EAAOU,KAAKC,WAC9B5I,MAAOiI,EAAOU,KAAKC,UACnBL,MAAOI,KAAKC,WAEdD,KAAKC,UAAY,OACZ,GAA+B,MAA1BX,EAAOU,KAAKC,WAAuBT,IAAS9F,GAAc8F,IAASnG,GAAgBkC,EAAM+D,EAAOU,KAAKC,WAAW,GAC1HH,EAAQE,KAAKK,eAAef,GAC5BS,EAAOlC,KAAKiC,QACP,GAA8B,MAA1BR,EAAOU,KAAKC,UAGrBH,EAAQE,KAAKM,iBAAiBhB,GAC9BS,EAAOlC,KAAKiC,QACP,GAA8B,MAA1BR,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbJ,EAAaG,KAAKO,yBAAyBjB,GAC3CS,EAAOlC,KAAK,CACVU,KAAMpF,EACN9B,MAAOwI,EACPD,MAAAA,SAEG,GAA8B,MAA1BN,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbJ,EAAaG,KAAKQ,yBAAyBlB,GAC3CS,EAAOlC,KAAK,CACVU,KAAMnD,EACN/D,MAAOwI,EACPD,MAAAA,SAEG,GAA8B,MAA1BN,EAAOU,KAAKC,UAAmB,CACxCL,EAAQI,KAAKC,SACb,IAAMQ,EAAUT,KAAKU,gBAAgBpB,GACrCS,EAAOlC,KAAK,CACVU,KAAMnD,EACN/D,MAAOoJ,EACPb,MAAAA,SAEG,QAAkDQ,IAA9CjB,GAAmBG,EAAOU,KAAKC,WACxCF,EAAOlC,KAAKmC,KAAKW,iBAAiBrB,SAC7B,QAAyCc,IAArChB,GAAUE,EAAOU,KAAKC,WAE/BD,KAAKC,UAAY,OACZ,GAA8B,MAA1BX,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EACa,MAA1BX,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACjBF,EAAOlC,KAAK,CAAEU,KAAMtE,EAAS5C,MAAO,KAAMuI,MAAAA,KACjCJ,IAASlG,GAAakG,IAASrE,EAIxC4E,EAAOlC,KAAK,CAAEU,KAAMzE,EAAYzC,MAAO,IAAKuI,MAAAA,IAE5CG,EAAOlC,KAAK,CAAEU,KAAM/E,EAAiBnC,MAAO,IAAKuI,MAAAA,SAE9C,GAA8B,MAA1BN,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EACjBF,EAAOlC,KAAK,CAAEU,KAAMrE,EAAS7C,MAAO,IAAKuI,MAAAA,SACpC,GAA8B,MAA1BN,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EACjBF,EAAOlC,KAAK,CAAEU,KAAMpE,EAAc9C,MAAO,IAAKuI,MAAAA,SACzC,GAA8B,MAA1BN,EAAOU,KAAKC,UAAmB,CACxCL,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EAGjB,IAAMW,EAAYb,EAAOlI,QAAUkI,EAAO1H,OAAO,GAAG,GAAGkG,KACjC,IAAlBwB,EAAOlI,QAAgB,CACzBqD,EACAF,EACAjB,EACAE,EACAD,EACAV,EACAC,GACAkF,SAASmC,GACTb,EAAOlC,KAAK,CAAEU,KAAMzD,EAAUzD,MAAO,IAAKuI,MAAAA,IAE1CG,EAAOlC,KAAK,CAAEU,KAAMnE,EAAc/C,MAAO,IAAKuI,MAAAA,SAE3C,GAA8B,MAA1BN,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EACjBF,EAAOlC,KAAK,CAAEU,KAAMjE,EAAYjD,MAAO,IAAKuI,MAAAA,SACvC,GAA8B,MAA1BN,EAAOU,KAAKC,UACrBL,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EACjBF,EAAOlC,KAAK,CAAEU,KAAMlE,EAAWhD,MAAO,IAAKuI,MAAAA,QACtC,IAA8B,MAA1BN,EAAOU,KAAKC,UAShB,CACL,IAAMY,EAAQ,IAAIvD,MAAJ,4BAA+BgC,EAAOU,KAAKC,YAEzD,MADAY,EAAMC,KAAO,aACPD,EAXNjB,EAAQI,KAAKC,SACbD,KAAKC,UAAY,EACa,MAA1BX,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACjBF,EAAOlC,KAAK,CAAEU,KAAMvE,EAAQ3C,MAAO,KAAMuI,MAAAA,KAEzCG,EAAOlC,KAAK,CAAEU,KAAMxE,EAAU1C,MAAO,IAAKuI,MAAAA,KAQhD,OAAOG,GAGTI,2BAnIgB,SAmIWb,GACzB,IAAMM,EAAQI,KAAKC,SAEnB,IADAD,KAAKC,UAAY,EACVD,KAAKC,SAAWX,EAAOzH,QAAU6D,EAAW4D,EAAOU,KAAKC,YAC7DD,KAAKC,UAAY,EAEnB,OAAOX,EAAOjH,MAAMuH,EAAOI,KAAKC,WAGlCM,yBA5IgB,SA4ISjB,GACvB,IAAMM,EAAQI,KAAKC,SACnBD,KAAKC,UAAY,EAEjB,IADA,IAAMc,EAAYzB,EAAOzH,OACQ,MAA1ByH,EAAOU,KAAKC,WAAqBD,KAAKC,SAAWc,GAAW,CAEjE,IAAIC,EAAUhB,KAAKC,SACK,OAApBX,EAAO0B,IAA8C,OAAxB1B,EAAO0B,EAAU,IACgB,MAAxB1B,EAAO0B,EAAU,GAGzDA,GAAW,EAFXA,GAAW,EAIbhB,KAAKC,SAAWe,EAGlB,OADAhB,KAAKC,UAAY,EACVgB,KAAKC,MAAM5B,EAAOjH,MAAMuH,EAAOI,KAAKC,YAG7CO,yBA/JgB,SA+JSlB,GACvB,IAAMM,EAAQI,KAAKC,SACnBD,KAAKC,UAAY,EAEjB,IADA,IAAMc,EAAYzB,EAAOzH,OACQ,MAA1ByH,EAAOU,KAAKC,WAAqBD,KAAKC,SAAWc,GAAW,CAEjE,IAAIC,EAAUhB,KAAKC,SACK,OAApBX,EAAO0B,IAA8C,OAAxB1B,EAAO0B,EAAU,IACgB,MAAxB1B,EAAO0B,EAAU,GAGzDA,GAAW,EAFXA,GAAW,EAIbhB,KAAKC,SAAWe,EAIlB,OAFAhB,KAAKC,UAAY,EACDX,EAAOjH,MAAMuH,EAAQ,EAAGI,KAAKC,SAAW,GACzCnI,QAAQ,MAAO,MAGhCuI,eAnLgB,SAmLDf,GACb,IAAMM,EAAQI,KAAKC,SACnBD,KAAKC,UAAY,EAEjB,IADA,IAAMc,EAAYzB,EAAOzH,OAClB0D,EAAM+D,EAAOU,KAAKC,WAAW,IAAUD,KAAKC,SAAWc,GAC5Df,KAAKC,UAAY,EAEnB,IACI5I,EADE2F,EAAIsC,EAAOjH,MAAMuH,EAAOI,KAAKC,UAOnC,OAJE5I,EADE2F,EAAEyB,SAAS,KACLtB,WAAWH,GAEXmE,SAASnE,EAAG,IAEf,CAAEuB,KAAM7E,EAAYrC,MAAAA,EAAOuI,MAAAA,IAGpCU,iBApMgB,SAoMChB,GACf,IAAMM,EAAQI,KAAKC,SAEnB,OADAD,KAAKC,UAAY,EACa,MAA1BX,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACV,CAAE1B,KAAMxD,EAAY1D,MAAO,KAAMuI,MAAAA,IAEZ,MAA1BN,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACV,CAAE1B,KAAM1D,EAAaxD,MAAO,KAAMuI,MAAAA,IAEpC,CAAErB,KAAMrD,EAAc7D,MAAO,IAAKuI,MAAAA,IAG3CM,eAlNgB,SAkNDZ,GACb,IAAMM,EAAQI,KAAKC,SAEnB,IADAD,KAAKC,UAAY,EACVD,KAAKC,SAAWX,EAAOzH,QAAU6D,EAAW4D,EAAOU,KAAKC,YAAYD,KAAKC,UAAY,EAC5F,IAAMR,EAASH,EAAOjH,MAAMuH,EAAOI,KAAKC,UAExC,MAAO,CAAE1B,KAAM3E,EAAYvC,MAAOiE,EAAamE,GAASG,MAAAA,IAG1De,iBA3NgB,SA2NCrB,GACf,IAAMM,EAAQI,KAAKC,SACbmB,EAAe9B,EAAOM,GAE5B,OADAI,KAAKC,UAAY,EACI,MAAjBmB,EAC4B,MAA1B9B,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACV,CAAE1B,KAAM3D,EAAQvD,MAAO,KAAMuI,MAAAA,IAE/B,CAAErB,KApmBC,MAomBclH,MAAO,IAAKuI,MAAAA,GAEjB,MAAjBwB,EAC4B,MAA1B9B,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACV,CAAE1B,KAAM5D,EAAStD,MAAO,KAAMuI,MAAAA,IAEhC,CAAErB,KAAM9D,EAAQpD,MAAO,IAAKuI,MAAAA,GAEhB,MAAjBwB,EAC4B,MAA1B9B,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACV,CAAE1B,KAAM7D,EAASrD,MAAO,KAAMuI,MAAAA,IAEhC,CAAErB,KAAM/D,EAAQnD,MAAO,IAAKuI,MAAAA,GAGP,MAA1BN,EAAOU,KAAKC,WACdD,KAAKC,UAAY,EACV,CAAE1B,KAAMhE,EAAQlD,MAAO,KAAMuI,MAAAA,IAE/B,CAAErB,KAAMhE,EAAQlD,MAAO,IAAKuI,MAAAA,IAGrCc,gBA5PgB,SA4PApB,GACdU,KAAKC,UAAY,EAIjB,IAHA,IAEIQ,EAFEb,EAAQI,KAAKC,SACbc,EAAYzB,EAAOzH,OAEQ,MAA1ByH,EAAOU,KAAKC,WAAqBD,KAAKC,SAAWc,GAAW,CAEjE,IAAIC,EAAUhB,KAAKC,SACK,OAApBX,EAAO0B,IAA8C,OAAxB1B,EAAO0B,EAAU,IACgB,MAAxB1B,EAAO0B,EAAU,GAGzDA,GAAW,EAFXA,GAAW,EAIbhB,KAAKC,SAAWe,EAElB,IAAIK,EAAgBpI,EAASqG,EAAOjH,MAAMuH,EAAOI,KAAKC,WAUtD,OATAoB,EAAgBA,EAAcvJ,QAAQ,MAAO,KAE3C2I,EADET,KAAKsB,eAAeD,GACZJ,KAAKC,MAAMG,GAGXJ,KAAKC,MAAL,WAAeG,EAAf,MAGZrB,KAAKC,UAAY,EACVQ,GAGTa,eAzRgB,SAyRDD,GAKb,GAAsB,KAAlBA,EACF,OAAO,EAET,GAPsB,MAOJ/I,QAAQ+I,EAAc,KAAO,EAC7C,OAAO,EAET,GATqB,CAAC,OAAQ,QAAS,QAStB/I,QAAQ+I,IAAkB,EACzC,OAAO,EAET,KAXsB,cAWJ/I,QAAQ+I,EAAc,KAAO,GAQ7C,OAAO,EAPP,IAEE,OADAJ,KAAKC,MAAMG,IACJ,EACP,MAAOE,GACP,OAAO,KAQf,IAAMC,GAAe,GAqCrB,SAASC,MAoZT,SAASC,GAAgBC,GACvB3B,KAAK2B,QAAUA,EAuTjB,SAASC,KAA8B,IAAtBC,EAAsB,uDAAJ,GACjC7B,KAAK8B,cAAL,KAcEC,IAAK,CAAExK,MAAOyI,KAAKgC,aAAczJ,WAAY,CAAC,CAAEC,MAAO,CAACE,MACxDuJ,IAAK,CAAE1K,MAAOyI,KAAKkC,aAAc3J,WAAY,CAAC,CAAEC,MAAO,CAACO,MACxDoJ,KAAM,CAAE5K,MAAOyI,KAAKoC,cAAe7J,WAAY,CAAC,CAAEC,MAAO,CAACE,MAC1D2J,SAAU,CACR9K,MAAOyI,KAAKsC,kBACZ/J,WAAY,CAAC,CAAEC,MAAO,CAACG,EAAaC,IAClC,CAAEJ,MAAO,CF5+CP,ME8+CN+J,UAAW,CACThL,MAAOyI,KAAKwC,kBACZjK,WAAY,CAAC,CAAEC,MAAO,CAACG,IAAgB,CAAEH,MAAO,CAACG,MAEnD8J,MAAO,CAAElL,MAAOyI,KAAK0C,eAAgBnK,WAAY,CAAC,CAAEC,MAAO,CAACE,MAC5Db,OAAQ,CACNN,MAAOyI,KAAK2C,gBACZpK,WAAY,CAAC,CAAEC,MAAO,CAACG,EAAaC,EFl/C7B,MEo/CToD,IAAK,CACHzE,MAAOyI,KAAK4C,aACZrK,WAAY,CAAC,CAAEC,MAAO,CFp/Cf,IEo/CgC,CAAEA,MAAO,CAACI,MAEnDkF,IAAK,CACHvG,MAAOyI,KAAK6C,aACZtK,WAAY,CAAC,CAAEC,MAAO,CAACI,EAAYG,EAAmBC,MAExD8J,MAAO,CACLvL,MAAOyI,KAAK+C,eACZxK,WAAY,CAAC,CAAEC,MAAO,CF9/Cf,GE8/C8BwK,UAAU,KAEjDC,OAAQ,CACN1L,MAAOyI,KAAKkD,eACZ3K,WAAY,CAAC,CAAEC,MAAO,CAACI,IAAe,CAAEJ,MAAO,CFhgDxC,MEkgDT2K,IAAK,CAAE5L,MAAOyI,KAAKoD,aAAc7K,WAAY,CAAC,CAAEC,MAAO,CAACO,MACxDsK,YAAa,CACX9L,MAAOyI,KAAKsD,oBACZ/K,WAAY,CAAC,CAAEC,MAAO,CAACG,IAAgB,CAAEH,MAAO,CAACG,MAEnDgF,IAAK,CACHpG,MAAOyI,KAAKuD,aACZhL,WAAY,CAAC,CAAEC,MAAO,CAACI,EAAYG,EAAmBC,MAExDwK,OAAQ,CACNjM,MAAOyI,KAAKyD,eACZlL,WAAY,CAAC,CAAEC,MAAO,CAACI,IAAe,CAAEJ,MAAO,CF7gDxC,ME+gDT+F,KAAM,CAAEhH,MAAOyI,KAAK0D,cAAenL,WAAY,CAAC,CAAEC,MAAO,CFphDnD,MEqhDNmL,KAAM,CAAEpM,MAAOyI,KAAK4D,cAAerL,WAAY,CAAC,CAAEC,MAAO,CFlhDhD,MEmhDTqL,OAAQ,CAAEtM,MAAOyI,KAAK8D,gBAAiBvL,WAAY,CAAC,CAAEC,MAAO,CFnhDpD,MEohDTuL,KAAM,CACJxM,MAAOyI,KAAKgE,cACZzL,WAAY,CAAC,CAAEC,MAAO,CAACI,EAAYI,EAAmBD,MAExDkL,QAAS,CACP1M,MAAOyI,KAAKkE,gBACZ3L,WAAY,CAAC,CAAEC,MAAO,CAACI,IAAe,CAAEJ,MAAO,CFxhDxC,ME0hDT2L,KAAM,CACJ5M,MAAOyI,KAAKoE,cACZ7L,WAAY,CACV,CAAEC,MAAO,CAACG,IACV,CAAEH,MAAO,CAACQ,MAGdqL,QAAS,CACP9M,MAAOyI,KAAKsE,iBACZ/L,WAAY,CAAC,CAAEC,MAAO,CAACG,EAAaC,MAEtC2L,SAAU,CAAEhN,MAAOyI,KAAKwE,iBAAkBjM,WAAY,CAAC,CAAEC,MAAO,CF1iD1D,ME2iDNiM,UAAW,CAAElN,MAAOyI,KAAK0E,kBAAmBnM,WAAY,CAAC,CAAEC,MAAO,CF3iD5D,ME4iDNmM,UAAW,CAAEpN,MAAOyI,KAAK4E,kBAAmBrM,WAAY,CAAC,CAAEC,MAAO,CF5iD5D,ME6iDNqM,SAAU,CACRtN,MAAOyI,KAAK8E,iBACZvM,WAAY,CAAC,CAAEC,MAAO,CF/iDlB,GE+iD8BwK,UAAU,KAE9C+B,IAAK,CAAExN,MAAOyI,KAAKgF,aAAczM,WAAY,CAAC,CAAEC,MAAO,CFjjDjD,IEijD+D,CAAEA,MAAO,CFjjDxE,MEkjDNyM,GAAI,CAAE1N,MAAOyI,KAAKkF,YAAa3M,WAAY,CAAC,CAAEC,MAAO,CFljD/C,IEkjD6D,CAAEA,MAAO,CFljDtE,MEmjDN2M,IAAK,CAAE5N,MAAOyI,KAAKoF,aAAc7M,WAAY,CAAC,CAAEC,MAAO,CFnjDjD,MEojDN6M,KAAM,CAAE9N,MAAF,WAAY,OAAO,GAASgB,WAAY,IAC9C+M,MAAO,CAAE/N,MAAF,WAAY,OAAO,GAAUgB,WAAY,IAChDgN,GAAI,CACFhO,MAAOyI,KAAKwF,YACZjN,WAAY,CAAC,CAAEC,MAAO,CFxjDlB,IEwjDgC,CAAEA,MAAO,CFxjDzC,IEwjDuD,CAAEA,MAAO,CFxjDhE,OE0jDHiN,GACA5D,GAp1BPL,GAAY,IAAY,EACxBA,GAAY,mBAA2B,EACvCA,GAAY,iBAAyB,EACrCA,GAAY,SAAiB,EAC7BA,GAAY,OAAe,EAC3BA,GAAalI,GAAa,EAC1BkI,GAAY,OAAe,EAC3BA,GAAY,OAAe,EAC3BA,GAAY,QAAgB,EAC5BA,GAAY,OAAe,EAC3BA,GAAY,MAAc,EAC1BA,GAAY,OAAe,EAC3BA,GAAazH,GAAY,EACzByH,GAAaxH,GAAU,EACvBwH,GAAavH,GAAW,EACxBuH,GAAatH,GAAW,EACxBsH,GAAarH,GAAgB,EAC7BqH,GAAahI,GAAmB,EAChCgI,GAAapH,GAAgB,EAC7BoH,GAAalH,GAAc,EAC3BkH,GAAanH,GAAa,EAC1BmH,GAAajH,GAAU,EACvBiH,GAAahH,GAAU,EACvBgH,GAAa/G,GAAU,EACvB+G,GAAa9G,GAAW,EACxB8G,GAAa7G,GAAW,EACxB6G,GAAa5G,GAAU,EACvB4G,GAAY,QAAgB,EAC5BA,GAAY,KAAa,GACzBA,GAAY,OAAe,GAC3BA,GAAaxG,GAAW,GACxBwG,GAAY,IAAY,GACxBA,GAAY,OAAe,GAC3BA,GAAatG,GAAgB,GAC7BsG,GAAY,OAAe,GAK3BC,GAAO5F,UAAY,CACjBqF,MADiB,SACXwE,GACJ1F,KAAK2F,YAAYD,GACjB1F,KAAK4F,MAAQ,EACb,IAAMC,EAAM7F,KAAK0F,WAAW,GAC5B,GAjwBY,QAiwBR1F,KAAK8F,WAAW,GAAgB,CAClC,IAAMC,EAAI/F,KAAKgG,gBAAgB,GACzBnF,EAAQ,IAAIvD,MAAJ,iCACcyI,EAAExH,KADhB,oBACgCwH,EAAE1O,QAGhD,MADAwJ,EAAMC,KAAO,cACPD,EAER,OAAOgF,GAGTF,YAhBiB,SAgBLD,GACV,IACM3F,GADQ,IAAIL,IACGC,SAAS+F,GAC9B3F,EAAOlC,KAAK,CAAEU,KA/wBF,MA+wBiBlH,MAAO,GAAIuI,MAAO8F,EAAW7N,SAC1DmI,KAAKD,OAASA,GAGhB2F,WAvBiB,SAuBNO,GACT,IAAMC,EAAYlG,KAAKgG,gBAAgB,GACvChG,KAAKmG,WAGL,IAFA,IAAIC,EAAOpG,KAAKqG,IAAIH,GAChBI,EAAetG,KAAK8F,WAAW,GAC5BG,EAAMzE,GAAa8E,IACxBtG,KAAKmG,WACLC,EAAOpG,KAAKuG,IAAID,EAAcF,GAC9BE,EAAetG,KAAK8F,WAAW,GAEjC,OAAOM,GAGTN,WApCiB,SAoCNU,GACT,OAAOxG,KAAKD,OAAOC,KAAK4F,MAAQY,GAAQjI,MAG1CyH,gBAxCiB,SAwCDQ,GACd,OAAOxG,KAAKD,OAAOC,KAAK4F,MAAQY,IAGlCL,SA5CiB,WA6CfnG,KAAK4F,OAAS,GAIhBS,IAjDiB,SAiDbvG,GACF,IACI2G,EACAf,EACAgB,EACAlP,EAhvBYmP,EAivBhB,OAAQ7G,EAAMvB,MACZ,KAAKnD,EACH,MAAO,CAAEmD,KAAM,UAAWlH,MAAOyI,EAAMzI,OACzC,KAAKqC,EACH,MAAO,CAAE6E,KAAM,SAAUlH,MAAOyI,EAAMzI,OACxC,KAAK6B,EACH,MAAO,CAAEqF,KAAM,QAASuC,KAAMhB,EAAMzI,OACtC,KAAK8B,EAEH,GADAuN,EAAO,CAAEnI,KAAM,QAASuC,KAAMhB,EAAMzI,OAChC2I,KAAK8F,WAAW,KAAO3K,EACzB,MAAM,IAAImC,MAAM,qDAElB,OAAOoJ,EACT,IAhyBU,MAkyBR,MAAO,CAAEnI,KAAM,gBAAiBqI,SAAU,CAD1CH,EAAQzG,KAAK0F,WAAWlE,GAAaqF,OAEvC,KAAK/L,EASH,MAAO,CAAEyD,KAAM,kBAAmBqI,SAAU,CARrC,CAAErI,KAAM,YAIbkI,EAHEzG,KAAK8F,WAAW,KAAO1M,EAGjB,CAAEmF,KAAM,YAERyB,KAAK8G,oBAAoBtF,GAAauF,QAGlD,KAAKhM,EACH,OAAOiF,KAAKuG,IAAIzG,EAAMvB,KAAM,CAAEA,KAAM,aACtC,KAAKtD,EACH,OAAO+E,KAAKgH,wBACd,KAAKnM,EAGH,MAAO,CAAE0D,KAAM,aAAcqI,SAAU,CAFhC,CAAErI,KAAM1D,EAAa+L,SAAU,CAAC,CAAErI,KAAM,cAC/CkI,EAAQzG,KAAK8G,oBAAoBtF,GAAayF,WAEhD,KAAK/L,EAKH,OAAI8E,KAAK8F,WAAW,KAAOxM,IAxxBfqN,EAwxBuC3G,KAAK8F,WAAW,GAvxBlE,CACLtM,EACAQ,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAAQ6D,SAASkI,IA0wBJ3G,KAAKkH,wBAEVlH,KAAK8F,WAAW,KAAOpM,GAAcsG,KAAK8F,WAAW,KAAOvM,GAC9DkN,EAAQzG,KAAKmH,wBACNnH,KAAKoH,gBAAgB,CAAE7I,KAAM,YAAckI,IAEhDzG,KAAK8F,WAAW,KAAOhL,GACXkF,KAAK8F,WAAW,KAAO1M,GACrC4G,KAAKmG,WACLnG,KAAKmG,WAEE,CACL5H,KAAM,aACNqI,SAAU,CAAC,CAAErI,KAAM,YAHrBkI,EAAQzG,KAAK8G,oBAAoBtF,GAAauF,SAMzC/G,KAAKkH,wBACd,KAAKvN,EACH,MAAO,CAAE4E,KAAM5E,GACjB,KAAKC,EACH,MAAO,CAAE2E,KAAM3E,EAAYvC,MAAOyI,EAAMzI,OAC1C,KAAKwC,EACH,MAAO,CAAE0E,KAAM1E,GACjB,KAAKC,EAEH,MAAO,CAAEyE,KAAM,sBAAuBqI,SAAU,CADhDlB,EAAa1F,KAAK0F,WAAWlE,GAAa6F,UAE5C,KAAKlM,EAEH,IADA3D,EAAO,GACAwI,KAAK8F,WAAW,KAAOzM,GACxB2G,KAAK8F,WAAW,KAAOnM,GACzB+L,EAAa,CAAEnH,KAAM5E,GACrBqG,KAAKmG,YAELT,EAAa1F,KAAK0F,WAAW,GAE/BlO,EAAKqG,KAAK6H,GAGZ,OADA1F,KAAKsH,OAAOjO,GACL7B,EAAK,GACd,QACEwI,KAAKuH,YAAYzH,KAKvByG,IA5IiB,SA4IbiB,EAAWpB,GACb,IAAIqB,EACAhB,EACA3F,EACAtJ,EACAkO,EAEAO,EAGAnG,EACJ,OAAQ0H,GACN,KAAKhO,EAEH,MAAO,CAAE+E,KAAM,wBAAyBqI,SAAU,CAACR,EADnDK,EAAQzG,KAAK0F,WAAWlE,GAAakG,eAEvC,KAAK1M,EAEH,OADAiL,EAAMzE,GAAamG,IACf3H,KAAK8F,WAAW,KAAOhL,EAElB,CAAEyD,KAAM,gBAAiBqI,SAAU,CAACR,EAD3CK,EAAQzG,KAAK4H,aAAa3B,MAI5BjG,KAAKmG,WAEE,CAAE5H,KAAM,kBAAmBqI,SAAU,CAACR,EAD7CK,EAAQzG,KAAK8G,oBAAoBb,MAEnC,KAAKlM,EAEH,OADA0M,EAAQzG,KAAK0F,WAAWlE,GAAaqG,MAC9B,CAAEtJ,KAAMxE,EAAU6M,SAAU,CAACR,EAAMK,IAC5C,KAAKzM,EAEH,MAAO,CAAEuE,KAAM,eAAgBqI,SAAU,CAACR,EAD1CK,EAAQzG,KAAK0F,WAAWlE,GAAasG,MAEvC,KAAK7N,EAEH,MAAO,CAAEsE,KAAM,gBAAiBqI,SAAU,CAACR,EAD3CK,EAAQzG,KAAK0F,WAAWlE,GAAauG,OAEvC,KAAK7N,EAEH,MAAO,CAAEqE,KAAM,gBAAiBqI,SAAU,CAACR,EAD3CK,EAAQzG,KAAK0F,WAAWlE,GAAawG,OAEvC,KAAK7N,EAEH,MAAO,CAAEoE,KAAM,qBAAsBqI,SAAU,CAACR,EADhDK,EAAQzG,KAAK0F,WAAWlE,GAAayG,YAEvC,KAAK7N,EAEH,MAAO,CAAEmE,KAAM,qBAAsBqI,SAAU,CAACR,EADhDK,EAAQzG,KAAK0F,WAAWlE,GAAa0G,YAEvC,KAAK5N,EAEH,MAAO,CAAEiE,KAAM,mBAAoBqI,SAAU,CAACR,EAD9CK,EAAQzG,KAAK0F,WAAWlE,GAAa2G,UAEvC,KAAK9N,EAEH,MAAO,CAAEkE,KAAM,kBAAmBqI,SAAU,CAACR,EAD7CK,EAAQzG,KAAK0F,WAAWlE,GAAa4G,SAEvC,KAAKjN,EAGH,IAFA2F,EAAOsF,EAAKtF,KACZtJ,EAAO,GACAwI,KAAK8F,WAAW,KAAOzM,GACxB2G,KAAK8F,WAAW,KAAOnM,GACzB+L,EAAa,CAAEnH,KAAM5E,GACrBqG,KAAKmG,YAELT,EAAa1F,KAAK0F,WAAW,GAE3B1F,KAAK8F,WAAW,KAAOxM,GACzB0G,KAAKsH,OAAOhO,GAEd9B,EAAKqG,KAAK6H,GAIZ,OAFA1F,KAAKsH,OAAOjO,GACL,CAAEkF,KAAM,WAAYuC,KAAAA,EAAM8F,SAAUpP,GAE7C,KAAKuD,EAQH,OAPA0M,EAAYzH,KAAK0F,WAAW,GAC5B1F,KAAKsH,OAAOlO,GAML,CAAEmF,KAAM,mBAAoBqI,SAAU,CAACR,EAJ5CK,EADEzG,KAAK8F,WAAW,KAAOjL,EACjB,CAAE0D,KAAM,YAERyB,KAAK8G,oBAAoBtF,GAAa6G,QAEWZ,IAC7D,KAAK5M,EAGH,MAAO,CAAE0D,KAAM,aAAcqI,SAAU,CAF5B,CAAErI,KAAM1D,EAAa+L,SAAU,CAACR,IAC/BpG,KAAK8G,oBAAoBtF,GAAayF,WAEpD,KAAK1M,EACL,KAAKK,EACL,KAAKJ,EACL,KAAKE,EACL,KAAKD,EACL,KAAKE,EACH,OAAOqF,KAAKsI,iBAAiBlC,EAAMoB,GACrC,KAAKtM,EAEH,OADA4E,EAAQE,KAAKgG,gBAAgB,IACnBzH,OAAS7E,GAAcoG,EAAMvB,OAAShF,GAC9CkN,EAAQzG,KAAKmH,wBACNnH,KAAKoH,gBAAgBhB,EAAMK,KAEpCzG,KAAKsH,OAAOxM,GACZkF,KAAKsH,OAAOlO,GAEL,CAAEmF,KAAM,aAAcqI,SAAU,CAACR,EADxCK,EAAQzG,KAAK8G,oBAAoBtF,GAAauF,SAEhD,QACE/G,KAAKuH,YAAYvH,KAAKgG,gBAAgB,MAI5CsB,OAlPiB,SAkPViB,GACL,GAAIvI,KAAK8F,WAAW,KAAOyC,EAEpB,CACL,IAAMxC,EAAI/F,KAAKgG,gBAAgB,GACzBnF,EAAQ,IAAIvD,MAAJ,mBAAsBiL,EAAtB,kBAAyCxC,EAAExH,OAEzD,MADAsC,EAAMC,KAAO,cACPD,EALNb,KAAKmG,YASToB,YA7PiB,SA6PLzH,GACV,IAAMe,EAAQ,IAAIvD,MAAJ,yBACZwC,EAAMvB,KADM,eAEZuB,EAAMzI,MAFM,MAId,MADAwJ,EAAMC,KAAO,cACPD,GAGRsG,sBArQiB,WAsQf,GAAInH,KAAK8F,WAAW,KAAOvM,GAAayG,KAAK8F,WAAW,KAAOvM,EAC7D,OAAOyG,KAAKwI,wBAEd,IAAM9B,EAAO,CACXnI,KAAM,QACNlH,MAAO2I,KAAKgG,gBAAgB,GAAG3O,OAIjC,OAFA2I,KAAKmG,WACLnG,KAAKsH,OAAOlO,GACLsN,GAGTU,gBAlRiB,SAkRDhB,EAAMK,GACpB,IAAMgC,EAAY,CAAElK,KAAM,kBAAmBqI,SAAU,CAACR,EAAMK,IAC9D,MAAmB,UAAfA,EAAMlI,KACD,CACLA,KAAM,aACNqI,SAAU,CAAC6B,EAAWzI,KAAK8G,oBAAoBtF,GAAauF,QAGzD0B,GAGTD,sBA7RiB,WAmSf,IAHA,IAAME,EAAQ,CAAC,KAAM,KAAM,MACvB9C,EAAQ,EACRU,EAAetG,KAAK8F,WAAW,GAC5BQ,IAAiBlN,GAAgBwM,EAAQ,GAAG,CACjD,GAAIU,IAAiB/M,EACnBqM,GAAS,EACT5F,KAAKmG,eACA,IAAIG,IAAiB5M,EAGrB,CACL,IAAMqM,EAAI/F,KAAK8F,WAAW,GACpBjF,EAAQ,IAAIvD,MAAJ,0CACZyI,EAAE1O,MADU,YACD0O,EAAExH,KADD,MAGd,MADAsC,EAAMC,KAAO,cACPD,EAPN6H,EAAM9C,GAAS5F,KAAKgG,gBAAgB,GAAG3O,MACvC2I,KAAKmG,WAQPG,EAAetG,KAAK8F,WAAW,GAGjC,OADA9F,KAAKsH,OAAOlO,GACL,CACLmF,KAAM,QACNqI,SAAU8B,IAIdJ,iBA1TiB,SA0TAlC,EAAMuC,GAErB,MAAO,CAAEpK,KAAM,aAAcuC,KAAM6H,EAAY/B,SAAU,CAACR,EAD5CpG,KAAK0F,WAAWlE,GAAamH,OAK7Cf,aAhUiB,SAgUJ3B,GACX,IAAM2C,EAAY5I,KAAK8F,WAAW,GAElC,MADmB,CAAC5M,EAAwBC,EAAsB2B,GACnDxC,QAAQsQ,IAAc,EAC5B5I,KAAK0F,WAAWO,GAErB2C,IAAc1N,GAChB8E,KAAKsH,OAAOpM,GACL8E,KAAKkH,yBAEV0B,IAAc3N,GAChB+E,KAAKsH,OAAOrM,GACL+E,KAAKgH,8BAFd,GAMFF,oBAhViB,SAgVGb,GAClB,IAAIQ,EACJ,GAAIjF,GAAaxB,KAAK8F,WAAW,IAAM,GACrCW,EAAQ,CAAElI,KAAM,iBACX,GAAIyB,KAAK8F,WAAW,KAAO5K,EAChCuL,EAAQzG,KAAK0F,WAAWO,QACnB,GAAIjG,KAAK8F,WAAW,KAAO/K,EAChC0L,EAAQzG,KAAK0F,WAAWO,OACnB,IAAIjG,KAAK8F,WAAW,KAAO9K,EAG3B,CACL,IAAM+K,EAAI/F,KAAKgG,gBAAgB,GACzBnF,EAAQ,IAAIvD,MAAJ,0CACZyI,EAAE1O,MADU,YACD0O,EAAExH,KADD,MAGd,MADAsC,EAAMC,KAAO,cACPD,EAPNb,KAAKsH,OAAOtM,GACZyL,EAAQzG,KAAK4H,aAAa3B,GAQ5B,OAAOQ,GAGTS,sBArWiB,WAuWf,IADA,IAAM2B,EAAc,GACb7I,KAAK8F,WAAW,KAAO1M,GAAc,CAC1C,IAAMsM,EAAa1F,KAAK0F,WAAW,GAEnC,GADAmD,EAAYhL,KAAK6H,GACb1F,KAAK8F,WAAW,KAAOxM,IACzB0G,KAAKsH,OAAOhO,GACR0G,KAAK8F,WAAW,KAAO1M,GACzB,MAAM,IAAIkE,MAAM,6BAKtB,OADA0C,KAAKsH,OAAOlO,GACL,CAAEmF,KAAM,kBAAmBqI,SAAUiC,IAG9C7B,sBArXiB,WA0Xf,IAJA,IAEI8B,EAAcC,EAChBrC,EAHIsC,EAAQ,GACRC,EAAkB,CAAC/P,EAAwBC,KAGxC,CAEP,GADA2P,EAAW9I,KAAKgG,gBAAgB,GAC5BiD,EAAgB3Q,QAAQwQ,EAASvK,MAAQ,EAC3C,MAAM,IAAIjB,MAAJ,8CACJwL,EAASvK,OAQb,GANAwK,EAAUD,EAASzR,MACnB2I,KAAKmG,WACLnG,KAAKsH,OAAO/N,GAEZmN,EAAO,CAAEnI,KAAM,eAAgBuC,KAAMiI,EAAS1R,MADtC2I,KAAK0F,WAAW,IAExBsD,EAAMnL,KAAK6I,GACP1G,KAAK8F,WAAW,KAAOxM,EACzB0G,KAAKsH,OAAOhO,QACP,GAAI0G,KAAK8F,WAAW,KAAOrM,EAAY,CAC5CuG,KAAKsH,OAAO7N,GACZ,OAGJ,MAAO,CAAE8E,KAAM,kBAAmBqI,SAAUoC,KAQhDtH,GAAgB7F,UAAY,CAC1BqN,OAD0B,SACnBxC,EAAMrP,GACX,OAAO2I,KAAKmJ,MAAMzC,EAAMrP,IAG1B8R,MAL0B,SAKpBzC,EAAMrP,GACV,IAAI+R,EACApI,EACApD,EACApB,EACAC,EACA4M,EACAjD,EAEAkD,EACAnR,EACAoR,EACAC,EACA5D,EACA6D,EAEA7J,EACA8J,EACAC,EACA9F,EACA+F,EACAC,EACAC,EACAC,EACAC,EACAC,E,EAEJ,OAAQvD,EAAKnI,MACX,IAAK,QACH,OAAc,OAAVlH,GAAkB4E,GAAS5E,QAEf+I,KADdiJ,EAAQhS,EAAMqP,EAAK5F,OAEV,KAEFuI,EAEF,KACT,IAAK,gBAEH,IADAzL,EAASoC,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACjCc,EAAI,EAAGA,EAAIuO,EAAKE,SAAS/O,OAAQM,GAAK,EAEzC,GAAe,QADfyF,EAASoC,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIhJ,IAEpC,OAAO,KAGX,OAAOA,EACT,IAAK,kBA4LL,KAAK7D,EAEH,OADAqM,EAAOpG,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GAC7B2I,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIR,GA1LtC,IAAK,QACH,OAAKzK,EAAQtE,KAGbuO,EAAQc,EAAKrP,OACD,IACVuO,EAAQvO,EAAMQ,OAAS+N,QAGVxF,KADfxC,EAASvG,EAAMuO,MAEbhI,EAAS,MAEJA,GAVE,KAWX,IAAK,QACH,IAAKjC,EAAQtE,GACX,OAAO,KAEToS,EAAc/C,EAAKE,SAASvO,MAAM,GAJpC,QAKa2H,KAAKkK,mBAAmB7S,EAAMQ,OAAQ4R,GALnD,GAQE,GAFC7J,EANH,KAMU8J,EANV,KAOE9L,EAAS,IADK+L,EANhB,MAQa,EACT,IAAKxR,EAAIyH,EAAOzH,EAAIuR,EAAMvR,GAAKwR,EAC7B/L,EAAOC,KAAKxG,EAAMc,SAGpB,IAAKA,EAAIyH,EAAOzH,EAAIuR,EAAMvR,GAAKwR,EAC7B/L,EAAOC,KAAKxG,EAAMc,IAGtB,OAAOyF,EACT,IAAK,aAGH,IAAKjC,EADL6N,EAAOxJ,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAElC,OAAO,KAGT,IADAiS,EAAY,GACPnR,EAAI,EAAGA,EAAIqR,EAAK3R,OAAQM,GAAK,EAEhB,QADhB6I,EAAUhB,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAI4C,EAAKrR,MAE1CmR,EAAUzL,KAAKmD,GAGnB,OAAOsI,EACT,IAAK,kBAGH,IAAKrN,GAAShE,EADduR,EAAOxJ,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,KAElC,OAAO,KAIT,IAFAiS,EAAY,GACZzF,EA3hCR,SAAmBjI,GAGjB,IAFA,IAAM+H,EAAOxM,OAAOwM,KAAK/H,GACnBiI,EAAS,GACN1L,EAAI,EAAGA,EAAIwL,EAAK9L,OAAQM,GAAK,EACpC0L,EAAOhG,KAAKjC,EAAI+H,EAAKxL,KAEvB,OAAO0L,EAqhCQsG,CAAUX,GACdrR,EAAI,EAAGA,EAAI0L,EAAOhM,OAAQM,GAAK,EAElB,QADhB6I,EAAUhB,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAI/C,EAAO1L,MAE5CmR,EAAUzL,KAAKmD,GAGnB,OAAOsI,EACT,IAAK,mBAEH,IAAK3N,EADL6N,EAAOxJ,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAElC,OAAO,KAIT,IAFAuS,EAAW,GACXC,EAAe,GACV1R,EAAI,EAAGA,EAAIqR,EAAK3R,OAAQM,GAAK,EAE3B2E,GADLsM,EAAUpJ,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAI4C,EAAKrR,MAE1CyR,EAAS/L,KAAK2L,EAAKrR,IAGvB,IAAK,IAAIiS,EAAI,EAAGA,EAAIR,EAAS/R,OAAQuS,GAAK,EAExB,QADhBpJ,EAAUhB,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIgD,EAASQ,MAE9CP,EAAahM,KAAKmD,GAGtB,OAAO6I,EACT,IAAK,aAGH,OAFArN,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACrCoF,EAASuD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GAC9BqP,EAAK5F,MACX,KAAKvG,EACHqD,EAASvB,GAAgBG,EAAOC,GAChC,MACF,KAAK7B,EACHgD,GAAUvB,GAAgBG,EAAOC,GACjC,MACF,KAAKjC,EACHoD,EAASpB,EAAQC,EACjB,MACF,KAAK/B,EACHkD,EAASpB,GAASC,EAClB,MACF,KAAKhC,EACHmD,EAASpB,EAAQC,EACjB,MACF,KAAK9B,EACHiD,EAASpB,GAASC,EAClB,MACF,QACE,MAAM,IAAIa,MAAJ,8BAAiCoJ,EAAK5F,OAEhD,OAAOlD,EACT,KAAK/C,EAEH,IAAKc,EADLmO,EAAW9J,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAEtC,OAAO,KAGT,IADA0S,EAAS,GACJ5R,EAAI,EAAGA,EAAI2R,EAASjS,OAAQM,GAAK,EAAG,CAEjB,MAAlBwD,EADJqF,EAAU8I,EAAS3R,KAEjB,EAAA4R,GAAOlM,KAAP,Q,+CAAemD,I,sSAEf+I,EAAOlM,KAAKmD,GAGhB,OAAO+I,EACT,IAAK,WAkEL,KAAKpQ,EACH,OAAOtC,EAjET,IAAK,kBACH,GAAc,OAAVA,EACF,OAAO,KAGT,IADAiS,EAAY,GACPnR,EAAI,EAAGA,EAAIuO,EAAKE,SAAS/O,OAAQM,GAAK,EACzCmR,EAAUzL,KAAKmC,KAAKmJ,MAAMzC,EAAKE,SAASzO,GAAId,IAE9C,OAAOiS,EACT,IAAK,kBACH,GAAc,OAAVjS,EACF,OAAO,KAGT,IADAiS,EAAY,GACPnR,EAAI,EAAGA,EAAIuO,EAAKE,SAAS/O,OAAQM,GAAK,EAEzCmR,GADAC,EAAQ7C,EAAKE,SAASzO,IACN2I,MAAQd,KAAKmJ,MAAMI,EAAMlS,MAAOA,GAElD,OAAOiS,EACT,IAAK,eAKH,OAHIxM,GADJsM,EAAUpJ,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,MAErC+R,EAAUpJ,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAElC+R,EACT,IAAK,gBAGH,OAAuB,IAAnBtM,GAFJN,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAG5BmF,EAEFwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACtC,IAAK,gBAEH,OAAO0F,GADPP,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IACZ0F,GAASiD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IACjE,IAAK,wBAKH,OAJAmF,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACrCoF,EAASuD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GAG/BkG,GAFPf,EAAQyB,GAAU/B,GAAYM,GAAQ,CAAC7D,EAAaK,GAAoBwD,EAAO,eAC/EC,EAASwB,GAAU/B,GAAYO,GAAS,CAAC9D,EAAaK,GAAoByD,EAAQ,eAC9C,KACtC,IAAK,qBAEH,OADAD,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IACtB2I,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GAC9C,IAAK,qBAGH,OAAOkG,GAFPf,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACrCoF,EAASuD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACF,KACtC,IAAK,mBAEH,OADAmF,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IACtB2I,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GAC9C,IAAK,kBAEH,OADAmF,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,GACrC,SAAOmF,EAASwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAC/C,IAAK,gBAEH,OAAOyF,GADPN,EAAQwD,KAAKmJ,MAAMzC,EAAKE,SAAS,GAAIvP,IAEvC,IAAK,UAEL,IAAK,SAOL,KAAKuC,EACH,OAAO8M,EAAKrP,MACd,IAAK,WAEH,IADA2S,EAAe,GACV7R,EAAI,EAAGA,EAAIuO,EAAKE,SAAS/O,OAAQM,GAAK,EACzC6R,EAAanM,KAAKmC,KAAKmJ,MAAMzC,EAAKE,SAASzO,GAAId,IAEjD,OAAO2I,KAAK2B,QAAQ0I,aAAa3D,EAAK5F,KAAMkJ,GAC9C,IAAK,sBAKH,OAJCC,EADH,EACcvD,EAAKE,SADnB,OAIUxK,aAAetC,EAChBmQ,EACT,QACE,MAAM,IAAI3M,MAAJ,6BAAgCoJ,EAAKnI,SAIjD2L,mBAvQ0B,SAuQPI,EAAab,GAC9B,IAAI7J,EAAQ6J,EAAY,GACpBC,EAAOD,EAAY,GACnBE,EAAOF,EAAY,GACjBc,EAAW,CAAC,KAAM,KAAM,MAC9B,GAAa,OAATZ,EACFA,EAAO,OACF,GAAa,IAATA,EAAY,CACrB,IAAM9I,EAAQ,IAAIvD,MAAM,mCAExB,MADAuD,EAAMC,KAAO,eACPD,EAER,IAAM2J,EAAoBb,EAAO,EAgBjC,OAbE/J,EADY,OAAVA,EACM4K,EAAoBF,EAAc,EAAI,EAEtCtK,KAAKyK,cAAcH,EAAa1K,EAAO+J,GAI/CD,EADW,OAATA,EACKc,GAAqB,EAAIF,EAEzBtK,KAAKyK,cAAcH,EAAaZ,EAAMC,GAE/CY,EAAS,GAAK3K,EACd2K,EAAS,GAAKb,EACda,EAAS,GAAKZ,EACPY,GAGTE,cAtS0B,SAsSZH,EAAaI,EAAaf,GAStC,OARIe,EAAc,GAChBA,GAAeJ,GACG,IAChBI,EAAcf,EAAO,GAAK,EAAI,GAEvBe,GAAeJ,IACxBI,EAAcf,EAAO,EAAIW,EAAc,EAAIA,GAEtCI,IA6GX9I,GAAQ/F,UAAY,CAClBwO,aADkB,SACLvJ,EAAMkJ,GACjB,IAAMW,EAAgB3K,KAAK8B,cAAchB,GACzC,QAAsBV,IAAlBuK,EACF,MAAM,IAAIrN,MAAJ,4BAA+BwD,EAA/B,OAGR,OADAd,KAAK4K,cAAc9J,EAAMkJ,EAAcW,EAAcpS,YAC9CoS,EAAcpT,MAAMuE,KAAKkE,KAAMgK,IAGxCY,cAVkB,SAUJ9J,EAAMtJ,EAAMqT,GAMxB,GAAyB,IAArBA,EAAUhT,OAAd,CAGA,IAAIiT,EAcAC,EACAC,EAdJ,GAAIH,EAAUA,EAAUhT,OAAS,GAAGmL,UAClC,GAAIxL,EAAKK,OAASgT,EAAUhT,OAE1B,MADAiT,EAAkC,IAArBD,EAAUhT,OAAe,YAAc,aAC9C,IAAIyF,MAAM,yBAAkBwD,EAAlB,+BACyB+J,EAAUhT,QADnC,OAC4CiT,EAD5C,yBAEuBtT,EAAKK,cAEzC,GAAIL,EAAKK,SAAWgT,EAAUhT,SAAWgT,EAAUA,EAAUhT,OAAS,GAAGY,SAE9E,MADAqS,EAAkC,IAArBD,EAAUhT,OAAe,YAAc,aAC9C,IAAIyF,MAAM,yBAAkBwD,EAAlB,uBACe+J,EAAUhT,QADzB,OACkCiT,EADlC,yBAEqBtT,EAAKK,SAK5C,IADA,IAAMoT,EAAQvN,KAAKC,IAAIkN,EAAUhT,OAAQL,EAAKK,QACrCM,EAAI,EAAGA,EAAI8S,EAAO9S,GAAK,EAC9B4S,EAAcF,EAAU1S,GAAGK,MAC3BwS,EAAa9O,GAAY1E,EAAKW,IAC9BX,EAAKW,GAAK8F,GAAU+M,EAAYD,EAAavT,EAAKW,GAAI2I,KAI1DwC,oBA3CkB,SA2CE0G,GAClB,OAA0E,IAAnE/R,EAAQ+R,EAAa,IAAIkB,YAAYjT,EAAQ+R,EAAa,MAGnExH,kBA/CkB,SA+CAwH,GAChB,IAAMmB,EAAYlT,EAAQ+R,EAAa,IACjCoB,EAASnT,EAAQ+R,EAAa,IACpC,OAAwE,IAAjEmB,EAAU7S,QAAQ8S,EAAQD,EAAUtT,OAASuT,EAAOvT,SAG7DyM,iBArDkB,SAqDD0F,GACf,IAAMqB,EAAcpT,EAAQ+R,EAAa,IAEzC,GADiB9N,GAAYmP,KACZ1S,EAAa,CAE5B,IADA,IAAI2S,EAAc,GACTnT,EAAIkT,EAAYxT,OAAS,EAAGM,GAAK,EAAGA,GAAK,EAChDmT,GAAeD,EAAYlT,GAE7B,OAAOmT,EAET,IAAMC,EAAgBvB,EAAa,GAAG3R,MAAM,GAE5C,OADAkT,EAAclH,UACPkH,GAGTvJ,aApEkB,SAoELgI,GACX,OAAOtM,KAAKqE,IAAIiI,EAAa,KAG/B5H,cAxEkB,SAwEJ4H,GACZ,OAAOtM,KAAKyE,KAAK6H,EAAa,KAGhC9H,aA5EkB,SA4EL8H,GAGX,IAFA,IAAI7G,EAAM,EACJqI,EAAaxB,EAAa,GACvB7R,EAAI,EAAGA,EAAIqT,EAAW3T,OAAQM,GAAK,EAC1CgL,GAAOqI,EAAWrT,GAEpB,OAAOgL,EAAMqI,EAAW3T,QAE1ByK,kBApFkB,SAoFA0H,GAChB,OAAO/R,EAAQ+R,EAAa,IAAI1R,QAAQL,EAAQ+R,EAAa,MAAQ,GAGvEtH,eAxFkB,SAwFHsH,GACb,OAAOtM,KAAK+E,MAAMuH,EAAa,KAGjCrH,gBA5FkB,SA4FFqH,GACd,IAAMyB,EAAMxT,EAAQ+R,EAAa,IACjC,OAAI/N,GAASwP,GAAatU,OAAOwM,KAAK8H,GAAK5T,OAEpC8D,EAAQ8P,GAAOA,EAAI5T,OAASH,GAAS+T,GAAK5T,QAGnD+K,aAnGkB,SAmGLoH,GAKX,IAJA,IAAM0B,EAAS,GACTC,EAAc3L,KAAK4L,aACnBC,EAAa7B,EAAa,GAC1B8B,EAAW9B,EAAa,GACrB7R,EAAI,EAAGA,EAAI2T,EAASjU,OAAQM,GAAK,EACxCuT,EAAO7N,KAAK8N,EAAYxC,MAAM0C,EAAYC,EAAS3T,KAErD,OAAOuT,GAGT3I,eA9GkB,SA8GHiH,GAEb,IADA,IAAMD,EAAS,GADY,WAElB5R,GACP,IAAM6I,EAAUgJ,EAAa7R,GAC7BhB,OAAOwM,KAAK3C,GAAS+K,SAAQ,SAAApP,GAC3BoN,EAAOpN,GAAOqE,EAAQrE,OAHjBxE,EAAI,EAAGA,EAAI6R,EAAanS,OAAQM,GAAK,EAAG,EAAxCA,GAMT,OAAO4R,GAGTlH,aAzHkB,SAyHLmH,GACX,OAAIA,EAAa,GAAGnS,OAAS,EACVqE,GAAY8N,EAAa,GAAG,MAC5BtR,EACRsR,EAAa,GAAGgC,QACrB,SAACxM,EAAMyM,GAAP,OAAgBlP,GAASyC,IAASzC,GAASkP,GAAOzM,EAAOyM,IACzDjC,EAAa,GAAG,IAGbA,EAAa,GAAGgC,QACrB,SAACjQ,EAAGmQ,GAAJ,OAAWxU,GAASwU,GAAGC,cAAczU,GAASqE,IAAM,EAAIA,EAAImQ,IAC5DlC,EAAa,GAAG,IAGb,MAGTzG,aA1IkB,SA0ILyG,GACX,GAAIA,EAAa,GAAGnS,OAAS,EAAG,CAE9B,GADiBqE,GAAY8N,EAAa,GAAG,MAC5BtR,EACf,OAAOsR,EAAa,GAAGgC,QACrB,SAACxM,EAAMyM,GAAP,OAAgBlP,GAASyC,IAASzC,GAASkP,GAAOzM,EAAOyM,IACzDjC,EAAa,GAAG,IAKpB,IAFA,IAAM8B,EAAW9B,EAAa,GAC1BoC,EAAaN,EAAS,GACjB3T,EAAI,EAAGA,EAAI2T,EAASjU,OAAQM,GAAK,EACpCT,GAASoU,EAAS3T,IAAIgU,cAAczU,GAAS0U,IAAe,IAC9DA,EAAaN,EAAS3T,IAG1B,OAAOiU,EAET,OAAO,MAGThJ,aA/JkB,SA+JL4G,GAGX,IAFA,IAAI7G,EAAM,EACJkJ,EAAYrC,EAAa,GACtB7R,EAAI,EAAGA,EAAIkU,EAAUxU,OAAQM,GAAK,EACzCgL,GAAsB,EAAfkJ,EAAUlU,GAEnB,OAAOgL,GAET6B,aAvKkB,SAuKLsH,GACX,QAASrU,EAAQqU,EAAY,OAASrU,EAAQqU,EAAY,KAE5D9G,YA1KkB,SA0KN8G,GACV,OAAOrU,EAAQqU,EAAY,IAAMA,EAAY,GAAKA,EAAY,IAEhEpH,YA7KkB,SA6KNoH,GACV,QAASrU,EAAQqU,EAAY,OAASrU,EAAQqU,EAAY,KAE5DlH,aAhLkB,SAgLLkH,GACX,OAAQrU,EAAQqU,EAAY,KAG9B5I,cApLkB,SAoLJsG,GAEZ,OAAQ9N,GAAY8N,EAAa,KAC/B,KAAKtR,EACH,MAAO,SACT,KAAKC,EACH,MAAO,SACT,KAAKC,EACH,MAAO,QACT,KFzvDO,EE0vDL,MAAO,SACT,KAAKC,EACH,MAAO,UACT,KF3vDO,EE4vDL,MAAO,SACT,KAAKC,EACH,MAAO,SAIb8K,cAxMkB,SAwMJoG,GACZ,OAAO7S,OAAOwM,KAAKqG,EAAa,KAGlClG,gBA5MkB,SA4MFkG,GAId,IAHA,IAAMpO,EAAMoO,EAAa,GACnBrG,EAAOxM,OAAOwM,KAAK/H,GACnBiI,EAAS,GACN1L,EAAI,EAAGA,EAAIwL,EAAK9L,OAAQM,GAAK,EACpC0L,EAAOhG,KAAKjC,EAAI+H,EAAKxL,KAEvB,OAAO0L,GAGTO,cAtNkB,SAsNJ4F,GACZ,IAAMuC,EAAWvC,EAAa,GAE9B,OADiBA,EAAa,GACd7F,KAAKoI,IAGvB/H,iBA5NkB,SA4NDwF,GACf,OAAI9N,GAAY8N,EAAa,MAAQpR,EAC5BoR,EAAa,GAEf,CAACA,EAAa,KAGvBtF,kBAnOkB,SAmOAsF,GAChB,OAAI9N,GAAY8N,EAAa,MAAQrR,EAC5BqR,EAAa,GAEf/I,KAAKuL,UAAUxC,EAAa,KAGrCpF,kBA1OkB,SA0OAoF,GAChB,IAAMyC,EAAWvQ,GAAY8N,EAAa,IAC1C,OAAIyC,IAAa/T,EACRsR,EAAa,GAElByC,IAAa9T,EACRoE,GAASiN,EAAa,IAExB,MAGTlF,iBArPkB,SAqPDkF,GACf,IAAK,IAAI7R,EAAI,EAAGA,EAAI6R,EAAanS,OAAQM,GAAK,EAC5C,GAAI+D,GAAY8N,EAAa7R,MAAQW,EACnC,OAAOkR,EAAa7R,GAGxB,OAAO,MAGT6L,cA9PkB,SA8PJgG,GACZ,IAAM0C,EAAc1C,EAAa,GAAG3R,MAAM,GAC1C,GAAIqU,EAAY7U,OAAS,EAAG,CAC1B,IAAM8U,EAAYzQ,GAAY8N,EAAa,GAAG,MAAQtR,EAAcqE,GAAWrF,GAC/EgV,EAAY3I,MAAK,SAAChI,EAAGmQ,GACnB,IAAMU,EAAKD,EAAU5Q,GACf8Q,EAAKF,EAAUT,GACrB,OAAIU,EAAKC,GAAY,EACjBD,EAAKC,EAAW,EACb,KAGX,OAAOH,GAGTxI,gBA7QkB,SA6QF8F,GACd,IAAM0C,EAAc1C,EAAa,GAAG3R,MAAM,GAC1C,GAA2B,IAAvBqU,EAAY7U,OACd,OAAO6U,EAET,IAAMf,EAAc3L,KAAK4L,aACnBC,EAAa7B,EAAa,GAC1B8C,EAAe5Q,GACnByP,EAAYxC,MAAM0C,EAAYa,EAAY,KAE5C,GAAI,CAAChU,EAAaC,GAAaL,QAAQwU,GAAgB,EACrD,MAAM,IAAIxP,MAAM,aAUlB,IADA,IAAMyP,EAAY,GACT5U,EAAI,EAAGA,EAAIuU,EAAY7U,OAAQM,GAAK,EAC3C4U,EAAUlP,KAAK,CAAC1F,EAAGuU,EAAYvU,KAEjC4U,EAAUhJ,MAAK,SAAChI,EAAGmQ,GACjB,IAAMc,EAAQrB,EAAYxC,MAAM0C,EAAY9P,EAAE,IACxCkR,EAAQtB,EAAYxC,MAAM0C,EAAYK,EAAE,IAC9C,GAAIhQ,GAAY8Q,KAAWF,EACzB,MAAM,IAAIxP,MAAJ,8BACmBwP,EADnB,sBAEF5Q,GAAY8Q,KAEX,GAAI9Q,GAAY+Q,KAAWH,EAChC,MAAM,IAAIxP,MAAJ,8BACmBwP,EADnB,sBAEF5Q,GAAY+Q,KAGlB,OAAID,EAAQC,EACH,EAELD,EAAQC,GACF,EAKHlR,EAAE,GAAKmQ,EAAE,MAGlB,IAAK,IAAI9B,EAAI,EAAGA,EAAI2C,EAAUlV,OAAQuS,GAAK,EAAG,SACvB2C,EAAU3C,GADa,GACzCsC,EAAYtC,GAD6B,KAG9C,OAAOsC,GAGTxJ,eArUkB,SAqUH8G,GAOb,IANA,IAIIkD,EACAlM,EALE6K,EAAa7B,EAAa,GAC1BmD,EAAgBnD,EAAa,GAC7BoD,EAAcpN,KAAKqN,kBAAkBxB,EAAY,CAACnT,EAAaC,IACjE2U,GAAY,IAGPnV,EAAI,EAAGA,EAAIgV,EAActV,OAAQM,GAAK,GAC7C6I,EAAUoM,EAAYD,EAAchV,KACtBmV,IACZA,EAAYtM,EACZkM,EAAYC,EAAchV,IAG9B,OAAO+U,GAGTzJ,eAtVkB,SAsVHuG,GAOb,IANA,IAIIuD,EACAvM,EALE6K,EAAa7B,EAAa,GAC1BmD,EAAgBnD,EAAa,GAC7BoD,EAAcpN,KAAKqN,kBAAkBxB,EAAY,CAACnT,EAAaC,IACjE6U,EAAYC,EAAAA,EAGPtV,EAAI,EAAGA,EAAIgV,EAActV,OAAQM,GAAK,GAC7C6I,EAAUoM,EAAYD,EAAchV,KACtBqV,IACZA,EAAYxM,EACZuM,EAAYJ,EAAchV,IAG9B,OAAOoV,GAGTF,kBAvWkB,SAuWAxB,EAAY6B,GAC5B,IAAM/B,EAAc3L,KAAK4L,aAUzB,OATgB,SAAA+B,GACd,IAAM3M,EAAU2K,EAAYxC,MAAM0C,EAAY8B,GAC9C,GAAID,EAAapV,QAAQ4D,GAAY8E,IAAY,EAAG,CAClD,IAAM4M,EAAM,8BAAH,OAAiCF,EAAjC,sBACKxR,GAAY8E,IAC1B,MAAM,IAAI1D,MAAMsQ,GAElB,OAAO5M,KA6BbhB,KAAKL,SAjBL,SAAkBL,GAEhB,OADc,IAAII,IACLC,SAASL,IAgBxBU,KAAK6N,QAxBL,SAAiBvO,GAGf,OAFe,IAAImC,IACAP,MAAM5B,IAuB3BU,KAAKkJ,OAdL,SAAgB4E,EAAMC,EAASrI,EAAY7D,GACzC,IAAMmM,EAAS,IAAIvM,GAIbE,EAAU,IAAIC,GAAQC,GACtB8J,EAAc,IAAIjK,GAAgBC,GACxCA,EAAQiK,aAAeD,EACnBoC,IAASzS,EAAeyS,GAC5B,IAAMrH,EAAOsH,EAAO9M,MAAMwE,GAC1B,OAAOiG,EAAYzC,OAAOxC,EAAMoH,IAKlC9N,KAAK3D,gBAAkBA,I,0tCCt8DzB,IAyCI4R,EAzCEC,EAAY,GAwBlB,SAASC,EAAaC,EAAQC,EAAU9E,GAClCA,aAAiBtM,OACnBmR,EAAOC,GAAY,GACnB9E,EAAMwC,SAAQ,SAACuC,EAAM1I,GACnBuI,EAAaC,EAAOC,GAAWzI,EAAO0I,OAErB,OAAV/E,GAAmC,WAAjB,EAAOA,IAClC6E,EAAOC,GAAY,GACnBlX,OAAOwM,KAAK4F,GAAOwC,SAAQ,SAAAwC,GACzBJ,EAAaC,EAAOC,GAAWE,EAAGhF,EAAMgF,QAI1CH,EAAOC,GAlCX,SAAqBvN,EAAMzJ,GAA0C,IAAnCmX,EAAmC,wDAAjBC,IAAiB,yDAiB7DC,EAAW,IAjBkD,mEAEjE,WAAY,OAAOrX,IAF8C,sBAIjE,WAAa,OAAOA,EAAMK,aAJuC,oBAMjE,WAAW,OAAOL,IAN+C,KAS7D,SAT6D,IASjE,WAAiB,OAAOA,IATyC,KAW7D,QAX6D,IAWjE,WAAgB,OAAOyJ,IAX0C,KAa7D,YAb6D,IAajE,WAAoB,OAAO0N,IAbsC,KAe7D,YAf6D,IAejE,WAAoB,OAAOC,MAfsC,MAmBnE,OADAP,EAAUrQ,KAAK6Q,GACRA,EAecC,CAAYN,EAAU9E,GApC7C2E,EAAUrW,OAAS,E,IA0CE+W,EAAAA,WACnB,WAAYC,EAAWC,GAAU,qBAC/Bb,EAAKY,EACLV,EAAaU,EAAW,OAAQC,GAChC3X,OAAOwM,KAAKkL,EAAUf,MAAM/B,SAAQ,SAAAwC,GAClC,EAAKA,GAAKM,EAAUf,KAAKS,M,iCAI7B,WAAY,OAAON,EAAGH,O,uBAEtB,WAAc,OAAO7M,KAAKuL,UAAUyB,EAAGH,KAAM,KAAM,K,KAE/C,U,IAAJ,WAAkB,OAAOI,M,EAbNU,G,sOCrCrBG,OAAOC,iBAAiB,QAAQ,WAC9B,IAAMC,EAAcC,SAASC,eAAe,QACtCzJ,EAAawJ,SAASC,eAAe,cACrCvR,EAASsR,SAASC,eAAe,UAEjCC,EAAIL,OAAOM,aAAaC,QAAQ,QAClCF,IAAGH,EAAY5X,MAAQ+X,GAC3B,IAAMG,EAAMR,OAAOM,aAAaC,QAAQ,cAGxC,SAASE,IAEPT,OAAOM,aAAaI,QAAQ,OAAQR,EAAY5X,OAChD0X,OAAOM,aAAaI,QAAQ,aAAc/J,EAAWrO,OACrD,IAIIqY,EAJEC,EAAQjK,EAAWrO,MACnBuY,EAAYV,SAASC,eAAe,cAAcU,QACpDC,EAAO,KACLjB,EAAY,GAElB,IACEa,EAAWzO,KAAKC,MAAM+N,EAAY5X,OAC9BuY,IACFE,EAAO,IAAIlB,EAAKC,EAAWa,IAE7B,MAAO/Q,GAEP,YADAf,EAAOvG,MAAQsH,EAAEjH,YAInB,IACE,IAAMqY,EClCL,SAAqBC,EAAMjC,EAASrI,GAAkC,IAAtB7D,EAAsB,uDAAJ,GAEvE,OADUoO,EAAS/G,OAAO8G,EAAMjC,EAASrI,EAA/B,KAAgD7D,IDiCnCqO,CACjBN,EAAYf,EAAUf,KAAO4B,EAC7B,CAAES,MAAOL,EAAMM,EAAG,IAClBT,GACA,GAEIU,EAAIN,MAAAA,EAAkDA,EAAaA,EAAW9X,UACnE,WAAb,EAAOoY,GACTzS,EAAOvG,MAAQ4J,KAAKuL,UAAU6D,EAAG,KAAM,GAEvCzS,EAAOvG,MAAQgZ,EAEjB,MAAO1R,GACPf,EAAOvG,MAAQsH,EAAEjH,YAnCjB6X,IAAK7J,EAAWrO,MAAQkY,GAuC5BN,EAAYD,iBAAiB,OAAQQ,GACrC9J,EAAWsJ,iBAAiB,OAAQQ,GACpCA,IAEAc,MAAM,2BAA2BC,MAAK,SAAAF,GACpCA,EAAEG,OAAOD,MAAK,SAAAE,GACZvB,SAASC,eAAe,eAAeuB,UAAYD,W","sources":["webpack://JSONFormula/webpack/bootstrap","webpack://JSONFormula/webpack/runtime/make namespace object","webpack://JSONFormula/./jmespath.js/dataTypes.js","webpack://JSONFormula/./jmespath.js/openFormulaFunctions.js","webpack://JSONFormula/./jmespath.js/jmespath.js","webpack://JSONFormula/./src/Form.js","webpack://JSONFormula/./src/tutorial.js","webpack://JSONFormula/./src/json-formula.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Type constants used to define functions.\nexport default {\n  TYPE_NUMBER: 0,\n  TYPE_ANY: 1,\n  TYPE_STRING: 2,\n  TYPE_ARRAY: 3,\n  TYPE_OBJECT: 4,\n  TYPE_BOOLEAN: 5,\n  TYPE_EXPREF: 6,\n  TYPE_NULL: 7,\n  TYPE_ARRAY_NUMBER: 8,\n  TYPE_ARRAY_STRING: 9,\n};\n","import dataTypes from './dataTypes';\n\nexport default {\n  // SUBSTITUTE(Text T ; Text Old ; Text New [; Number Which ])\n  substitute: {\n    _func: args => {\n      const src = args[0].toString();\n      const old = args[1].toString();\n      const replacement = args[2].toString();\n      // no third parameter? replace all instances\n      if (args.length <= 3) return src.replace(new RegExp(old, 'g'), replacement);\n      const whch = args[3].valueOf();\n      // find the instance to replace\n      let pos = -1;\n      for (let i = 0; i < whch; i += 1) {\n        pos += 1;\n        const nextFind = src.slice(pos).indexOf(old);\n        // no instance to match 'Which'\n        if (nextFind === -1) return src;\n        pos += nextFind;\n      }\n      const result = src.slice(0, pos) + src.slice(pos).replace(old, replacement);\n      return result;\n    },\n    _signature: [\n      { types: [dataTypes.TYPE_STRING] },\n      { types: [dataTypes.TYPE_STRING] },\n      { types: [dataTypes.TYPE_STRING] },\n      { types: [dataTypes.TYPE_NUMBER], optional: true },\n    ],\n  },\n};\n","/* eslint-disable no-restricted-syntax */\n/* eslint-disable no-param-reassign */\n/* eslint-disable no-underscore-dangle */\nimport dataTypes from './dataTypes';\nimport openFormulaFunctions from './openFormulaFunctions';\n\n// Type constants used to define functions.\nconst {\n  TYPE_NUMBER,\n  TYPE_ANY,\n  TYPE_STRING,\n  TYPE_ARRAY,\n  TYPE_OBJECT,\n  TYPE_BOOLEAN,\n  TYPE_EXPREF,\n  TYPE_NULL,\n  TYPE_ARRAY_NUMBER,\n  TYPE_ARRAY_STRING,\n} = dataTypes;\n\nfunction JsonFormula() {\n  const TOK_EOF = 'EOF';\n  const TOK_UNQUOTEDIDENTIFIER = 'UnquotedIdentifier';\n  const TOK_QUOTEDIDENTIFIER = 'QuotedIdentifier';\n  const TOK_RBRACKET = 'Rbracket';\n  const TOK_RPAREN = 'Rparen';\n  const TOK_COMMA = 'Comma';\n  const TOK_COLON = 'Colon';\n  const TOK_CONCATENATE = 'Concatenate';\n  const TOK_RBRACE = 'Rbrace';\n  const TOK_NUMBER = 'Number';\n  const TOK_CURRENT = 'Current';\n  const TOK_GLOBAL = 'Global';\n  const TOK_FIELD = 'Field';\n  const TOK_EXPREF = 'Expref';\n  const TOK_PIPE = 'Pipe';\n  const TOK_OR = 'Or';\n  const TOK_AND = 'And';\n  const TOK_ADD = 'Add';\n  const TOK_SUBTRACT = 'Subtract';\n  const TOK_MULTIPLY = 'Multiply';\n  const TOK_POWER = 'Power';\n  const TOK_DIVIDE = 'Divide';\n  const TOK_EQ = 'EQ';\n  const TOK_GT = 'GT';\n  const TOK_LT = 'LT';\n  const TOK_GTE = 'GTE';\n  const TOK_LTE = 'LTE';\n  const TOK_NE = 'NE';\n  const TOK_FLATTEN = 'Flatten';\n  const TOK_STAR = 'Star';\n  const TOK_FILTER = 'Filter';\n  const TOK_DOT = 'Dot';\n  const TOK_NOT = 'Not';\n  const TOK_LBRACE = 'Lbrace';\n  const TOK_LBRACKET = 'Lbracket';\n  const TOK_LPAREN = 'Lparen';\n  const TOK_LITERAL = 'Literal';\n\n  const TYPE_NAME_TABLE = {\n    0: 'number',\n    1: 'any',\n    2: 'string',\n    3: 'array',\n    4: 'object',\n    5: 'boolean',\n    6: 'expression',\n    7: 'null',\n    8: 'Array<number>',\n    9: 'Array<string>',\n  };\n\n  let globalTokens = {};\n\n  function isNum(ch, includeSign) {\n    return (ch >= '0' && ch <= '9')\n             || (includeSign && ch === '-')\n             || (ch === '.');\n  }\n\n  function isAlphaNum(ch) {\n    return (ch >= 'a' && ch <= 'z')\n             || (ch >= 'A' && ch <= 'Z')\n             || (ch >= '0' && ch <= '9')\n             || ch === '_';\n  }\n\n  function isOperator(tok) {\n    return [\n      TOK_CONCATENATE,\n      TOK_OR,\n      TOK_AND,\n      TOK_ADD,\n      TOK_SUBTRACT,\n      TOK_MULTIPLY,\n      TOK_POWER,\n      TOK_DIVIDE,\n      TOK_EQ,\n      TOK_GT,\n      TOK_LT,\n      TOK_GTE,\n      TOK_LTE,\n      TOK_NE].includes(tok);\n  }\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    }\n    return false;\n  }\n\n  function valueOf(a) {\n    if (a === null || a === undefined) return a;\n    if (isArray(a)) {\n      return a.map(i => valueOf(i));\n    }\n    return a.valueOf();\n  }\n\n  function toString(a) {\n    if (a === null || a === undefined) return '';\n    return a.toString();\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === '[object Object]';\n    }\n    return false;\n  }\n\n  function getTypeName(inputObj) {\n    if (inputObj === null) return TYPE_NULL;\n    const obj = inputObj.valueOf();\n    switch (Object.prototype.toString.call(obj)) {\n      case '[object String]':\n        return TYPE_STRING;\n      case '[object Number]':\n        return TYPE_NUMBER;\n      case '[object Array]':\n        return TYPE_ARRAY;\n      case '[object Boolean]':\n        return TYPE_BOOLEAN;\n      case '[object Null]':\n        return TYPE_NULL;\n      case '[object Object]':\n        // Check if it's an expref.  If it has, it's been\n        // tagged with a jmespathType attr of 'Expref';\n        if (obj.jmespathType === TOK_EXPREF) {\n          return TYPE_EXPREF;\n        }\n        return TYPE_OBJECT;\n      default:\n        return TYPE_OBJECT;\n    }\n  }\n\n  function strictDeepEqual(lhs, rhs) {\n    const first = valueOf(lhs);\n    const second = valueOf(rhs);\n    // Check the scalar case first.\n    if (first === second) {\n      return true;\n    }\n\n    // Check if they are the same type.\n    const firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    // We know that first and second have the same type so we can just check the\n    // first type from now on.\n    if (isArray(first) === true) {\n      // Short circuit if they're not the same length;\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (let i = 0; i < first.length; i += 1) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      // An object is equal if it has the same key/value pairs.\n      const keysSeen = {};\n      for (const key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      // Now check that there aren't any keys in second that weren't\n      // in first.\n      for (const key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(value) {\n    // From the spec:\n    // A false value corresponds to the following values:\n    // Empty list\n    // Empty object\n    // Empty string\n    // False boolean\n    // null value\n    // (new) use JS truthy evaluation.  This changes the spec behavior.\n    // Where in the past a zero (0) would be True, it's now false\n\n    // First check the scalar values.\n    if (value === null) return true;\n    // in case it's an object with a valueOf defined\n    const obj = valueOf(value);\n    if (obj === '' || obj === false || obj === null) {\n      return true;\n    }\n    if (isArray(obj) && obj.length === 0) {\n      // Check for an empty array.\n      return true;\n    }\n    if (isObject(obj)) {\n      // Check for an empty object.\n      for (const key in obj) {\n        // If there are any keys, then\n        // the object is not empty so the object\n        // is not false.\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return !obj;\n  }\n\n  function objValues(obj) {\n    const keys = Object.keys(obj);\n    const values = [];\n    for (let i = 0; i < keys.length; i += 1) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function toNumber(value) {\n    const n = valueOf(value); // in case it's an object that implements valueOf()\n    if (n === null) return 0;\n    if (n instanceof Array) return 0;\n    if (typeof n === 'number') return n;\n    if (typeof n === 'string') {\n      const temp = parseFloat(n);\n      return Number.isNaN(temp) ? 0 : temp;\n    }\n    if (typeof n === 'boolean') return n ? 1 : 0;\n\n    // more coercions needed...\n    throw new Error('need to coerce number');\n  }\n\n  function applyOperator(first, second, operator) {\n    // TODO: fill in remaining operators\n    if (isArray(first) && isArray(second)) {\n      const len = Math.min(first.length, second.length);\n      const result = [];\n      let i;\n      for (i = 0; i < len; i += 1) {\n        if (isArray(first[i]) || isArray(second[i])) {\n          result.push(applyOperator(first[i], second[i], operator));\n        } else if (operator === '*') {\n          result.push(first[i] * second[i]);\n        } else if (operator === '&') {\n          result.push(first[i] + second[i]);\n        } else throw new Error('unimplemented');\n      }\n      for (i = len; i < Math.max(first.length, second.length); i += 1) {\n        // Result of the operator applied with 'null'\n        if (operator === '&') result.push('');\n        else if (operator === '*') result.push(0);\n      }\n      return result;\n    }\n\n    if (isArray(first) || isArray(second)) {\n      const [arr, scalar] = isArray(first) ? [first, second] : [second, first];\n      if (operator === '*') return arr.map(a => toNumber(a) * toNumber(scalar));\n      if (operator === '&') return arr.map(a => a + scalar);\n    }\n    if (operator === '*') return toNumber(first) * toNumber(second);\n    if (operator === '&') return first + second;\n    throw new Error(`unimplemented array operator: ${operator}`);\n  }\n  function matchType(actual, expectedList, argValue, context) {\n    if (expectedList.findIndex(\n      type => type === TYPE_ANY || actual === type,\n    ) !== -1\n    ) return argValue;\n    // Can't coerce Objects to any other type\n    if (actual === TYPE_OBJECT) {\n      throw new Error(`TypeError: ${context} expected argument to be type ${TYPE_NAME_TABLE[expectedList[0]]} but received type ${TYPE_NAME_TABLE[actual]} instead.`);\n    }\n    // no exact match in the list of possible types, see if we can coerce an array type\n    let expected = -1;\n    if (actual === TYPE_ARRAY) {\n      if (expectedList.includes(TYPE_ARRAY_STRING) && expectedList.includes(TYPE_ARRAY_NUMBER)) {\n        // choose the array type based on the first element\n        if (argValue.length > 0 && typeof argValue[0] === 'string') expected = TYPE_ARRAY_STRING;\n        else expected = TYPE_ARRAY_NUMBER;\n      }\n    }\n    if (expected === -1 && [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(actual)) {\n      expected = expectedList.find(\n        e => [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(e),\n      );\n    }\n    // no match, just take the first type\n    if (expected === -1) [expected] = expectedList;\n    if (expected === TYPE_ARRAY_STRING\n        || expected === TYPE_ARRAY_NUMBER\n        || expected === TYPE_ARRAY) {\n      if (expected === TYPE_ARRAY) {\n        if (actual === TYPE_ARRAY_NUMBER || actual === TYPE_ARRAY_STRING) return argValue;\n        return argValue === null ? [] : [argValue];\n      }\n      // The expected type can either just be array,\n      // or it can require a specific subtype (array of numbers).\n      const subtype = expected === TYPE_ARRAY_NUMBER ? TYPE_NUMBER : TYPE_STRING;\n      if (actual === TYPE_ARRAY) {\n        // Otherwise we need to check subtypes.\n        // We're going to modify the array, so take a copy\n        const returnArray = argValue.slice();\n        for (let i = 0; i < returnArray.length; i += 1) {\n          const indexType = getTypeName(returnArray[i]);\n          returnArray[i] = matchType(indexType, [subtype], returnArray[i], context);\n        }\n        return returnArray;\n      }\n      if ([TYPE_NUMBER, TYPE_STRING, TYPE_NULL, TYPE_BOOLEAN].includes(subtype)) {\n        return [matchType(actual, [subtype], argValue, context)];\n      }\n    } else {\n      if (expected === TYPE_NUMBER) {\n        if (actual === TYPE_STRING) {\n          return toNumber(argValue);\n        }\n        if (actual === TYPE_BOOLEAN) return argValue ? 1 : 0;\n        if (actual === TYPE_NULL) return 0;\n        /* TYPE_ARRAY, TYPE_EXPREF, TYPE_OBJECT, TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING */\n        return 0;\n      }\n      if (expected === TYPE_STRING) {\n        if (actual === TYPE_NULL || actual === TYPE_OBJECT) return '';\n        return argValue.toString();\n      }\n      if (expected === TYPE_BOOLEAN) {\n        return !!argValue;\n      }\n    }\n    throw new Error('unhandled argument');\n  }\n\n  let trimLeft;\n  if (typeof String.prototype.trimLeft === 'function') {\n    trimLeft = str => str.trimLeft();\n  } else {\n    trimLeft = str => str.match(/^\\s*(.*)/)[1];\n  }\n\n  // The \"&\", \"[\", \"<\", \">\" tokens\n  // are not in basicToken because\n  // there are two token variants\n  // (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n  // below.\n\n  const basicTokens = {\n    '.': TOK_DOT,\n    // \"*\": TOK_STAR,\n    ',': TOK_COMMA,\n    ':': TOK_COLON,\n    '{': TOK_LBRACE,\n    '}': TOK_RBRACE,\n    ']': TOK_RBRACKET,\n    '(': TOK_LPAREN,\n    ')': TOK_RPAREN,\n    '@': TOK_CURRENT,\n  };\n\n  const globalStartToken = '$';\n  const operatorStartToken = {\n    '<': true,\n    '>': true,\n    '=': true,\n    '!': true,\n  };\n\n  const skipChars = {\n    ' ': true,\n    '\\t': true,\n    '\\n': true,\n  };\n\n  function isIdentifier(stream, pos) {\n    const ch = stream[pos];\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    if (ch === '$') {\n      return stream.length > pos && isAlphaNum(stream[pos + 1]);\n    }\n    // return whether character 'isAlpha'\n    return (ch >= 'a' && ch <= 'z')\n            || (ch >= 'A' && ch <= 'Z')\n            || ch === '_';\n  }\n\n  function isGlobal(prev, stream, pos) {\n    // global tokens occur only at the start of an expression\n    if (prev !== null && prev === TOK_DOT) return false;\n    const ch = stream[pos];\n    if (ch !== globalStartToken) return false;\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    let i = pos + 1;\n    while (i < stream.length && isAlphaNum(stream[i])) i += 1;\n    const global = stream.slice(pos, i);\n    return !!globalTokens[global];\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n    tokenize(stream) {\n      const tokens = [];\n      this._current = 0;\n      let start;\n      let identifier;\n      let token;\n      while (this._current < stream.length) {\n        const prev = tokens.length ? tokens.slice(-1)[0].type : null;\n\n        if (isGlobal(prev, stream, this._current)) {\n          tokens.push(this._consumeGlobal(stream));\n        } else if (isIdentifier(stream, this._current)) {\n          start = this._current;\n          identifier = this._consumeUnquotedIdentifier(stream);\n          tokens.push({\n            type: TOK_UNQUOTEDIDENTIFIER,\n            value: identifier,\n            start,\n          });\n        } else if (basicTokens[stream[this._current]] !== undefined) {\n          tokens.push({\n            type: basicTokens[stream[this._current]],\n            value: stream[this._current],\n            start: this._current,\n          });\n          this._current += 1;\n        } else if ((stream[this._current] === '-' && !(prev === TOK_NUMBER || prev === TOK_RPAREN)) || isNum(stream[this._current], false)) {\n          token = this._consumeNumber(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === '[') {\n          // No need to increment this._current.  This happens\n          // in _consumeLBracket\n          token = this._consumeLBracket(stream);\n          tokens.push(token);\n        } else if (stream[this._current] === '\"') {\n          start = this._current;\n          identifier = this._consumeQuotedIdentifier(stream);\n          tokens.push({\n            type: TOK_QUOTEDIDENTIFIER,\n            value: identifier,\n            start,\n          });\n        } else if (stream[this._current] === \"'\") {\n          start = this._current;\n          identifier = this._consumeRawStringLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: identifier,\n            start,\n          });\n        } else if (stream[this._current] === '`') {\n          start = this._current;\n          const literal = this._consumeLiteral(stream);\n          tokens.push({\n            type: TOK_LITERAL,\n            value: literal,\n            start,\n          });\n        } else if (operatorStartToken[stream[this._current]] !== undefined) {\n          tokens.push(this._consumeOperator(stream));\n        } else if (skipChars[stream[this._current]] !== undefined) {\n          // Ignore whitespace.\n          this._current += 1;\n        } else if (stream[this._current] === '&') {\n          start = this._current;\n          this._current += 1;\n          if (stream[this._current] === '&') {\n            this._current += 1;\n            tokens.push({ type: TOK_AND, value: '&&', start });\n          } else if (prev === TOK_COMMA || prev === TOK_LPAREN) {\n            // based on previous token we'll know if this & is a JMESPath expression-type\n            // or if it's a concatenation operator\n            // if we're a function arg then it's an expression-type\n            tokens.push({ type: TOK_EXPREF, value: '&', start });\n          } else {\n            tokens.push({ type: TOK_CONCATENATE, value: '&', start });\n          }\n        } else if (stream[this._current] === '+') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_ADD, value: '+', start });\n        } else if (stream[this._current] === '-') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_SUBTRACT, value: '-', start });\n        } else if (stream[this._current] === '*') {\n          start = this._current;\n          this._current += 1;\n          // based on previous token we'll know if this asterix is a star -- not a multiply\n          // might be better to list the prev tokens that are valid for multiply?\n          const prevToken = tokens.length && tokens.slice(-1)[0].type;\n          if (tokens.length === 0 || [\n            TOK_LBRACKET,\n            TOK_DOT,\n            TOK_PIPE,\n            TOK_AND,\n            TOK_OR,\n            TOK_COMMA,\n            TOK_COLON,\n          ].includes(prevToken)) {\n            tokens.push({ type: TOK_STAR, value: '*', start });\n          } else {\n            tokens.push({ type: TOK_MULTIPLY, value: '*', start });\n          }\n        } else if (stream[this._current] === '/') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_DIVIDE, value: '/', start });\n        } else if (stream[this._current] === '^') {\n          start = this._current;\n          this._current += 1;\n          tokens.push({ type: TOK_POWER, value: '^', start });\n        } else if (stream[this._current] === '|') {\n          start = this._current;\n          this._current += 1;\n          if (stream[this._current] === '|') {\n            this._current += 1;\n            tokens.push({ type: TOK_OR, value: '||', start });\n          } else {\n            tokens.push({ type: TOK_PIPE, value: '|', start });\n          }\n        } else {\n          const error = new Error(`Unknown character:${stream[this._current]}`);\n          error.name = 'LexerError';\n          throw error;\n        }\n      }\n      return tokens;\n    },\n\n    _consumeUnquotedIdentifier(stream) {\n      const start = this._current;\n      this._current += 1;\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n        this._current += 1;\n      }\n      return stream.slice(start, this._current);\n    },\n\n    _consumeQuotedIdentifier(stream) {\n      const start = this._current;\n      this._current += 1;\n      const maxLength = stream.length;\n      while (stream[this._current] !== '\"' && this._current < maxLength) {\n        // You can escape a double quote and you can escape an escape.\n        let current = this._current;\n        if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                               || stream[current + 1] === '\"')) {\n          current += 2;\n        } else {\n          current += 1;\n        }\n        this._current = current;\n      }\n      this._current += 1;\n      return JSON.parse(stream.slice(start, this._current));\n    },\n\n    _consumeRawStringLiteral(stream) {\n      const start = this._current;\n      this._current += 1;\n      const maxLength = stream.length;\n      while (stream[this._current] !== \"'\" && this._current < maxLength) {\n        // You can escape a single quote and you can escape an escape.\n        let current = this._current;\n        if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                               || stream[current + 1] === \"'\")) {\n          current += 2;\n        } else {\n          current += 1;\n        }\n        this._current = current;\n      }\n      this._current += 1;\n      const literal = stream.slice(start + 1, this._current - 1);\n      return literal.replace(\"\\\\'\", \"'\");\n    },\n\n    _consumeNumber(stream) {\n      const start = this._current;\n      this._current += 1;\n      const maxLength = stream.length;\n      while (isNum(stream[this._current], false) && this._current < maxLength) {\n        this._current += 1;\n      }\n      const n = stream.slice(start, this._current);\n      let value;\n      if (n.includes('.')) {\n        value = parseFloat(n);\n      } else {\n        value = parseInt(n, 10);\n      }\n      return { type: TOK_NUMBER, value, start };\n    },\n\n    _consumeLBracket(stream) {\n      const start = this._current;\n      this._current += 1;\n      if (stream[this._current] === '?') {\n        this._current += 1;\n        return { type: TOK_FILTER, value: '[?', start };\n      }\n      if (stream[this._current] === ']') {\n        this._current += 1;\n        return { type: TOK_FLATTEN, value: '[]', start };\n      }\n      return { type: TOK_LBRACKET, value: '[', start };\n    },\n\n    _consumeGlobal(stream) {\n      const start = this._current;\n      this._current += 1;\n      while (this._current < stream.length && isAlphaNum(stream[this._current])) this._current += 1;\n      const global = stream.slice(start, this._current);\n\n      return { type: TOK_GLOBAL, value: globalTokens[global], start };\n    },\n\n    _consumeOperator(stream) {\n      const start = this._current;\n      const startingChar = stream[start];\n      this._current += 1;\n      if (startingChar === '!') {\n        if (stream[this._current] === '=') {\n          this._current += 1;\n          return { type: TOK_NE, value: '!=', start };\n        }\n        return { type: TOK_NOT, value: '!', start };\n      }\n      if (startingChar === '<') {\n        if (stream[this._current] === '=') {\n          this._current += 1;\n          return { type: TOK_LTE, value: '<=', start };\n        }\n        return { type: TOK_LT, value: '<', start };\n      }\n      if (startingChar === '>') {\n        if (stream[this._current] === '=') {\n          this._current += 1;\n          return { type: TOK_GTE, value: '>=', start };\n        }\n        return { type: TOK_GT, value: '>', start };\n      }\n      // startingChar is '='\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_EQ, value: '==', start };\n      }\n      return { type: TOK_EQ, value: '=', start };\n    },\n\n    _consumeLiteral(stream) {\n      this._current += 1;\n      const start = this._current;\n      const maxLength = stream.length;\n      let literal;\n      while (stream[this._current] !== '`' && this._current < maxLength) {\n        // You can escape a literal char or you can escape the escape.\n        let current = this._current;\n        if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                               || stream[current + 1] === '`')) {\n          current += 2;\n        } else {\n          current += 1;\n        }\n        this._current = current;\n      }\n      let literalString = trimLeft(stream.slice(start, this._current));\n      literalString = literalString.replace('\\\\`', '`');\n      if (this._looksLikeJSON(literalString)) {\n        literal = JSON.parse(literalString);\n      } else {\n        // Try to JSON parse it as \"<literal>\"\n        literal = JSON.parse(`\"${literalString}\"`);\n      }\n      // +1 gets us to the ending \"`\", +1 to move on to the next char.\n      this._current += 1;\n      return literal;\n    },\n\n    _looksLikeJSON(literalString) {\n      const startingChars = '[{\"';\n      const jsonLiterals = ['true', 'false', 'null'];\n      const numberLooking = '-0123456789';\n\n      if (literalString === '') {\n        return false;\n      }\n      if (startingChars.indexOf(literalString[0]) >= 0) {\n        return true;\n      }\n      if (jsonLiterals.indexOf(literalString) >= 0) {\n        return true;\n      }\n      if (numberLooking.indexOf(literalString[0]) >= 0) {\n        try {\n          JSON.parse(literalString);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    },\n  };\n\n  const bindingPower = {};\n  bindingPower[TOK_EOF] = 0;\n  bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n  bindingPower[TOK_RBRACKET] = 0;\n  bindingPower[TOK_RPAREN] = 0;\n  bindingPower[TOK_COMMA] = 0;\n  bindingPower[TOK_RBRACE] = 0;\n  bindingPower[TOK_NUMBER] = 0;\n  bindingPower[TOK_CURRENT] = 0;\n  bindingPower[TOK_GLOBAL] = 0;\n  bindingPower[TOK_FIELD] = 0;\n  bindingPower[TOK_EXPREF] = 0;\n  bindingPower[TOK_PIPE] = 1;\n  bindingPower[TOK_OR] = 2;\n  bindingPower[TOK_AND] = 3;\n  bindingPower[TOK_ADD] = 6;\n  bindingPower[TOK_SUBTRACT] = 6;\n  bindingPower[TOK_CONCATENATE] = 7;\n  bindingPower[TOK_MULTIPLY] = 7;\n  bindingPower[TOK_DIVIDE] = 7;\n  bindingPower[TOK_POWER] = 7;\n  bindingPower[TOK_EQ] = 5;\n  bindingPower[TOK_GT] = 5;\n  bindingPower[TOK_LT] = 5;\n  bindingPower[TOK_GTE] = 5;\n  bindingPower[TOK_LTE] = 5;\n  bindingPower[TOK_NE] = 5;\n  bindingPower[TOK_FLATTEN] = 9;\n  bindingPower[TOK_STAR] = 20;\n  bindingPower[TOK_FILTER] = 21;\n  bindingPower[TOK_DOT] = 40;\n  bindingPower[TOK_NOT] = 45;\n  bindingPower[TOK_LBRACE] = 50;\n  bindingPower[TOK_LBRACKET] = 55;\n  bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n    parse(expression) {\n      this._loadTokens(expression);\n      this.index = 0;\n      const ast = this.expression(0);\n      if (this._lookahead(0) !== TOK_EOF) {\n        const t = this._lookaheadToken(0);\n        const error = new Error(\n          `Unexpected token type: ${t.type}, value: ${t.value}`,\n        );\n        error.name = 'ParserError';\n        throw error;\n      }\n      return ast;\n    },\n\n    _loadTokens(expression) {\n      const lexer = new Lexer();\n      const tokens = lexer.tokenize(expression);\n      tokens.push({ type: TOK_EOF, value: '', start: expression.length });\n      this.tokens = tokens;\n    },\n\n    expression(rbp) {\n      const leftToken = this._lookaheadToken(0);\n      this._advance();\n      let left = this.nud(leftToken);\n      let currentToken = this._lookahead(0);\n      while (rbp < bindingPower[currentToken]) {\n        this._advance();\n        left = this.led(currentToken, left);\n        currentToken = this._lookahead(0);\n      }\n      return left;\n    },\n\n    _lookahead(number) {\n      return this.tokens[this.index + number].type;\n    },\n\n    _lookaheadToken(number) {\n      return this.tokens[this.index + number];\n    },\n\n    _advance() {\n      this.index += 1;\n    },\n\n    // eslint-disable-next-line consistent-return\n    nud(token) {\n      let left;\n      let right;\n      let expression;\n      let node;\n      let args;\n      switch (token.type) {\n        case TOK_LITERAL:\n          return { type: 'Literal', value: token.value };\n        case TOK_NUMBER:\n          return { type: 'Number', value: token.value };\n        case TOK_UNQUOTEDIDENTIFIER:\n          return { type: 'Field', name: token.value };\n        case TOK_QUOTEDIDENTIFIER:\n          node = { type: 'Field', name: token.value };\n          if (this._lookahead(0) === TOK_LPAREN) {\n            throw new Error('Quoted identifier not allowed for function names.');\n          }\n          return node;\n        case TOK_NOT:\n          right = this.expression(bindingPower.Not);\n          return { type: 'NotExpression', children: [right] };\n        case TOK_STAR:\n          left = { type: 'Identity' };\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            // This can happen in a multiselect,\n            // [a, b, *]\n            right = { type: 'Identity' };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Star);\n          }\n          return { type: 'ValueProjection', children: [left, right] };\n        case TOK_FILTER:\n          return this.led(token.type, { type: 'Identity' });\n        case TOK_LBRACE:\n          return this._parseMultiselectHash();\n        case TOK_FLATTEN:\n          left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };\n          right = this._parseProjectionRHS(bindingPower.Flatten);\n          return { type: 'Projection', children: [left, right] };\n        case TOK_LBRACKET:\n          // seeing a comma means that we are not a projection -- assume a list\n          // but the cases of [0] and [] are still ambiguous\n          // the better solution is to force us down the index expression path\n          // after pipe and after identifier\n          if (this._lookahead(1) === TOK_COMMA || isOperator(this._lookahead(1))) {\n            return this._parseMultiselectList();\n          }\n          if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice({ type: 'Identity' }, right);\n          }\n          if (this._lookahead(0) === TOK_STAR\n                       && this._lookahead(1) === TOK_RBRACKET) {\n            this._advance();\n            this._advance();\n            right = this._parseProjectionRHS(bindingPower.Star);\n            return {\n              type: 'Projection',\n              children: [{ type: 'Identity' }, right],\n            };\n          }\n          return this._parseMultiselectList();\n        case TOK_CURRENT:\n          return { type: TOK_CURRENT };\n        case TOK_GLOBAL:\n          return { type: TOK_GLOBAL, value: token.value };\n        case TOK_FIELD:\n          return { type: TOK_FIELD };\n        case TOK_EXPREF:\n          expression = this.expression(bindingPower.Expref);\n          return { type: 'ExpressionReference', children: [expression] };\n        case TOK_LPAREN:\n          args = [];\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = { type: TOK_CURRENT };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          return args[0];\n        default:\n          this._errorToken(token);\n      }\n    },\n\n    // eslint-disable-next-line consistent-return\n    led(tokenName, left) {\n      let condition;\n      let right;\n      let name;\n      let args;\n      let expression;\n      let node;\n      let rbp;\n      let leftNode;\n      let rightNode;\n      let token;\n      switch (tokenName) {\n        case TOK_CONCATENATE:\n          right = this.expression(bindingPower.Concatenate);\n          return { type: 'ConcatenateExpression', children: [left, right] };\n        case TOK_DOT:\n          rbp = bindingPower.Dot;\n          if (this._lookahead(0) !== TOK_STAR) {\n            right = this._parseDotRHS(rbp);\n            return { type: 'Subexpression', children: [left, right] };\n          }\n          // Creating a projection.\n          this._advance();\n          right = this._parseProjectionRHS(rbp);\n          return { type: 'ValueProjection', children: [left, right] };\n        case TOK_PIPE:\n          right = this.expression(bindingPower.Pipe);\n          return { type: TOK_PIPE, children: [left, right] };\n        case TOK_OR:\n          right = this.expression(bindingPower.Or);\n          return { type: 'OrExpression', children: [left, right] };\n        case TOK_AND:\n          right = this.expression(bindingPower.And);\n          return { type: 'AndExpression', children: [left, right] };\n        case TOK_ADD:\n          right = this.expression(bindingPower.Add);\n          return { type: 'AddExpression', children: [left, right] };\n        case TOK_SUBTRACT:\n          right = this.expression(bindingPower.Subtract);\n          return { type: 'SubtractExpression', children: [left, right] };\n        case TOK_MULTIPLY:\n          right = this.expression(bindingPower.Multiply);\n          return { type: 'MultiplyExpression', children: [left, right] };\n        case TOK_DIVIDE:\n          right = this.expression(bindingPower.Divide);\n          return { type: 'DivideExpression', children: [left, right] };\n        case TOK_POWER:\n          right = this.expression(bindingPower.Power);\n          return { type: 'PowerExpression', children: [left, right] };\n        case TOK_LPAREN:\n          name = left.name;\n          args = [];\n          while (this._lookahead(0) !== TOK_RPAREN) {\n            if (this._lookahead(0) === TOK_CURRENT) {\n              expression = { type: TOK_CURRENT };\n              this._advance();\n            } else {\n              expression = this.expression(0);\n            }\n            if (this._lookahead(0) === TOK_COMMA) {\n              this._match(TOK_COMMA);\n            }\n            args.push(expression);\n          }\n          this._match(TOK_RPAREN);\n          node = { type: 'Function', name, children: args };\n          return node;\n        case TOK_FILTER:\n          condition = this.expression(0);\n          this._match(TOK_RBRACKET);\n          if (this._lookahead(0) === TOK_FLATTEN) {\n            right = { type: 'Identity' };\n          } else {\n            right = this._parseProjectionRHS(bindingPower.Filter);\n          }\n          return { type: 'FilterProjection', children: [left, right, condition] };\n        case TOK_FLATTEN:\n          leftNode = { type: TOK_FLATTEN, children: [left] };\n          rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n          return { type: 'Projection', children: [leftNode, rightNode] };\n        case TOK_EQ:\n        case TOK_NE:\n        case TOK_GT:\n        case TOK_GTE:\n        case TOK_LT:\n        case TOK_LTE:\n          return this._parseComparator(left, tokenName);\n        case TOK_LBRACKET:\n          token = this._lookaheadToken(0);\n          if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n            right = this._parseIndexExpression();\n            return this._projectIfSlice(left, right);\n          }\n          this._match(TOK_STAR);\n          this._match(TOK_RBRACKET);\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return { type: 'Projection', children: [left, right] };\n        default:\n          this._errorToken(this._lookaheadToken(0));\n      }\n    },\n\n    _match(tokenType) {\n      if (this._lookahead(0) === tokenType) {\n        this._advance();\n      } else {\n        const t = this._lookaheadToken(0);\n        const error = new Error(`Expected ${tokenType}, got: ${t.type}`);\n        error.name = 'ParserError';\n        throw error;\n      }\n    },\n\n    _errorToken(token) {\n      const error = new Error(`Invalid token (${\n        token.type}): \"${\n        token.value}\"`);\n      error.name = 'ParserError';\n      throw error;\n    },\n\n    _parseIndexExpression() {\n      if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n        return this._parseSliceExpression();\n      }\n      const node = {\n        type: 'Index',\n        value: this._lookaheadToken(0).value,\n      };\n      this._advance();\n      this._match(TOK_RBRACKET);\n      return node;\n    },\n\n    _projectIfSlice(left, right) {\n      const indexExpr = { type: 'IndexExpression', children: [left, right] };\n      if (right.type === 'Slice') {\n        return {\n          type: 'Projection',\n          children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],\n        };\n      }\n      return indexExpr;\n    },\n\n    _parseSliceExpression() {\n      // [start:end:step] where each part is optional, as well as the last\n      // colon.\n      const parts = [null, null, null];\n      let index = 0;\n      let currentToken = this._lookahead(0);\n      while (currentToken !== TOK_RBRACKET && index < 3) {\n        if (currentToken === TOK_COLON) {\n          index += 1;\n          this._advance();\n        } else if (currentToken === TOK_NUMBER) {\n          parts[index] = this._lookaheadToken(0).value;\n          this._advance();\n        } else {\n          const t = this._lookahead(0);\n          const error = new Error(`Syntax error, unexpected token: ${\n            t.value}(${t.type})`);\n          error.name = 'Parsererror';\n          throw error;\n        }\n        currentToken = this._lookahead(0);\n      }\n      this._match(TOK_RBRACKET);\n      return {\n        type: 'Slice',\n        children: parts,\n      };\n    },\n\n    _parseComparator(left, comparator) {\n      const right = this.expression(bindingPower[comparator]);\n      return { type: 'Comparator', name: comparator, children: [left, right] };\n    },\n\n    // eslint-disable-next-line consistent-return\n    _parseDotRHS(rbp) {\n      const lookahead = this._lookahead(0);\n      const exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n      if (exprTokens.indexOf(lookahead) >= 0) {\n        return this.expression(rbp);\n      }\n      if (lookahead === TOK_LBRACKET) {\n        this._match(TOK_LBRACKET);\n        return this._parseMultiselectList();\n      }\n      if (lookahead === TOK_LBRACE) {\n        this._match(TOK_LBRACE);\n        return this._parseMultiselectHash();\n      }\n    },\n\n    _parseProjectionRHS(rbp) {\n      let right;\n      if (bindingPower[this._lookahead(0)] < 10) {\n        right = { type: 'Identity' };\n      } else if (this._lookahead(0) === TOK_LBRACKET) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_FILTER) {\n        right = this.expression(rbp);\n      } else if (this._lookahead(0) === TOK_DOT) {\n        this._match(TOK_DOT);\n        right = this._parseDotRHS(rbp);\n      } else {\n        const t = this._lookaheadToken(0);\n        const error = new Error(`Sytanx error, unexpected token: ${\n          t.value}(${t.type})`);\n        error.name = 'ParserError';\n        throw error;\n      }\n      return right;\n    },\n\n    _parseMultiselectList() {\n      const expressions = [];\n      while (this._lookahead(0) !== TOK_RBRACKET) {\n        const expression = this.expression(0);\n        expressions.push(expression);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n          if (this._lookahead(0) === TOK_RBRACKET) {\n            throw new Error('Unexpected token Rbracket');\n          }\n        }\n      }\n      this._match(TOK_RBRACKET);\n      return { type: 'MultiSelectList', children: expressions };\n    },\n\n    _parseMultiselectHash() {\n      const pairs = [];\n      const identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n      let keyToken; let keyName; let value; let\n        node;\n      for (;;) {\n        keyToken = this._lookaheadToken(0);\n        if (identifierTypes.indexOf(keyToken.type) < 0) {\n          throw new Error(`Expecting an identifier token, got: ${\n            keyToken.type}`);\n        }\n        keyName = keyToken.value;\n        this._advance();\n        this._match(TOK_COLON);\n        value = this.expression(0);\n        node = { type: 'KeyValuePair', name: keyName, value };\n        pairs.push(node);\n        if (this._lookahead(0) === TOK_COMMA) {\n          this._match(TOK_COMMA);\n        } else if (this._lookahead(0) === TOK_RBRACE) {\n          this._match(TOK_RBRACE);\n          break;\n        }\n      }\n      return { type: 'MultiSelectHash', children: pairs };\n    },\n  };\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n    search(node, value) {\n      return this.visit(node, value);\n    },\n\n    visit(node, value) {\n      let matched;\n      let current;\n      let result;\n      let first;\n      let second;\n      let field;\n      let left;\n      let right;\n      let collected;\n      let i;\n      let child;\n      let base;\n      let index;\n      let sliceParams;\n      let computed;\n      let start;\n      let stop;\n      let step;\n      let values;\n      let filtered;\n      let finalResults;\n      let original;\n      let merged;\n      let resolvedArgs;\n      let refNode;\n\n      switch (node.type) {\n        case 'Field':\n          if (value !== null && isObject(value)) {\n            field = value[node.name];\n            if (field === undefined) {\n              return null;\n            }\n            return field;\n          }\n          return null;\n        case 'Subexpression':\n          result = this.visit(node.children[0], value);\n          for (i = 1; i < node.children.length; i += 1) {\n            result = this.visit(node.children[1], result);\n            if (result === null) {\n              return null;\n            }\n          }\n          return result;\n        case 'IndexExpression':\n          left = this.visit(node.children[0], value);\n          right = this.visit(node.children[1], left);\n          return right;\n        case 'Index':\n          if (!isArray(value)) {\n            return null;\n          }\n          index = node.value;\n          if (index < 0) {\n            index = value.length + index;\n          }\n          result = value[index];\n          if (result === undefined) {\n            result = null;\n          }\n          return result;\n        case 'Slice':\n          if (!isArray(value)) {\n            return null;\n          }\n          sliceParams = node.children.slice(0);\n          computed = this.computeSliceParams(value.length, sliceParams);\n          [start, stop, step] = computed;\n          result = [];\n          if (step > 0) {\n            for (i = start; i < stop; i += step) {\n              result.push(value[i]);\n            }\n          } else {\n            for (i = start; i > stop; i += step) {\n              result.push(value[i]);\n            }\n          }\n          return result;\n        case 'Projection':\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < base.length; i += 1) {\n            current = this.visit(node.children[1], base[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case 'ValueProjection':\n          // Evaluate left child.\n          base = this.visit(node.children[0], value);\n          if (!isObject(valueOf(base))) {\n            return null;\n          }\n          collected = [];\n          values = objValues(base);\n          for (i = 0; i < values.length; i += 1) {\n            current = this.visit(node.children[1], values[i]);\n            if (current !== null) {\n              collected.push(current);\n            }\n          }\n          return collected;\n        case 'FilterProjection':\n          base = this.visit(node.children[0], value);\n          if (!isArray(base)) {\n            return null;\n          }\n          filtered = [];\n          finalResults = [];\n          for (i = 0; i < base.length; i += 1) {\n            matched = this.visit(node.children[2], base[i]);\n            if (!isFalse(matched)) {\n              filtered.push(base[i]);\n            }\n          }\n          for (let j = 0; j < filtered.length; j += 1) {\n            current = this.visit(node.children[1], filtered[j]);\n            if (current !== null) {\n              finalResults.push(current);\n            }\n          }\n          return finalResults;\n        case 'Comparator':\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          switch (node.name) {\n            case TOK_EQ:\n              result = strictDeepEqual(first, second);\n              break;\n            case TOK_NE:\n              result = !strictDeepEqual(first, second);\n              break;\n            case TOK_GT:\n              result = first > second;\n              break;\n            case TOK_GTE:\n              result = first >= second;\n              break;\n            case TOK_LT:\n              result = first < second;\n              break;\n            case TOK_LTE:\n              result = first <= second;\n              break;\n            default:\n              throw new Error(`Unknown comparator: ${node.name}`);\n          }\n          return result;\n        case TOK_FLATTEN:\n          original = this.visit(node.children[0], value);\n          if (!isArray(original)) {\n            return null;\n          }\n          merged = [];\n          for (i = 0; i < original.length; i += 1) {\n            current = original[i];\n            if (isArray(current)) {\n              merged.push(...current);\n            } else {\n              merged.push(current);\n            }\n          }\n          return merged;\n        case 'Identity':\n          return value;\n        case 'MultiSelectList':\n          if (value === null) {\n            return null;\n          }\n          collected = [];\n          for (i = 0; i < node.children.length; i += 1) {\n            collected.push(this.visit(node.children[i], value));\n          }\n          return collected;\n        case 'MultiSelectHash':\n          if (value === null) {\n            return null;\n          }\n          collected = {};\n          for (i = 0; i < node.children.length; i += 1) {\n            child = node.children[i];\n            collected[child.name] = this.visit(child.value, value);\n          }\n          return collected;\n        case 'OrExpression':\n          matched = this.visit(node.children[0], value);\n          if (isFalse(matched)) {\n            matched = this.visit(node.children[1], value);\n          }\n          return matched;\n        case 'AndExpression':\n          first = this.visit(node.children[0], value);\n\n          if (isFalse(first) === true) {\n            return first;\n          }\n          return this.visit(node.children[1], value);\n        case 'AddExpression':\n          first = this.visit(node.children[0], value);\n          return toNumber(first) + toNumber(this.visit(node.children[1], value));\n        case 'ConcatenateExpression':\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          first = matchType(getTypeName(first), [TYPE_STRING, TYPE_ARRAY_STRING], first, 'concatenate');\n          second = matchType(getTypeName(second), [TYPE_STRING, TYPE_ARRAY_STRING], second, 'concatenate');\n          return applyOperator(first, second, '&');\n        case 'SubtractExpression':\n          first = this.visit(node.children[0], value);\n          return first - this.visit(node.children[1], value);\n        case 'MultiplyExpression':\n          first = this.visit(node.children[0], value);\n          second = this.visit(node.children[1], value);\n          return applyOperator(first, second, '*');\n        case 'DivideExpression':\n          first = this.visit(node.children[0], value);\n          return first / this.visit(node.children[1], value);\n        case 'PowerExpression':\n          first = this.visit(node.children[0], value);\n          return first ** this.visit(node.children[1], value);\n        case 'NotExpression':\n          first = this.visit(node.children[0], value);\n          return isFalse(first);\n        case 'Literal':\n          return node.value;\n        case 'Number':\n          return node.value;\n        case TOK_PIPE:\n          left = this.visit(node.children[0], value);\n          return this.visit(node.children[1], left);\n        case TOK_CURRENT:\n          return value;\n        case TOK_GLOBAL:\n          return node.value;\n        case 'Function':\n          resolvedArgs = [];\n          for (i = 0; i < node.children.length; i += 1) {\n            resolvedArgs.push(this.visit(node.children[i], value));\n          }\n          return this.runtime.callFunction(node.name, resolvedArgs);\n        case 'ExpressionReference':\n          [refNode] = node.children;\n          // Tag the node with a specific attribute so the type\n          // checker verify the type.\n          refNode.jmespathType = TOK_EXPREF;\n          return refNode;\n        default:\n          throw new Error(`Unknown node type: ${node.type}`);\n      }\n    },\n\n    computeSliceParams(arrayLength, sliceParams) {\n      let start = sliceParams[0];\n      let stop = sliceParams[1];\n      let step = sliceParams[2];\n      const computed = [null, null, null];\n      if (step === null) {\n        step = 1;\n      } else if (step === 0) {\n        const error = new Error('Invalid slice, step cannot be 0');\n        error.name = 'RuntimeError';\n        throw error;\n      }\n      const stepValueNegative = step < 0;\n\n      if (start === null) {\n        start = stepValueNegative ? arrayLength - 1 : 0;\n      } else {\n        start = this.capSliceRange(arrayLength, start, step);\n      }\n\n      if (stop === null) {\n        stop = stepValueNegative ? -1 : arrayLength;\n      } else {\n        stop = this.capSliceRange(arrayLength, stop, step);\n      }\n      computed[0] = start;\n      computed[1] = stop;\n      computed[2] = step;\n      return computed;\n    },\n\n    capSliceRange(arrayLength, actualValue, step) {\n      if (actualValue < 0) {\n        actualValue += arrayLength;\n        if (actualValue < 0) {\n          actualValue = step < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLength) {\n        actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n      }\n      return actualValue;\n    },\n\n  };\n\n  function Runtime(customFunctions = {}) {\n    this.functionTable = {\n      // name: [function, <signature>]\n      // The <signature> can be:\n      //\n      // {\n      //   args: [[type1, type2], [type1, type2]],\n      //   variadic: true|false\n      // }\n      //\n      // Each arg in the arg list is a list of valid types\n      // (if the function is overloaded and supports multiple\n      // types.  If the type is \"any\" then no type checking\n      // occurs on the argument.  Variadic is optional\n      // and if not provided is assumed to be false.\n      abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },\n      avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },\n      ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },\n      contains: {\n        _func: this._functionContains,\n        _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] },\n          { types: [TYPE_ANY] }],\n      },\n      ends_with: {\n        _func: this._functionEndsWith,\n        _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n      },\n      floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },\n      length: {\n        _func: this._functionLength,\n        _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],\n      },\n      map: {\n        _func: this._functionMap,\n        _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }],\n      },\n      max: {\n        _func: this._functionMax,\n        _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n      },\n      merge: {\n        _func: this._functionMerge,\n        _signature: [{ types: [TYPE_OBJECT], variadic: true }],\n      },\n      max_by: {\n        _func: this._functionMaxBy,\n        _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n      },\n      sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },\n      starts_with: {\n        _func: this._functionStartsWith,\n        _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n      },\n      min: {\n        _func: this._functionMin,\n        _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n      },\n      min_by: {\n        _func: this._functionMinBy,\n        _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n      },\n      type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },\n      keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },\n      values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },\n      sort: {\n        _func: this._functionSort,\n        _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }],\n      },\n      sort_by: {\n        _func: this._functionSortBy,\n        _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n      },\n      join: {\n        _func: this._functionJoin,\n        _signature: [\n          { types: [TYPE_STRING] },\n          { types: [TYPE_ARRAY_STRING] },\n        ],\n      },\n      reverse: {\n        _func: this._functionReverse,\n        _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],\n      },\n      to_array: { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },\n      to_string: { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },\n      to_number: { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },\n      not_null: {\n        _func: this._functionNotNull,\n        _signature: [{ types: [TYPE_ANY], variadic: true }],\n      },\n      and: { _func: this._functionAnd, _signature: [{ types: [TYPE_ANY] }, { types: [TYPE_ANY] }] },\n      or: { _func: this._functionOr, _signature: [{ types: [TYPE_ANY] }, { types: [TYPE_ANY] }] },\n      not: { _func: this._functionNot, _signature: [{ types: [TYPE_ANY] }] },\n      true: { _func() { return true; }, _signature: [] },\n      false: { _func() { return false; }, _signature: [] },\n      if: {\n        _func: this._functionIf,\n        _signature: [{ types: [TYPE_ANY] }, { types: [TYPE_ANY] }, { types: [TYPE_ANY] }],\n      },\n      ...openFormulaFunctions,\n      ...customFunctions,\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction(name, resolvedArgs) {\n      const functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n        throw new Error(`Unknown function: ${name}()`);\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n\n    _validateArgs(name, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      if (signature.length === 0) {\n        return;\n      }\n      let pluralized;\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? ' argument' : ' arguments';\n          throw new Error(`ArgumentError: ${name}() `\n                                + `takes at least${signature.length}${pluralized\n                                } but received ${args.length}`);\n        }\n      } else if (args.length !== signature.length && !signature[signature.length - 1].optional) {\n        pluralized = signature.length === 1 ? ' argument' : ' arguments';\n        throw new Error(`ArgumentError: ${name}() `\n                            + `takes ${signature.length}${pluralized\n                            } but received ${args.length}`);\n      }\n      let currentSpec;\n      let actualType;\n      const limit = Math.min(signature.length, args.length);\n      for (let i = 0; i < limit; i += 1) {\n        currentSpec = signature[i].types;\n        actualType = getTypeName(args[i]);\n        args[i] = matchType(actualType, currentSpec, args[i], name);\n      }\n    },\n\n    _functionStartsWith(resolvedArgs) {\n      return valueOf(resolvedArgs[0]).lastIndexOf(valueOf(resolvedArgs[1])) === 0;\n    },\n\n    _functionEndsWith(resolvedArgs) {\n      const searchStr = valueOf(resolvedArgs[0]);\n      const suffix = valueOf(resolvedArgs[1]);\n      return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n\n    _functionReverse(resolvedArgs) {\n      const originalStr = valueOf(resolvedArgs[0]);\n      const typeName = getTypeName(originalStr);\n      if (typeName === TYPE_STRING) {\n        let reversedStr = '';\n        for (let i = originalStr.length - 1; i >= 0; i -= 1) {\n          reversedStr += originalStr[i];\n        }\n        return reversedStr;\n      }\n      const reversedArray = resolvedArgs[0].slice(0);\n      reversedArray.reverse();\n      return reversedArray;\n    },\n\n    _functionAbs(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n\n    _functionCeil(resolvedArgs) {\n      return Math.ceil(resolvedArgs[0]);\n    },\n\n    _functionAvg(resolvedArgs) {\n      let sum = 0;\n      const inputArray = resolvedArgs[0];\n      for (let i = 0; i < inputArray.length; i += 1) {\n        sum += inputArray[i];\n      }\n      return sum / inputArray.length;\n    },\n    _functionContains(resolvedArgs) {\n      return valueOf(resolvedArgs[0]).indexOf(valueOf(resolvedArgs[1])) >= 0;\n    },\n\n    _functionFloor(resolvedArgs) {\n      return Math.floor(resolvedArgs[0]);\n    },\n\n    _functionLength(resolvedArgs) {\n      const arg = valueOf(resolvedArgs[0]);\n      if (isObject(arg)) return Object.keys(arg).length;\n\n      return isArray(arg) ? arg.length : toString(arg).length;\n    },\n\n    _functionMap(resolvedArgs) {\n      const mapped = [];\n      const interpreter = this._interpreter;\n      const exprefNode = resolvedArgs[0];\n      const elements = resolvedArgs[1];\n      for (let i = 0; i < elements.length; i += 1) {\n        mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n\n    _functionMerge(resolvedArgs) {\n      const merged = {};\n      for (let i = 0; i < resolvedArgs.length; i += 1) {\n        const current = resolvedArgs[i];\n        Object.keys(current).forEach(key => {\n          merged[key] = current[key];\n        });\n      }\n      return merged;\n    },\n\n    _functionMax(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        const typeName = getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return resolvedArgs[0].reduce(\n            (prev, cur) => (toNumber(prev) >= toNumber(cur) ? prev : cur),\n            resolvedArgs[0][0],\n          );\n        }\n        return resolvedArgs[0].reduce(\n          (a, b) => (toString(b).localeCompare(toString(a)) < 0 ? a : b),\n          resolvedArgs[0][0],\n        );\n      }\n      return null;\n    },\n\n    _functionMin(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        const typeName = getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return resolvedArgs[0].reduce(\n            (prev, cur) => (toNumber(prev) <= toNumber(cur) ? prev : cur),\n            resolvedArgs[0][0],\n          );\n        }\n        const elements = resolvedArgs[0];\n        let minElement = elements[0];\n        for (let i = 1; i < elements.length; i += 1) {\n          if (toString(elements[i]).localeCompare(toString(minElement)) < 0) {\n            minElement = elements[i];\n          }\n        }\n        return minElement;\n      }\n      return null;\n    },\n\n    _functionSum(resolvedArgs) {\n      let sum = 0;\n      const listToSum = resolvedArgs[0];\n      for (let i = 0; i < listToSum.length; i += 1) {\n        sum += listToSum[i] * 1;\n      }\n      return sum;\n    },\n    _functionAnd(resolveArgs) {\n      return !!valueOf(resolveArgs[0]) && !!valueOf(resolveArgs[1]);\n    },\n    _functionIf(resolveArgs) {\n      return valueOf(resolveArgs[0]) ? resolveArgs[1] : resolveArgs[2];\n    },\n    _functionOr(resolveArgs) {\n      return !!valueOf(resolveArgs[0]) || !!valueOf(resolveArgs[1]);\n    },\n    _functionNot(resolveArgs) {\n      return !valueOf(resolveArgs[0]);\n    },\n    // eslint-disable-next-line consistent-return\n    _functionType(resolvedArgs) {\n      // eslint-disable-next-line default-case\n      switch (getTypeName(resolvedArgs[0])) {\n        case TYPE_NUMBER:\n          return 'number';\n        case TYPE_STRING:\n          return 'string';\n        case TYPE_ARRAY:\n          return 'array';\n        case TYPE_OBJECT:\n          return 'object';\n        case TYPE_BOOLEAN:\n          return 'boolean';\n        case TYPE_EXPREF:\n          return 'expref';\n        case TYPE_NULL:\n          return 'null';\n      }\n    },\n\n    _functionKeys(resolvedArgs) {\n      return Object.keys(resolvedArgs[0]);\n    },\n\n    _functionValues(resolvedArgs) {\n      const obj = resolvedArgs[0];\n      const keys = Object.keys(obj);\n      const values = [];\n      for (let i = 0; i < keys.length; i += 1) {\n        values.push(obj[keys[i]]);\n      }\n      return values;\n    },\n\n    _functionJoin(resolvedArgs) {\n      const joinChar = resolvedArgs[0];\n      const listJoin = resolvedArgs[1];\n      return listJoin.join(joinChar);\n    },\n\n    _functionToArray(resolvedArgs) {\n      if (getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n        return resolvedArgs[0];\n      }\n      return [resolvedArgs[0]];\n    },\n\n    _functionToString(resolvedArgs) {\n      if (getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n        return resolvedArgs[0];\n      }\n      return JSON.stringify(resolvedArgs[0]);\n    },\n\n    _functionToNumber(resolvedArgs) {\n      const typeName = getTypeName(resolvedArgs[0]);\n      if (typeName === TYPE_NUMBER) {\n        return resolvedArgs[0];\n      }\n      if (typeName === TYPE_STRING) {\n        return toNumber(resolvedArgs[0]);\n      }\n      return null;\n    },\n\n    _functionNotNull(resolvedArgs) {\n      for (let i = 0; i < resolvedArgs.length; i += 1) {\n        if (getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n          return resolvedArgs[i];\n        }\n      }\n      return null;\n    },\n\n    _functionSort(resolvedArgs) {\n      const sortedArray = resolvedArgs[0].slice(0);\n      if (sortedArray.length > 0) {\n        const normalize = getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER ? toNumber : toString;\n        sortedArray.sort((a, b) => {\n          const va = normalize(a);\n          const vb = normalize(b);\n          if (va < vb) return -1;\n          if (va > vb) return 1;\n          return 0;\n        });\n      }\n      return sortedArray;\n    },\n\n    _functionSortBy(resolvedArgs) {\n      const sortedArray = resolvedArgs[0].slice(0);\n      if (sortedArray.length === 0) {\n        return sortedArray;\n      }\n      const interpreter = this._interpreter;\n      const exprefNode = resolvedArgs[1];\n      const requiredType = getTypeName(\n        interpreter.visit(exprefNode, sortedArray[0]),\n      );\n      if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n        throw new Error('TypeError');\n      }\n      // In order to get a stable sort out of an unstable\n      // sort algorithm, we decorate/sort/undecorate (DSU)\n      // by creating a new list of [index, element] pairs.\n      // In the cmp function, if the evaluated elements are\n      // equal, then the index will be used as the tiebreaker.\n      // After the decorated list has been sorted, it will be\n      // undecorated to extract the original elements.\n      const decorated = [];\n      for (let i = 0; i < sortedArray.length; i += 1) {\n        decorated.push([i, sortedArray[i]]);\n      }\n      decorated.sort((a, b) => {\n        const exprA = interpreter.visit(exprefNode, a[1]);\n        const exprB = interpreter.visit(exprefNode, b[1]);\n        if (getTypeName(exprA) !== requiredType) {\n          throw new Error(\n            `TypeError: expected ${requiredType}, received ${\n              getTypeName(exprA)}`,\n          );\n        } else if (getTypeName(exprB) !== requiredType) {\n          throw new Error(\n            `TypeError: expected ${requiredType}, received ${\n              getTypeName(exprB)}`,\n          );\n        }\n        if (exprA > exprB) {\n          return 1;\n        }\n        if (exprA < exprB) {\n          return -1;\n        }\n        // If they're equal compare the items by their\n        // order to maintain relative order of equal keys\n        // (i.e. to get a stable sort).\n        return a[0] - b[0];\n      });\n      // Undecorate: extract out the original list elements.\n      for (let j = 0; j < decorated.length; j += 1) {\n        [, sortedArray[j]] = decorated[j];\n      }\n      return sortedArray;\n    },\n\n    _functionMaxBy(resolvedArgs) {\n      const exprefNode = resolvedArgs[1];\n      const resolvedArray = resolvedArgs[0];\n      const keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      let maxNumber = -Infinity;\n      let maxRecord;\n      let current;\n      for (let i = 0; i < resolvedArray.length; i += 1) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n\n    _functionMinBy(resolvedArgs) {\n      const exprefNode = resolvedArgs[1];\n      const resolvedArray = resolvedArgs[0];\n      const keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      let minNumber = Infinity;\n      let minRecord;\n      let current;\n      for (let i = 0; i < resolvedArray.length; i += 1) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n\n    createKeyFunction(exprefNode, allowedTypes) {\n      const interpreter = this._interpreter;\n      const keyFunc = x => {\n        const current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(getTypeName(current)) < 0) {\n          const msg = `TypeError: expected one of ${allowedTypes\n          }, received ${getTypeName(current)}`;\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    },\n  };\n\n  function compile(stream) {\n    const parser = new Parser();\n    const ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n    const lexer = new Lexer();\n    return lexer.tokenize(stream);\n  }\n\n  function search(data, globals, expression, customFunctions) {\n    const parser = new Parser();\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    const runtime = new Runtime(customFunctions);\n    const interpreter = new TreeInterpreter(runtime);\n    runtime._interpreter = interpreter;\n    if (globals) globalTokens = globals;\n    const node = parser.parse(expression);\n    return interpreter.search(node, data);\n  }\n  this.tokenize = tokenize;\n  this.compile = compile;\n  this.search = search;\n  this.strictDeepEqual = strictDeepEqual;\n}\n\nexport default new JsonFormula();\n","/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable class-methods-use-this */\n/*\n    Field class allows objects to evaluate correctly according to context.\n    - if used in an expression, will return a value or string.\n    - for JSON.stringify() returns a scalar\n    - BUT also allows explicit access to properties. e.g. field.required, field.name etc.\n\n    Should allow us to eliminate getFieldProperty()\n  */\n\nconst allFields = [];\nallFields.length = 0;\n\nfunction createField(name, value, readonly = false, required = true) {\n  class Field {\n    valueOf() { return value; }\n\n    toString() { return value.toString(); }\n\n    toJSON() { return value; }\n\n    // Use getters and scope variables so that the children are not enumerable\n    get '$value'() { return value; }\n\n    get '$name'() { return name; }\n\n    get '$readonly'() { return readonly; }\n\n    get '$required'() { return required; }\n  }\n  const newField = new Field();\n  allFields.push(newField);\n  return newField;\n}\nfunction createFields(parent, childref, child) {\n  if (child instanceof Array) {\n    parent[childref] = [];\n    child.forEach((item, index) => {\n      createFields(parent[childref], index, item);\n    });\n  } else if (child !== null && typeof child === 'object') {\n    parent[childref] = {};\n    Object.keys(child).forEach(k => {\n      createFields(parent[childref], k, child[k]);\n    });\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    parent[childref] = createField(childref, child);\n  }\n}\n\nlet fd;\n\nexport default class Form {\n  constructor(fieldData, dataRoot) {\n    fd = fieldData;\n    createFields(fieldData, 'data', dataRoot);\n    Object.keys(fieldData.data).forEach(k => {\n      this[k] = fieldData.data[k];\n    });\n  }\n\n  valueOf() { return fd.data; }\n\n  stringify() { return JSON.stringify(fd.data, null, 2); }\n\n  get '$fields'() { return allFields; }\n}\n","/* eslint-disable no-param-reassign */\n/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n/* global window, document, fetch */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable-next-line max-classes-per-file */\nimport { jsonFormula } from './json-formula';\nimport Form from './Form';\n\nwindow.addEventListener('load', () => {\n  const dataElement = document.getElementById('data');\n  const expression = document.getElementById('expression');\n  const result = document.getElementById('result');\n\n  const d = window.localStorage.getItem('data');\n  if (d) dataElement.value = d;\n  const exp = window.localStorage.getItem('expression');\n  if (exp) expression.value = exp;\n\n  function run() {\n    // save for next time...\n    window.localStorage.setItem('data', dataElement.value);\n    window.localStorage.setItem('expression', expression.value);\n    const input = expression.value;\n    const useFields = document.getElementById('use-fields').checked;\n    let root = null;\n    const fieldData = {};\n    let jsonData;\n    try {\n      jsonData = JSON.parse(dataElement.value);\n      if (useFields) {\n        root = new Form(fieldData, jsonData);\n      }\n    } catch (e) {\n      result.value = e.toString();\n      return;\n    }\n\n    try {\n      const jsonResult = jsonFormula(\n        useFields ? fieldData.data : jsonData,\n        { $form: root, $: {} },\n        input,\n        true,\n      );\n      const r = jsonResult === null || jsonResult === undefined ? jsonResult : jsonResult.valueOf();\n      if (typeof r === 'object') {\n        result.value = JSON.stringify(r, null, 2);\n      } else {\n        result.value = r;\n      }\n    } catch (e) {\n      result.value = e.toString();\n    }\n  }\n\n  dataElement.addEventListener('blur', run);\n  expression.addEventListener('blur', run);\n  run();\n\n  fetch('../antlr/JSONFormula.g4').then(r => {\n    r.text().then(g4 => {\n      document.getElementById('grammar-out').innerHTML = g4;\n    });\n  });\n});\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport jmespath from '../jmespath.js/jmespath';\n\n// eslint-disable-next-line import/prefer-default-export\nexport function jsonFormula(json, globals, expression, customFunctions = {}) {\n  const x = jmespath.search(json, globals, expression, { ...customFunctions });\n  return x;\n}\n"],"names":["exports","Symbol","toStringTag","Object","defineProperty","value","substitute","_func","args","src","toString","old","replacement","length","replace","RegExp","whch","valueOf","pos","i","nextFind","slice","indexOf","_signature","types","optional","TYPE_NUMBER","TYPE_STRING","TYPE_ARRAY","TYPE_BOOLEAN","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","trimLeft","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_CONCATENATE","TOK_RBRACE","TOK_NUMBER","TOK_CURRENT","TOK_GLOBAL","TOK_FIELD","TOK_EXPREF","TOK_PIPE","TOK_OR","TOK_AND","TOK_ADD","TOK_SUBTRACT","TOK_MULTIPLY","TOK_POWER","TOK_DIVIDE","TOK_EQ","TOK_GT","TOK_LT","TOK_GTE","TOK_LTE","TOK_NE","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_DOT","TOK_LBRACE","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","TYPE_NAME_TABLE","globalTokens","isNum","ch","includeSign","isAlphaNum","isArray","obj","prototype","call","a","map","isObject","getTypeName","inputObj","jmespathType","strictDeepEqual","lhs","rhs","first","second","keysSeen","key","hasOwnProperty","key2","isFalse","toNumber","n","Array","temp","parseFloat","Number","isNaN","Error","applyOperator","operator","len","Math","min","result","push","max","arr","scalar","matchType","actual","expectedList","argValue","context","findIndex","type","expected","includes","find","e","subtype","returnArray","indexType","String","str","match","basicTokens","operatorStartToken","skipChars","isIdentifier","stream","isGlobal","prev","global","Lexer","tokenize","start","identifier","token","tokens","this","_current","_consumeGlobal","_consumeUnquotedIdentifier","undefined","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","prevToken","error","name","maxLength","current","JSON","parse","parseInt","startingChar","literalString","_looksLikeJSON","ex","bindingPower","Parser","TreeInterpreter","runtime","Runtime","customFunctions","functionTable","abs","_functionAbs","avg","_functionAvg","ceil","_functionCeil","contains","_functionContains","ends_with","_functionEndsWith","floor","_functionFloor","_functionLength","_functionMap","_functionMax","merge","_functionMerge","variadic","max_by","_functionMaxBy","sum","_functionSum","starts_with","_functionStartsWith","_functionMin","min_by","_functionMinBy","_functionType","keys","_functionKeys","values","_functionValues","sort","_functionSort","sort_by","_functionSortBy","join","_functionJoin","reverse","_functionReverse","to_array","_functionToArray","to_string","_functionToString","to_number","_functionToNumber","not_null","_functionNotNull","and","_functionAnd","or","_functionOr","not","_functionNot","true","false","if","_functionIf","openFormulaFunctions","expression","_loadTokens","index","ast","_lookahead","t","_lookaheadToken","rbp","leftToken","_advance","left","nud","currentToken","led","number","right","node","tok","children","Not","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseMultiselectList","_parseIndexExpression","_projectIfSlice","Expref","_match","_errorToken","tokenName","condition","Concatenate","Dot","_parseDotRHS","Pipe","Or","And","Add","Subtract","Multiply","Divide","Power","Filter","_parseComparator","tokenType","_parseSliceExpression","indexExpr","parts","comparator","lookahead","expressions","keyToken","keyName","pairs","identifierTypes","search","visit","matched","field","collected","child","base","sliceParams","stop","step","filtered","finalResults","original","merged","resolvedArgs","refNode","computeSliceParams","objValues","j","callFunction","arrayLength","computed","stepValueNegative","capSliceRange","actualValue","functionEntry","_validateArgs","signature","pluralized","currentSpec","actualType","limit","lastIndexOf","searchStr","suffix","originalStr","reversedStr","reversedArray","inputArray","arg","mapped","interpreter","_interpreter","exprefNode","elements","forEach","reduce","cur","b","localeCompare","minElement","listToSum","resolveArgs","joinChar","stringify","typeName","sortedArray","normalize","va","vb","requiredType","decorated","exprA","exprB","maxRecord","resolvedArray","keyFunction","createKeyFunction","maxNumber","minRecord","minNumber","Infinity","allowedTypes","x","msg","compile","data","globals","parser","fd","allFields","createFields","parent","childref","item","k","readonly","required","newField","createField","Form","fieldData","dataRoot","window","addEventListener","dataElement","document","getElementById","d","localStorage","getItem","exp","run","setItem","jsonData","input","useFields","checked","root","jsonResult","json","jmespath","jsonFormula","$form","$","r","fetch","then","text","g4","innerHTML"],"sourceRoot":""}