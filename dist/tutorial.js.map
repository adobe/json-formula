{"version":3,"file":"tutorial.js","mappings":"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","sources":["webpack://JSONFormula/webpack/bootstrap","webpack://JSONFormula/webpack/runtime/make namespace object","webpack://JSONFormula/./src/jmespath/dataTypes.js","webpack://JSONFormula/./src/jmespath/tokenDefinitions.js","webpack://JSONFormula/./src/jmespath/matchType.js","webpack://JSONFormula/./src/jmespath/utils.js","webpack://JSONFormula/./src/jmespath/TreeInterpreter.js","webpack://JSONFormula/./src/jmespath/Lexer.js","webpack://JSONFormula/./src/jmespath/Parser.js","webpack://JSONFormula/./src/jmespath/openFormulaFunctions.js","webpack://JSONFormula/./src/jmespath/functions.js","webpack://JSONFormula/./src/jmespath/jmespath.js","webpack://JSONFormula/./src/json-formula.js","webpack://JSONFormula/./src/Form.js","webpack://JSONFormula/./src/jmespath/stringToNumber.js","webpack://JSONFormula/./src/tutorial.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Type constants used to define functions.\nexport default {\n  TYPE_NUMBER: 0,\n  TYPE_ANY: 1,\n  TYPE_STRING: 2,\n  TYPE_ARRAY: 3,\n  TYPE_OBJECT: 4,\n  TYPE_BOOLEAN: 5,\n  TYPE_EXPREF: 6,\n  TYPE_NULL: 7,\n  TYPE_ARRAY_NUMBER: 8,\n  TYPE_ARRAY_STRING: 9,\n  TYPE_CLASS: 10,\n  TYPE_ARRAY_ARRAY: 11,\n};\n","export default {\n  TOK_EOF: 'EOF',\n  TOK_UNQUOTEDIDENTIFIER: 'UnquotedIdentifier',\n  TOK_QUOTEDIDENTIFIER: 'QuotedIdentifier',\n  TOK_RBRACKET: 'Rbracket',\n  TOK_RPAREN: 'Rparen',\n  TOK_COMMA: 'Comma',\n  TOK_COLON: 'Colon',\n  TOK_CONCATENATE: 'Concatenate',\n  TOK_RBRACE: 'Rbrace',\n  TOK_NUMBER: 'Number',\n  TOK_CURRENT: 'Current',\n  TOK_GLOBAL: 'Global',\n  TOK_FIELD: 'Field',\n  TOK_EXPREF: 'Expref',\n  TOK_PIPE: 'Pipe',\n  TOK_OR: 'Or',\n  TOK_AND: 'And',\n  TOK_ADD: 'Add',\n  TOK_SUBTRACT: 'Subtract',\n  TOK_MULTIPLY: 'Multiply',\n  TOK_POWER: 'Power',\n  TOK_UNION: 'Union',\n  TOK_DIVIDE: 'Divide',\n  TOK_EQ: 'EQ',\n  TOK_GT: 'GT',\n  TOK_LT: 'LT',\n  TOK_GTE: 'GTE',\n  TOK_LTE: 'LTE',\n  TOK_NE: 'NE',\n  TOK_FLATTEN: 'Flatten',\n  TOK_STAR: 'Star',\n  TOK_FILTER: 'Filter',\n  TOK_DOT: 'Dot',\n  TOK_NOT: 'Not',\n  TOK_LBRACE: 'Lbrace',\n  TOK_LBRACKET: 'Lbracket',\n  TOK_LPAREN: 'Lparen',\n  TOK_LITERAL: 'Literal',\n};\n","import dataTypes from './dataTypes';\nimport tokenDefinitions from './tokenDefinitions';\n\nconst {\n  TYPE_NUMBER,\n  TYPE_ANY,\n  TYPE_STRING,\n  TYPE_ARRAY,\n  TYPE_OBJECT,\n  TYPE_BOOLEAN,\n  TYPE_EXPREF,\n  TYPE_NULL,\n  TYPE_ARRAY_NUMBER,\n  TYPE_ARRAY_STRING,\n  TYPE_CLASS,\n  TYPE_ARRAY_ARRAY,\n} = dataTypes;\n\nconst {\n  TOK_EXPREF,\n} = tokenDefinitions;\n\nconst TYPE_NAME_TABLE = {\n  [TYPE_NUMBER]: 'number',\n  [TYPE_ANY]: 'any',\n  [TYPE_STRING]: 'string',\n  [TYPE_ARRAY]: 'array',\n  [TYPE_OBJECT]: 'object',\n  [TYPE_BOOLEAN]: 'boolean',\n  [TYPE_EXPREF]: 'expression',\n  [TYPE_NULL]: 'null',\n  [TYPE_ARRAY_NUMBER]: 'Array<number>',\n  [TYPE_ARRAY_STRING]: 'Array<string>',\n  [TYPE_CLASS]: 'class',\n  [TYPE_ARRAY_ARRAY]: 'Array<array>',\n};\n\nexport function getTypeName(inputObj, useValueOf = true) {\n  if (inputObj === null) return TYPE_NULL;\n  let obj = inputObj;\n  if (useValueOf) {\n    // const proto = Object.getPrototypeOf(inputObj);\n    // check for the case where there's a child named 'valueOf' that's not a function\n    // if so, then it's an object...\n    if (typeof inputObj.valueOf === 'function') obj = inputObj.valueOf.call(inputObj);\n    else return TYPE_OBJECT;\n  }\n  switch (Object.prototype.toString.call(obj)) {\n    case '[object String]':\n      return TYPE_STRING;\n    case '[object Number]':\n      return TYPE_NUMBER;\n    case '[object Array]':\n      return TYPE_ARRAY;\n    case '[object Boolean]':\n      return TYPE_BOOLEAN;\n    case '[object Null]':\n      return TYPE_NULL;\n    case '[object Object]':\n      // Check if it's an expref.  If it has, it's been\n      // tagged with a jmespathType attr of 'Expref';\n      if (obj.jmespathType === TOK_EXPREF) {\n        return TYPE_EXPREF;\n      }\n      return TYPE_OBJECT;\n    default:\n      return TYPE_OBJECT;\n  }\n}\n\nexport function getTypeNames(inputObj) {\n  // return the types with and without using valueOf\n  // needed for the cases where we really need an object passed to a function -- not it's value\n  const type1 = getTypeName(inputObj);\n  const type2 = getTypeName(inputObj, false);\n  return [type1, type2];\n}\n\nexport function matchType(actuals, expectedList, argValue, context, toNumber, toString) {\n  const actual = actuals[0];\n  if (expectedList.findIndex(\n    type => type === TYPE_ANY || actual === type,\n  ) !== -1\n  ) return argValue;\n  // Can't coerce Objects to any other type,\n  // and cannot coerce anything to a Class\n  let wrongType = false;\n  if (actual === TYPE_OBJECT || (expectedList.length === 1 && expectedList[0] === TYPE_CLASS)) {\n    wrongType = true;\n  }\n  if (actual === TYPE_ARRAY && (expectedList.length === 1 && expectedList[0] === TYPE_OBJECT)) {\n    wrongType = true;\n  }\n  if (expectedList.includes(TYPE_ARRAY_ARRAY)) {\n    if (actual === TYPE_ARRAY) {\n      argValue.forEach(a => {\n        if (!(a instanceof Array)) wrongType = true;\n      });\n      if (!wrongType) return argValue;\n    }\n    wrongType = true;\n  }\n  if (wrongType) {\n    throw new Error(`TypeError: ${context} expected argument to be type ${TYPE_NAME_TABLE[expectedList[0]]} but received type ${TYPE_NAME_TABLE[actual]} instead.`);\n  }\n  // no exact match in the list of possible types, see if we can coerce an array type\n  let expected = -1;\n  if (actual === TYPE_ARRAY) {\n    if (expectedList.includes(TYPE_ARRAY_STRING) && expectedList.includes(TYPE_ARRAY_NUMBER)) {\n      // choose the array type based on the first element\n      if (argValue.length > 0 && typeof argValue[0] === 'string') expected = TYPE_ARRAY_STRING;\n      else expected = TYPE_ARRAY_NUMBER;\n    }\n  }\n  if (expected === -1 && [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(actual)) {\n    expected = expectedList.find(\n      e => [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(e),\n    );\n  }\n  // no match, just take the first type\n  if (expected === -1) [expected] = expectedList;\n  if (expected === TYPE_ANY) return argValue;\n  if (expected === TYPE_ARRAY_STRING\n      || expected === TYPE_ARRAY_NUMBER\n      || expected === TYPE_ARRAY) {\n    if (expected === TYPE_ARRAY) {\n      if (actual === TYPE_ARRAY_NUMBER || actual === TYPE_ARRAY_STRING) return argValue;\n      return argValue === null ? [] : [argValue];\n    }\n    // The expected type can either just be array,\n    // or it can require a specific subtype (array of numbers).\n    const subtype = expected === TYPE_ARRAY_NUMBER ? TYPE_NUMBER : TYPE_STRING;\n    if (actual === TYPE_ARRAY) {\n      // Otherwise we need to check subtypes.\n      // We're going to modify the array, so take a copy\n      const returnArray = argValue.slice();\n      for (let i = 0; i < returnArray.length; i += 1) {\n        const indexType = getTypeNames(returnArray[i]);\n        returnArray[i] = matchType(\n          indexType, [subtype], returnArray[i], context, toNumber, toString,\n        );\n      }\n      return returnArray;\n    }\n    if ([TYPE_NUMBER, TYPE_STRING, TYPE_NULL, TYPE_BOOLEAN].includes(subtype)) {\n      return [matchType(actuals, [subtype], argValue, context, toNumber, toString)];\n    }\n  } else {\n    if (expected === TYPE_NUMBER) {\n      if ([TYPE_STRING, TYPE_BOOLEAN, TYPE_NULL].includes(actual)) return toNumber(argValue);\n      /* TYPE_ARRAY, TYPE_EXPREF, TYPE_OBJECT, TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING */\n      return 0;\n    }\n    if (expected === TYPE_STRING) {\n      if (actual === TYPE_NULL || actual === TYPE_OBJECT) return '';\n      return toString(argValue);\n    }\n    if (expected === TYPE_BOOLEAN) {\n      return !!argValue;\n    }\n    if (expected === TYPE_OBJECT && actuals[1] === TYPE_OBJECT) {\n      return argValue;\n    }\n  }\n  throw new Error('unhandled argument');\n}\n","export function isArray(obj) {\n  if (obj !== null) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n  return false;\n}\n\nexport function isObject(obj) {\n  if (obj !== null) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  }\n  return false;\n}\n\nexport function getValueOf(a) {\n  if (a === null || a === undefined) return a;\n  if (isArray(a)) {\n    return a.map(i => getValueOf(i));\n  }\n  // if we have a child named 'valueOf' then we're an object,\n  // and just return the object.\n  if (typeof (a.valueOf) !== 'function') return a;\n  return a.valueOf();\n}\n\nexport function strictDeepEqual(lhs, rhs) {\n  const first = getValueOf(lhs);\n  const second = getValueOf(rhs);\n  // Check the scalar case first.\n  if (first === second) {\n    return true;\n  }\n\n  // Check if they are the same type.\n  const firstType = Object.prototype.toString.call(first);\n  if (firstType !== Object.prototype.toString.call(second)) {\n    return false;\n  }\n  // We know that first and second have the same type so we can just check the\n  // first type from now on.\n  if (isArray(first) === true) {\n    // Short circuit if they're not the same length;\n    if (first.length !== second.length) {\n      return false;\n    }\n    for (let i = 0; i < first.length; i += 1) {\n      if (strictDeepEqual(first[i], second[i]) === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (isObject(first) === true) {\n    // An object is equal if it has the same key/value pairs.\n    const keysSeen = {};\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in first) {\n      if (hasOwnProperty.call(first, key)) {\n        if (strictDeepEqual(first[key], second[key]) === false) {\n          return false;\n        }\n        keysSeen[key] = true;\n      }\n    }\n    // Now check that there aren't any keys in second that weren't\n    // in first.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key2 in second) {\n      if (hasOwnProperty.call(second, key2)) {\n        if (keysSeen[key2] !== true) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  return false;\n}\n","import { matchType, getTypeNames } from './matchType';\nimport dataTypes from './dataTypes';\nimport tokenDefinitions from './tokenDefinitions';\nimport {\n  isArray, isObject, strictDeepEqual, getValueOf,\n} from './utils';\n\nconst {\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_EQ,\n  TOK_GT,\n  TOK_LT,\n  TOK_GTE,\n  TOK_LTE,\n  TOK_NE,\n  TOK_FLATTEN,\n} = tokenDefinitions;\n\nconst {\n  TYPE_STRING,\n  TYPE_ARRAY_STRING,\n  TYPE_ARRAY,\n} = dataTypes;\n\nfunction isFalse(value) {\n  // From the spec:\n  // A false value corresponds to the following values:\n  // Empty list\n  // Empty object\n  // Empty string\n  // False boolean\n  // null value\n  // (new) use JS truthy evaluation.  This changes the spec behavior.\n  // Where in the past a zero (0) would be True, it's now false\n\n  // First check the scalar values.\n  if (value === null) return true;\n  // in case it's an object with a valueOf defined\n  const obj = getValueOf(value);\n  if (obj === '' || obj === false || obj === null) {\n    return true;\n  }\n  if (isArray(obj) && obj.length === 0) {\n    // Check for an empty array.\n    return true;\n  }\n  if (isObject(obj)) {\n    // Check for an empty object.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in obj) {\n      // If there are any keys, then\n      // the object is not empty so the object\n      // is not false.\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return !obj;\n}\n\nfunction objValues(obj) {\n  return Object.values(obj);\n}\n\nexport default class TreeInterpreter {\n  constructor(runtime, globals, toNumber, toString, debug, language) {\n    this.runtime = runtime;\n    this.globals = globals;\n    this.toNumber = toNumber;\n    this.toString = toString;\n    this.debug = debug;\n    this.language = language;\n  }\n\n  search(node, value) {\n    return this.visit(node, value);\n  }\n\n  visit(n, v) {\n    const visitFunctions = {\n      Field: (node, value) => {\n        // we used to check isObject(value) here -- but it is possible for an array-based\n        // object to have properties.  So we'll allow the child check on objects and arrays.\n        if (value !== null && (isObject(value) || isArray(value))) {\n          let field = value[node.name];\n          // fields can be objects with overridden methods. e.g. valueOf\n          // so don't resolve to a function...\n          if (typeof field === 'function') field = undefined;\n          if (field === undefined) {\n            try {\n              this.debug.push(`Failed to find: '${node.name}'`);\n              const available = Object.keys(value).map(a => `'${a}'`).toString();\n              if (available.length) this.debug.push(`Available fields: ${available}`);\n            // eslint-disable-next-line no-empty\n            } catch (e) {}\n            return null;\n          }\n          return field;\n        }\n        return null;\n      },\n\n      Subexpression: (node, value) => {\n        let result = this.visit(node.children[0], value);\n        for (let i = 1; i < node.children.length; i += 1) {\n          result = this.visit(node.children[1], result);\n          if (result === null) return null;\n        }\n        return result;\n      },\n\n      IndexExpression: (node, value) => {\n        const left = this.visit(node.children[0], value);\n        return this.visit(node.children[1], left);\n      },\n\n      Index: (node, value) => {\n        if (isArray(value)) {\n          let index = this.toNumber(this.visit(node.value, value));\n          if (index < 0) {\n            index = value.length + index;\n          }\n          const result = value[index];\n          if (result === undefined) {\n            this.debug.push(`Index ${index} out of range`);\n            return null;\n          }\n          return result;\n        }\n        if (isObject(value)) {\n          const key = this.toString(this.visit(node.value, value));\n          const result = value[key];\n          if (result === undefined) {\n            this.debug.push(`Key ${key} does not exist`);\n            return null;\n          }\n          return result;\n        }\n        this.debug.push(`left side of index expression ${value} is not an array or object.`);\n        return null;\n      },\n\n      Slice: (node, value) => {\n        if (!isArray(value)) return null;\n        const sliceParams = node.children.slice(0).map(\n          param => (param != null ? this.toNumber(this.visit(param, value)) : null),\n        );\n        const computed = this.computeSliceParams(value.length, sliceParams);\n        const [start, stop, step] = computed;\n        const result = [];\n        if (step > 0) {\n          for (let i = start; i < stop; i += step) {\n            result.push(value[i]);\n          }\n        } else {\n          for (let i = start; i > stop; i += step) {\n            result.push(value[i]);\n          }\n        }\n        return result;\n      },\n\n      Projection: (node, value) => {\n      // Evaluate left child.\n        const base = this.visit(node.children[0], value);\n        if (!isArray(base)) return null;\n        const collected = [];\n        base.forEach(b => {\n          const current = this.visit(node.children[1], b);\n          if (current !== null) {\n            collected.push(current);\n          }\n        });\n        return collected;\n      },\n\n      ValueProjection: (node, value) => {\n      // Evaluate left child.\n        const projection = this.visit(node.children[0], value);\n        if (!isObject(getValueOf(projection))) return null;\n        const collected = [];\n        const values = objValues(projection);\n        values.forEach(val => {\n          const current = this.visit(node.children[1], val);\n          if (current !== null) collected.push(current);\n        });\n        return collected;\n      },\n\n      FilterProjection: (node, value) => {\n        const base = this.visit(node.children[0], value);\n        if (!isArray(base)) return null;\n        const filtered = base.filter(b => {\n          const matched = this.visit(node.children[2], b);\n          return !isFalse(matched);\n        });\n\n        const finalResults = [];\n        filtered.forEach(f => {\n          const current = this.visit(node.children[1], f);\n          if (current !== null) finalResults.push(current);\n        });\n        return finalResults;\n      },\n\n      Comparator: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n\n        if (node.name === TOK_EQ) return strictDeepEqual(first, second);\n        if (node.name === TOK_NE) return !strictDeepEqual(first, second);\n        if (node.name === TOK_GT) return first > second;\n        if (node.name === TOK_GTE) return first >= second;\n        if (node.name === TOK_LT) return first < second;\n        if (node.name === TOK_LTE) return first <= second;\n        throw new Error(`Unknown comparator: ${node.name}`);\n      },\n\n      [TOK_FLATTEN]: (node, value) => {\n        const original = this.visit(node.children[0], value);\n        if (!isArray(original)) return null;\n        const merged = [];\n        original.forEach(current => {\n          if (isArray(current)) {\n            merged.push(...current);\n          } else {\n            merged.push(current);\n          }\n        });\n        return merged;\n      },\n\n      Identity: (_node, value) => value,\n\n      MultiSelectList: (node, value) => {\n        if (value === null) return null;\n        return node.children.map(child => this.visit(child, value));\n      },\n\n      MultiSelectHash: (node, value) => {\n        if (value === null) return null;\n        const collected = {};\n        node.children.forEach(child => {\n          collected[child.name] = this.visit(child.value, value);\n        });\n        return collected;\n      },\n\n      OrExpression: (node, value) => {\n        let matched = this.visit(node.children[0], value);\n        if (isFalse(matched)) matched = this.visit(node.children[1], value);\n        return matched;\n      },\n\n      AndExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n\n        if (isFalse(first) === true) return first;\n        return this.visit(node.children[1], value);\n      },\n\n      AddExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        return this.applyOperator(first, second, '+');\n      },\n\n      ConcatenateExpression: (node, value) => {\n        let first = this.visit(node.children[0], value);\n        let second = this.visit(node.children[1], value);\n        first = matchType(getTypeNames(first), [TYPE_STRING, TYPE_ARRAY_STRING], first, 'concatenate', this.toNumber, this.toString);\n        second = matchType(getTypeNames(second), [TYPE_STRING, TYPE_ARRAY_STRING], second, 'concatenate', this.toNumber, this.toString);\n        return this.applyOperator(first, second, '&');\n      },\n\n      UnionExpression: (node, value) => {\n        let first = this.visit(node.children[0], value);\n        let second = this.visit(node.children[1], value);\n        first = matchType(getTypeNames(first), [TYPE_ARRAY], first, 'union', this.toNumber, this.toString);\n        second = matchType(getTypeNames(second), [TYPE_ARRAY], second, 'union', this.toNumber, this.toString);\n        return first.concat(second);\n      },\n\n      SubtractExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        return this.applyOperator(first, second, '-');\n      },\n\n      MultiplyExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        return this.applyOperator(first, second, '*');\n      },\n\n      DivideExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        return this.applyOperator(first, second, '/');\n      },\n\n      PowerExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        return this.applyOperator(first, second, '^');\n      },\n\n      NotExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        return isFalse(first);\n      },\n\n      Literal: node => node.value,\n\n      Number: node => node.value,\n\n      [TOK_PIPE]: (node, value) => {\n        const left = this.visit(node.children[0], value);\n        return this.visit(node.children[1], left);\n      },\n\n      [TOK_CURRENT]: (_node, value) => value,\n\n      [TOK_GLOBAL]: node => {\n        const result = this.globals[node.name];\n        return result === undefined ? null : result;\n      },\n\n      Function: (node, value) => {\n      // Special case for if()\n      // we need to make sure the results are called only after the condition is evaluated\n      // Otherwise we end up with both results invoked -- which could include side effects\n      // For \"if\", the last parameter to callFunction is false (bResolved) to indicate there's\n      // no point in validating the argument type.\n        if (node.name === 'if') return this.runtime.callFunction(node.name, node.children, value, this, false);\n        const resolvedArgs = node.children.map(child => this.visit(child, value));\n        return this.runtime.callFunction(node.name, resolvedArgs, value, this);\n      },\n\n      ExpressionReference: node => {\n        const [refNode] = node.children;\n        // Tag the node with a specific attribute so the type\n        // checker verify the type.\n        refNode.jmespathType = TOK_EXPREF;\n        return refNode;\n      },\n    };\n    const fn = n && visitFunctions[n.type];\n    if (!fn) throw new Error(`Unknown/missing node type ${(n && n.type) || ''}`);\n    return fn(n, v);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  computeSliceParams(arrayLength, sliceParams) {\n    function capSliceRange(arrayLen, actual, stp) {\n      let actualValue = actual;\n      if (actualValue < 0) {\n        actualValue += arrayLen;\n        if (actualValue < 0) {\n          actualValue = stp < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLen) {\n        actualValue = stp < 0 ? arrayLen - 1 : arrayLen;\n      }\n      return actualValue;\n    }\n\n    let [start, stop, step] = sliceParams;\n    if (step === null) {\n      step = 1;\n    } else if (step === 0) {\n      const error = new Error('Invalid slice, step cannot be 0');\n      error.name = 'RuntimeError';\n      throw error;\n    }\n    const stepValueNegative = step < 0;\n\n    if (start === null) {\n      start = stepValueNegative ? arrayLength - 1 : 0;\n    } else {\n      start = capSliceRange(arrayLength, start, step);\n    }\n\n    if (stop === null) {\n      stop = stepValueNegative ? -1 : arrayLength;\n    } else {\n      stop = capSliceRange(arrayLength, stop, step);\n    }\n    return [start, stop, step];\n  }\n\n  applyOperator(first, second, operator) {\n    if (isArray(first) && isArray(second)) {\n      // balance the size of the arrays\n      const shorter = first.length < second.length ? first : second;\n      const diff = Math.abs(first.length - second.length);\n      shorter.length += diff;\n      shorter.fill(null, shorter.length - diff);\n      const result = [];\n      for (let i = 0; i < first.length; i += 1) {\n        result.push(this.applyOperator(first[i], second[i], operator));\n      }\n      return result;\n    }\n\n    if (isArray(first)) return first.map(a => this.applyOperator(a, second, operator));\n    if (isArray(second)) return second.map(a => this.applyOperator(first, a, operator));\n\n    if (operator === '*') return this.toNumber(first) * this.toNumber(second);\n    if (operator === '&') return first + second;\n    if (operator === '+') {\n      return this.toNumber(first) + this.toNumber(second);\n    }\n    if (operator === '-') return this.toNumber(first) - this.toNumber(second);\n    if (operator === '/') {\n      const result = first / second;\n      return Number.isFinite(result) ? result : null;\n    }\n    if (operator === '^') {\n      return first ** second;\n    }\n    throw new Error(`Unknown operator: ${operator}`);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport tokenDefinitions from './tokenDefinitions';\n\nconst {\n  TOK_UNQUOTEDIDENTIFIER,\n  TOK_QUOTEDIDENTIFIER,\n  TOK_RBRACKET,\n  TOK_RPAREN,\n  TOK_COMMA,\n  TOK_COLON,\n  TOK_CONCATENATE,\n  TOK_RBRACE,\n  TOK_NUMBER,\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_OR,\n  TOK_AND,\n  TOK_ADD,\n  TOK_SUBTRACT,\n  TOK_MULTIPLY,\n  TOK_POWER,\n  TOK_DIVIDE,\n  TOK_UNION,\n  TOK_EQ,\n  TOK_GT,\n  TOK_LT,\n  TOK_GTE,\n  TOK_LTE,\n  TOK_NE,\n  TOK_FLATTEN,\n  TOK_STAR,\n  TOK_FILTER,\n  TOK_DOT,\n  TOK_NOT,\n  TOK_LBRACE,\n  TOK_LBRACKET,\n  TOK_LPAREN,\n  TOK_LITERAL,\n} = tokenDefinitions;\n\n// The \"&\", \"[\", \"<\", \">\" tokens\n// are not in basicToken because\n// there are two token variants\n// (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n// below.\n\nconst basicTokens = {\n  '.': TOK_DOT,\n  // \"*\": TOK_STAR,\n  ',': TOK_COMMA,\n  ':': TOK_COLON,\n  '{': TOK_LBRACE,\n  '}': TOK_RBRACE,\n  ']': TOK_RBRACKET,\n  '(': TOK_LPAREN,\n  ')': TOK_RPAREN,\n  '@': TOK_CURRENT,\n};\n\nconst globalStartToken = '$';\nconst operatorStartToken = {\n  '<': true,\n  '>': true,\n  '=': true,\n  '!': true,\n};\n\nconst skipChars = {\n  ' ': true,\n  '\\t': true,\n  '\\n': true,\n};\n\nfunction isNum(ch, includeSign) {\n  return (ch >= '0' && ch <= '9')\n             || (includeSign && ch === '-')\n             || (ch === '.');\n}\n\nfunction isAlphaNum(ch) {\n  return (ch >= 'a' && ch <= 'z')\n           || (ch >= 'A' && ch <= 'Z')\n           || (ch >= '0' && ch <= '9')\n           || ch === '_';\n}\n\nfunction isIdentifier(stream, pos) {\n  const ch = stream[pos];\n  // $ is special -- it's allowed to be part of an identifier if it's the first character\n  if (ch === '$') {\n    return stream.length > pos && isAlphaNum(stream[pos + 1]);\n  }\n  // return whether character 'isAlpha'\n  return (ch >= 'a' && ch <= 'z')\n          || (ch >= 'A' && ch <= 'Z')\n          || ch === '_';\n}\n\nexport default class Lexer {\n  constructor(allowedGlobalNames = [], debug = []) {\n    this._allowedGlobalNames = allowedGlobalNames;\n    this.debug = debug;\n  }\n\n  tokenize(stream) {\n    const tokens = [];\n    this._current = 0;\n    let start;\n    let identifier;\n    let token;\n    while (this._current < stream.length) {\n      const prev = tokens.length ? tokens.slice(-1)[0].type : null;\n\n      if (this._isGlobal(prev, stream, this._current)) {\n        tokens.push(this._consumeGlobal(stream));\n      } else if (isIdentifier(stream, this._current)) {\n        start = this._current;\n        identifier = this._consumeUnquotedIdentifier(stream);\n        tokens.push({\n          type: TOK_UNQUOTEDIDENTIFIER,\n          value: identifier,\n          start,\n        });\n      } else if (basicTokens[stream[this._current]] !== undefined) {\n        tokens.push({\n          type: basicTokens[stream[this._current]],\n          value: stream[this._current],\n          start: this._current,\n        });\n        this._current += 1;\n      } else if ((stream[this._current] === '-' && ![TOK_CURRENT, TOK_NUMBER, TOK_RPAREN, TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_RBRACKET].includes(prev)) || isNum(stream[this._current], false)) {\n        token = this._consumeNumber(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '[') {\n        // No need to increment this._current.  This happens\n        // in _consumeLBracket\n        token = this._consumeLBracket(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '\"') {\n        start = this._current;\n        identifier = this._consumeQuotedIdentifier(stream);\n        tokens.push({\n          type: TOK_QUOTEDIDENTIFIER,\n          value: identifier,\n          start,\n        });\n      } else if (stream[this._current] === \"'\") {\n        start = this._current;\n        identifier = this._consumeRawStringLiteral(stream);\n        tokens.push({\n          type: TOK_LITERAL,\n          value: identifier,\n          start,\n        });\n      } else if (stream[this._current] === '`') {\n        start = this._current;\n        const literal = this._consumeLiteral(stream);\n        tokens.push({\n          type: TOK_LITERAL,\n          value: literal,\n          start,\n        });\n      } else if (operatorStartToken[stream[this._current]] !== undefined) {\n        tokens.push(this._consumeOperator(stream));\n      } else if (skipChars[stream[this._current]] !== undefined) {\n        // Ignore whitespace.\n        this._current += 1;\n      } else if (stream[this._current] === '&') {\n        start = this._current;\n        this._current += 1;\n        if (stream[this._current] === '&') {\n          this._current += 1;\n          tokens.push({ type: TOK_AND, value: '&&', start });\n        } else if (prev === TOK_COMMA || prev === TOK_LPAREN) {\n          // based on previous token we'll know if this & is a JMESPath expression-type\n          // or if it's a concatenation operator\n          // if we're a function arg then it's an expression-type\n          tokens.push({ type: TOK_EXPREF, value: '&', start });\n        } else {\n          tokens.push({ type: TOK_CONCATENATE, value: '&', start });\n        }\n      } else if (stream[this._current] === '~') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_UNION, value: '~', start });\n      } else if (stream[this._current] === '+') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_ADD, value: '+', start });\n      } else if (stream[this._current] === '-') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_SUBTRACT, value: '-', start });\n      } else if (stream[this._current] === '*') {\n        start = this._current;\n        this._current += 1;\n        // based on previous token we'll know if this asterix is a star -- not a multiply\n        // might be better to list the prev tokens that are valid for multiply?\n        const prevToken = tokens.length && tokens.slice(-1)[0].type;\n        if (tokens.length === 0 || [\n          TOK_LBRACKET,\n          TOK_DOT,\n          TOK_PIPE,\n          TOK_AND,\n          TOK_OR,\n          TOK_COMMA,\n          TOK_COLON,\n        ].includes(prevToken)) {\n          tokens.push({ type: TOK_STAR, value: '*', start });\n        } else {\n          tokens.push({ type: TOK_MULTIPLY, value: '*', start });\n        }\n      } else if (stream[this._current] === '/') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_DIVIDE, value: '/', start });\n      } else if (stream[this._current] === '^') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_POWER, value: '^', start });\n      } else if (stream[this._current] === '|') {\n        start = this._current;\n        this._current += 1;\n        if (stream[this._current] === '|') {\n          this._current += 1;\n          tokens.push({ type: TOK_OR, value: '||', start });\n        } else {\n          tokens.push({ type: TOK_PIPE, value: '|', start });\n        }\n      } else {\n        const error = new Error(`Unknown character:${stream[this._current]}`);\n        error.name = 'LexerError';\n        throw error;\n      }\n    }\n    return tokens;\n  }\n\n  _consumeUnquotedIdentifier(stream) {\n    const start = this._current;\n    this._current += 1;\n    while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n      this._current += 1;\n    }\n    return stream.slice(start, this._current);\n  }\n\n  _consumeQuotedIdentifier(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    let foundNonAlpha = !isIdentifier(stream, start + 1);\n    while (stream[this._current] !== '\"' && this._current < maxLength) {\n      // You can escape a double quote and you can escape an escape.\n      let current = this._current;\n      if (!isAlphaNum(stream[current])) foundNonAlpha = true;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                             || stream[current + 1] === '\"')) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const val = stream.slice(start, this._current);\n    // Check for unnecessary double quotes.\n    // json-formula uses double quotes to escape characters that don't belong in names names.\n    // e.g. \"purchase-order\".address\n    // If we find a double-quoted entity with spaces or all legal characters, issue a warning\n    try {\n      if (!foundNonAlpha || val.includes(' ')) {\n        this.debug.push(`Suspicious quotes: ${val}`);\n        this.debug.push(`Did you intend a literal? '${val.replace(/\"/g, '')}'?`);\n      }\n    // eslint-disable-next-line no-empty\n    } catch (e) {}\n    return JSON.parse(val);\n  }\n\n  _consumeRawStringLiteral(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (stream[this._current] !== \"'\" && this._current < maxLength) {\n      // You can escape a single quote and you can escape an escape.\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                             || stream[current + 1] === \"'\")) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const literal = stream.slice(start + 1, this._current - 1);\n    return literal.replaceAll(\"\\\\'\", \"'\");\n  }\n\n  _consumeNumber(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (isNum(stream[this._current], false) && this._current < maxLength) {\n      this._current += 1;\n    }\n    const n = stream.slice(start, this._current);\n    let value;\n    if (n.includes('.')) {\n      value = parseFloat(n);\n    } else {\n      value = parseInt(n, 10);\n    }\n    return { type: TOK_NUMBER, value, start };\n  }\n\n  _consumeLBracket(stream) {\n    const start = this._current;\n    this._current += 1;\n    if (stream[this._current] === '?') {\n      this._current += 1;\n      return { type: TOK_FILTER, value: '[?', start };\n    }\n    if (stream[this._current] === ']') {\n      this._current += 1;\n      return { type: TOK_FLATTEN, value: '[]', start };\n    }\n    return { type: TOK_LBRACKET, value: '[', start };\n  }\n\n  _isGlobal(prev, stream, pos) {\n    // global tokens occur only at the start of an expression\n    if (prev !== null && prev === TOK_DOT) return false;\n    const ch = stream[pos];\n    if (ch !== globalStartToken) return false;\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    let i = pos + 1;\n    while (i < stream.length && isAlphaNum(stream[i])) i += 1;\n    const global = stream.slice(pos, i);\n    return this._allowedGlobalNames.includes(global);\n  }\n\n  _consumeGlobal(stream) {\n    const start = this._current;\n    this._current += 1;\n    while (this._current < stream.length && isAlphaNum(stream[this._current])) this._current += 1;\n    const global = stream.slice(start, this._current);\n\n    return { type: TOK_GLOBAL, name: global, start };\n  }\n\n  _consumeOperator(stream) {\n    const start = this._current;\n    const startingChar = stream[start];\n    this._current += 1;\n    if (startingChar === '!') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_NE, value: '!=', start };\n      }\n      return { type: TOK_NOT, value: '!', start };\n    }\n    if (startingChar === '<') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_LTE, value: '<=', start };\n      }\n      return { type: TOK_LT, value: '<', start };\n    }\n    if (startingChar === '>') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_GTE, value: '>=', start };\n      }\n      return { type: TOK_GT, value: '>', start };\n    }\n    // startingChar is '='\n    if (stream[this._current] === '=') {\n      this._current += 1;\n      return { type: TOK_EQ, value: '==', start };\n    }\n    return { type: TOK_EQ, value: '=', start };\n  }\n\n  _consumeLiteral(stream) {\n    function _looksLikeJSON(str) {\n      if (str === '') return false;\n      if ('[{\"'.includes(str[0])) return true;\n      if (['true', 'false', 'null'].includes(str)) return true;\n\n      if ('-0123456789'.includes(str[0])) {\n        try {\n          JSON.parse(str);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n\n    this._current += 1;\n    const start = this._current;\n    const maxLength = stream.length;\n    let literal;\n    let inQuotes = false;\n    while ((inQuotes || stream[this._current] !== '`') && this._current < maxLength) {\n      let current = this._current;\n      // bypass escaped double quotes when we're inside quotes\n      if (inQuotes && stream[current] === '\\\\' && stream[current + 1] === '\"') current += 2;\n      else {\n        if (stream[current] === '\"') inQuotes = !inQuotes;\n        if (inQuotes && stream[current + 1] === '`') current += 2;\n        else if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                              || stream[current + 1] === '`')) {\n        // You can escape a literal char or you can escape the escape.\n          current += 2;\n        } else {\n          current += 1;\n        }\n      }\n      this._current = current;\n    }\n    let literalString = stream.slice(start, this._current).trimStart();\n    literalString = literalString.replaceAll('\\\\`', '`');\n    if (_looksLikeJSON(literalString)) {\n      literal = JSON.parse(literalString);\n    } else {\n      // Try to JSON parse it as \"<literal>\"\n      literal = JSON.parse(`\"${literalString}\"`);\n    }\n    // +1 gets us to the ending \"`\", +1 to move on to the next char.\n    this._current += 1;\n    return literal;\n  }\n}\n","import Lexer from './Lexer';\nimport tokenDefinitions from './tokenDefinitions';\n\n/* eslint-disable no-underscore-dangle */\nconst {\n  TOK_LITERAL,\n  TOK_COLON,\n  TOK_EOF,\n  TOK_UNQUOTEDIDENTIFIER,\n  TOK_QUOTEDIDENTIFIER,\n  TOK_RBRACKET,\n  TOK_RPAREN,\n  TOK_COMMA,\n  TOK_CONCATENATE,\n  TOK_RBRACE,\n  TOK_NUMBER,\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_FIELD,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_OR,\n  TOK_AND,\n  TOK_ADD,\n  TOK_SUBTRACT,\n  TOK_MULTIPLY,\n  TOK_POWER,\n  TOK_DIVIDE,\n  TOK_UNION,\n  TOK_EQ,\n  TOK_GT,\n  TOK_LT,\n  TOK_GTE,\n  TOK_LTE,\n  TOK_NE,\n  TOK_FLATTEN,\n  TOK_STAR,\n  TOK_FILTER,\n  TOK_DOT,\n  TOK_NOT,\n  TOK_LBRACE,\n  TOK_LBRACKET,\n  TOK_LPAREN,\n} = tokenDefinitions;\n\nconst bindingPower = {\n  [TOK_EOF]: 0,\n  [TOK_UNQUOTEDIDENTIFIER]: 0,\n  [TOK_QUOTEDIDENTIFIER]: 0,\n  [TOK_RBRACKET]: 0,\n  [TOK_RPAREN]: 0,\n  [TOK_COMMA]: 0,\n  [TOK_RBRACE]: 0,\n  [TOK_NUMBER]: 0,\n  [TOK_CURRENT]: 0,\n  [TOK_GLOBAL]: 0,\n  [TOK_FIELD]: 0,\n  [TOK_EXPREF]: 0,\n  [TOK_PIPE]: 1,\n  [TOK_OR]: 2,\n  [TOK_AND]: 3,\n  [TOK_ADD]: 6,\n  [TOK_SUBTRACT]: 6,\n  [TOK_CONCATENATE]: 7,\n  [TOK_MULTIPLY]: 7,\n  [TOK_DIVIDE]: 7,\n  [TOK_POWER]: 7,\n  [TOK_UNION]: 7,\n  [TOK_EQ]: 5,\n  [TOK_GT]: 5,\n  [TOK_LT]: 5,\n  [TOK_GTE]: 5,\n  [TOK_LTE]: 5,\n  [TOK_NE]: 5,\n  [TOK_FLATTEN]: 9,\n  [TOK_STAR]: 20,\n  [TOK_FILTER]: 21,\n  [TOK_DOT]: 40,\n  [TOK_NOT]: 45,\n  [TOK_LBRACE]: 50,\n  [TOK_LBRACKET]: 55,\n  [TOK_LPAREN]: 60,\n};\n\nexport default class Parser {\n  constructor(allowedGlobalNames = []) {\n    this._allowedGlobalNames = allowedGlobalNames;\n  }\n\n  parse(expression, debug) {\n    this._loadTokens(expression, debug);\n    this.index = 0;\n    const ast = this.expression(0);\n    if (this._lookahead(0) !== TOK_EOF) {\n      const t = this._lookaheadToken(0);\n      const error = new Error(\n        `Unexpected token type: ${t.type}, value: ${t.value}`,\n      );\n      error.name = 'ParserError';\n      throw error;\n    }\n    return ast;\n  }\n\n  _loadTokens(expression, debug) {\n    const lexer = new Lexer(this._allowedGlobalNames, debug);\n    const tokens = lexer.tokenize(expression);\n    tokens.push({ type: TOK_EOF, value: '', start: expression.length });\n    this.tokens = tokens;\n  }\n\n  expression(rbp) {\n    const leftToken = this._lookaheadToken(0);\n    this._advance();\n    let left = this.nud(leftToken);\n    let currentToken = this._lookahead(0);\n    while (rbp < bindingPower[currentToken]) {\n      this._advance();\n      left = this.led(currentToken, left);\n      currentToken = this._lookahead(0);\n    }\n    return left;\n  }\n\n  _lookahead(number) {\n    return this.tokens[this.index + number].type;\n  }\n\n  _lookaheadToken(number) {\n    return this.tokens[this.index + number];\n  }\n\n  _advance() {\n    this.index += 1;\n  }\n\n  _getIndex() {\n    return this.index;\n  }\n\n  _setIndex(index) {\n    this.index = index;\n  }\n\n  // eslint-disable-next-line consistent-return\n  nud(token) {\n    let left;\n    let right;\n    let expression;\n    let node;\n    let args;\n    switch (token.type) {\n      case TOK_LITERAL:\n        return { type: 'Literal', value: token.value };\n      case TOK_NUMBER:\n        return { type: 'Number', value: token.value };\n      case TOK_UNQUOTEDIDENTIFIER:\n        return { type: 'Field', name: token.value };\n      case TOK_QUOTEDIDENTIFIER:\n        node = { type: 'Field', name: token.value };\n        if (this._lookahead(0) === TOK_LPAREN) {\n          throw new Error('Quoted identifier not allowed for function names.');\n        }\n        return node;\n      case TOK_NOT:\n        right = this.expression(bindingPower.Not);\n        return { type: 'NotExpression', children: [right] };\n      case TOK_STAR:\n        left = { type: 'Identity' };\n        if (this._lookahead(0) === TOK_RBRACKET) {\n          // This can happen in a multiselect,\n          // [a, b, *]\n          right = { type: 'Identity' };\n        } else {\n          right = this._parseProjectionRHS(bindingPower.Star);\n        }\n        return { type: 'ValueProjection', children: [left, right] };\n      case TOK_FILTER:\n        return this.led(token.type, { type: 'Identity' });\n      case TOK_LBRACE:\n        return this._parseMultiselectHash();\n      case TOK_FLATTEN:\n        left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };\n        right = this._parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', children: [left, right] };\n      case TOK_LBRACKET:\n        if (this._lookahead(0) === TOK_STAR\n            && this._lookahead(1) === TOK_RBRACKET) {\n          this._advance();\n          this._advance();\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return {\n            type: 'Projection',\n            children: [{ type: 'Identity' }, right],\n          };\n        }\n        return this._parseUnchainedIndexExpression();\n      case TOK_CURRENT:\n        return { type: TOK_CURRENT };\n      case TOK_GLOBAL:\n        return { type: TOK_GLOBAL, name: token.name };\n      case TOK_FIELD:\n        return { type: TOK_FIELD };\n      case TOK_EXPREF:\n        expression = this.expression(bindingPower.Expref);\n        return { type: 'ExpressionReference', children: [expression] };\n      case TOK_LPAREN:\n        args = [];\n        while (this._lookahead(0) !== TOK_RPAREN) {\n          expression = this.expression(0);\n          args.push(expression);\n        }\n        this._match(TOK_RPAREN);\n        return args[0];\n      default:\n        this._errorToken(token);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  led(tokenName, left) {\n    let condition;\n    let right;\n    let name;\n    let args;\n    let expression;\n    let node;\n    let rbp;\n    let leftNode;\n    let rightNode;\n    switch (tokenName) {\n      case TOK_CONCATENATE:\n        right = this.expression(bindingPower.Concatenate);\n        return { type: 'ConcatenateExpression', children: [left, right] };\n      case TOK_DOT:\n        rbp = bindingPower.Dot;\n        if (this._lookahead(0) !== TOK_STAR) {\n          right = this._parseDotRHS(rbp);\n          return { type: 'Subexpression', children: [left, right] };\n        }\n        // Creating a projection.\n        this._advance();\n        right = this._parseProjectionRHS(rbp);\n        return { type: 'ValueProjection', children: [left, right] };\n      case TOK_PIPE:\n        right = this.expression(bindingPower.Pipe);\n        return { type: TOK_PIPE, children: [left, right] };\n      case TOK_OR:\n        right = this.expression(bindingPower.Or);\n        return { type: 'OrExpression', children: [left, right] };\n      case TOK_AND:\n        right = this.expression(bindingPower.And);\n        return { type: 'AndExpression', children: [left, right] };\n      case TOK_ADD:\n        right = this.expression(bindingPower.Add);\n        return { type: 'AddExpression', children: [left, right] };\n      case TOK_SUBTRACT:\n        right = this.expression(bindingPower.Subtract);\n        return { type: 'SubtractExpression', children: [left, right] };\n      case TOK_MULTIPLY:\n        right = this.expression(bindingPower.Multiply);\n        return { type: 'MultiplyExpression', children: [left, right] };\n      case TOK_DIVIDE:\n        right = this.expression(bindingPower.Divide);\n        return { type: 'DivideExpression', children: [left, right] };\n      case TOK_POWER:\n        right = this.expression(bindingPower.Power);\n        return { type: 'PowerExpression', children: [left, right] };\n      case TOK_UNION:\n        right = this.expression(bindingPower.Power);\n        return { type: 'UnionExpression', children: [left, right] };\n      case TOK_LPAREN:\n        name = left.name;\n        args = [];\n        while (this._lookahead(0) !== TOK_RPAREN) {\n          expression = this.expression(0);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          }\n          args.push(expression);\n        }\n        this._match(TOK_RPAREN);\n        node = { type: 'Function', name, children: args };\n        return node;\n      case TOK_FILTER:\n        condition = this.expression(0);\n        this._match(TOK_RBRACKET);\n        if (this._lookahead(0) === TOK_FLATTEN) {\n          right = { type: 'Identity' };\n        } else {\n          right = this._parseProjectionRHS(bindingPower.Filter);\n        }\n        return { type: 'FilterProjection', children: [left, right, condition] };\n      case TOK_FLATTEN:\n        leftNode = { type: TOK_FLATTEN, children: [left] };\n        rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', children: [leftNode, rightNode] };\n      case TOK_EQ:\n      case TOK_NE:\n      case TOK_GT:\n      case TOK_GTE:\n      case TOK_LT:\n      case TOK_LTE:\n        return this._parseComparator(left, tokenName);\n      case TOK_LBRACKET:\n        if (this._lookahead(0) === TOK_STAR\n            && this._lookahead(1) === TOK_RBRACKET) {\n          this._advance();\n          this._advance();\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return { type: 'Projection', children: [left, right] };\n        }\n        right = this._parseChainedIndexExpression();\n        return this._projectIfSlice(left, right);\n      default:\n        this._errorToken(this._lookaheadToken(0));\n    }\n  }\n\n  _match(tokenType) {\n    if (this._lookahead(0) === tokenType) {\n      this._advance();\n    } else {\n      const t = this._lookaheadToken(0);\n      const error = new Error(`Expected ${tokenType}, got: ${t.type}`);\n      error.name = 'ParserError';\n      throw error;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _errorToken(token) {\n    const error = new Error(`Invalid token (${\n      token.type}): \"${\n      token.value}\"`);\n    error.name = 'ParserError';\n    throw error;\n  }\n\n  _parseChainedIndexExpression() {\n    const oldIndex = this._getIndex();\n    if (this._lookahead(0) === TOK_COLON) {\n      return this._parseSliceExpression();\n    }\n    // look ahead of the first expression to determine the type\n    const first = this.expression(0);\n    const token = this._lookahead(0);\n    if (token === TOK_COLON) {\n      // now that we know the type revert back to the old position and parse\n      this._setIndex(oldIndex);\n      return this._parseSliceExpression();\n    }\n    this._match(TOK_RBRACKET);\n    return {\n      type: 'Index',\n      value: first,\n    };\n  }\n\n  _parseUnchainedIndexExpression() {\n    const oldIndex = this._getIndex();\n    const firstToken = this._lookahead(0);\n    if (firstToken === TOK_COLON) {\n      const right = this._parseSliceExpression();\n      return this._projectIfSlice({ type: 'Identity' }, right);\n    }\n    const first = this.expression(0);\n    const currentToken = this._lookahead(0);\n    if (currentToken === TOK_COMMA) {\n      this._setIndex(oldIndex);\n      return this._parseMultiselectList();\n    }\n    if (currentToken === TOK_COLON) {\n      this._setIndex(oldIndex);\n      const right = this._parseSliceExpression();\n      return this._projectIfSlice({ type: 'Identity' }, right);\n    }\n    if (firstToken === TOK_NUMBER) {\n      this._match(TOK_RBRACKET);\n      return {\n        type: 'Index',\n        value: first,\n      };\n    }\n    this._setIndex(oldIndex);\n    return this._parseMultiselectList();\n  }\n\n  _projectIfSlice(left, right) {\n    const indexExpr = { type: 'IndexExpression', children: [left, right] };\n    if (right.type === 'Slice') {\n      return {\n        type: 'Projection',\n        children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],\n      };\n    }\n    return indexExpr;\n  }\n\n  _parseSliceExpression() {\n    // [start:end:step] where each part is optional, as well as the last\n    // colon.\n    const parts = [null, null, null];\n    let index = 0;\n    let currentToken = this._lookahead(0);\n    while (currentToken !== TOK_RBRACKET && index < 3) {\n      if (currentToken === TOK_COLON && index < 2) { // there can't be more than 2 colons\n        index += 1;\n        this._advance();\n      } else {\n        parts[index] = this.expression(0);\n        // check next token to be either colon or rbracket\n        const t = this._lookahead(0);\n        if (t !== TOK_COLON && t !== TOK_RBRACKET) {\n          const error = new Error(`Syntax error, unexpected token: ${\n            t.value}(${t.type})`);\n          error.name = 'Parsererror';\n          throw error;\n        }\n      }\n      currentToken = this._lookahead(0);\n    }\n    this._match(TOK_RBRACKET);\n    return {\n      type: 'Slice',\n      children: parts,\n    };\n  }\n\n  _parseComparator(left, comparator) {\n    const right = this.expression(bindingPower[comparator]);\n    return { type: 'Comparator', name: comparator, children: [left, right] };\n  }\n\n  // eslint-disable-next-line consistent-return\n  _parseDotRHS(rbp) {\n    const lookahead = this._lookahead(0);\n    const exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n    if (exprTokens.indexOf(lookahead) >= 0) {\n      return this.expression(rbp);\n    }\n    if (lookahead === TOK_LBRACKET) {\n      this._match(TOK_LBRACKET);\n      return this._parseMultiselectList();\n    }\n    if (lookahead === TOK_LBRACE) {\n      this._match(TOK_LBRACE);\n      return this._parseMultiselectHash();\n    }\n  }\n\n  _parseProjectionRHS(rbp) {\n    let right;\n    if (bindingPower[this._lookahead(0)] < 10) {\n      right = { type: 'Identity' };\n    } else if (this._lookahead(0) === TOK_LBRACKET) {\n      right = this.expression(rbp);\n    } else if (this._lookahead(0) === TOK_FILTER) {\n      right = this.expression(rbp);\n    } else if (this._lookahead(0) === TOK_DOT) {\n      this._match(TOK_DOT);\n      right = this._parseDotRHS(rbp);\n    } else {\n      const t = this._lookaheadToken(0);\n      const error = new Error(`Sytanx error, unexpected token: ${\n        t.value}(${t.type})`);\n      error.name = 'ParserError';\n      throw error;\n    }\n    return right;\n  }\n\n  _parseMultiselectList() {\n    const expressions = [];\n    while (this._lookahead(0) !== TOK_RBRACKET) {\n      const expression = this.expression(0);\n      expressions.push(expression);\n      if (this._lookahead(0) === TOK_COMMA) {\n        this._match(TOK_COMMA);\n        if (this._lookahead(0) === TOK_RBRACKET) {\n          throw new Error('Unexpected token Rbracket');\n        }\n      }\n    }\n    this._match(TOK_RBRACKET);\n    return { type: 'MultiSelectList', children: expressions };\n  }\n\n  _parseMultiselectHash() {\n    const pairs = [];\n    const identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n    let keyToken; let keyName; let value; let\n      node;\n    if (this._lookahead(0) === TOK_RBRACE) {\n      this._advance();\n      return { type: 'MultiSelectHash', children: [] };\n    }\n    for (;;) {\n      keyToken = this._lookaheadToken(0);\n      if (identifierTypes.indexOf(keyToken.type) < 0) {\n        throw new Error(`Expecting an identifier token, got: ${\n          keyToken.type}`);\n      }\n      keyName = keyToken.value;\n      this._advance();\n      this._match(TOK_COLON);\n      value = this.expression(0);\n      node = { type: 'KeyValuePair', name: keyName, value };\n      pairs.push(node);\n      if (this._lookahead(0) === TOK_COMMA) {\n        this._match(TOK_COMMA);\n      } else if (this._lookahead(0) === TOK_RBRACE) {\n        this._match(TOK_RBRACE);\n        break;\n      }\n    }\n    return { type: 'MultiSelectHash', children: pairs };\n  }\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport dataTypes from './dataTypes';\n\n// get the offset in MS, given a date and timezone\n// timezone is an IANA name. e.g. 'America/New_York'\nfunction offsetMS(dateObj, timeZone) {\n  const tzOffset = new Intl.DateTimeFormat('en-US', { timeZone, timeZoneName: 'longOffset' }).format(dateObj);\n  const offset = /GMT([+\\-])?(\\d{1,2}):?(\\d{0,2})?/.exec(tzOffset);\n  if (!offset) return 0;\n  const [sign, hours, minutes] = offset.slice(1);\n  const result = (((hours || 0) * 60) + 1 * (minutes || 0)) * 60 * 1000;\n  return sign === '-' ? result * -1 : result;\n}\n\nfunction round(num, digits) {\n  const precision = 10 ** digits;\n  return Math.round(num * precision) / precision;\n}\n\nconst MS_IN_DAY = 24 * 60 * 60 * 1000;\n\n// If we create a non-UTC date, then we need to adjust from the default JavaScript timezone\n// to the default timezone\nexport function adjustTimeZone(dateObj, timeZone) {\n  if (dateObj === null) return null;\n  let baseDate = Date.UTC(\n    dateObj.getFullYear(),\n    dateObj.getMonth(),\n    dateObj.getDate(),\n    dateObj.getHours(),\n    dateObj.getMinutes(),\n    dateObj.getSeconds(),\n    dateObj.getMilliseconds(),\n  );\n  baseDate += offsetMS(dateObj, timeZone);\n\n  // get the offset for the default JS environment\n  // return days since the epoch\n  return new Date(baseDate);\n}\n\nexport default function openFormulaFunctions(valueOf, toString, toNumber) {\n  return {\n  /**\n   * Return a lower-case string using locale-specific mappings.\n   * e.g. Strings with German lowercase letter '' can be compared to 'ss'\n   * @param {string} input string to casefold\n   * @returns {string} A new string converted to lower case\n   * @function\n   */\n    casefold: {\n      _func: (args, _data, interpreter) => {\n        const str = toString(args[0]);\n        return str.toLocaleUpperCase(interpreter.language).toLocaleLowerCase(interpreter.language);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    /**\n     * Returns the logical AND result of all parameters\n     * @param {any} first logical expression -- will be cast to boolean\n     * @param {...any} operand any number of additional expressions\n     * @returns {boolean} The logical result of applying AND to all parameters\n     * @example\n     * and(10 > 8, length('foo') < 5)\n     * // true\n     * @function\n     */\n    and: {\n      _func: resolvedArgs => {\n        let result = !!valueOf(resolvedArgs[0]);\n        resolvedArgs.slice(1).forEach(arg => {\n          result = result && !!valueOf(arg);\n        });\n        return result;\n      },\n      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],\n    },\n    /**\n     * Returns the logical OR result of two parameters\n     * @param {any} first logical expression -- will be cast to boolean\n     * @param {...any} operand any number of additional expressions\n     * @returns {boolean} The logical result of applying OR to all parameters\n     * @example\n     * or((x / 2) == y, (y * 2) == x)\n     * // true\n     * @function\n     */\n    or: {\n      _func: resolvedArgs => {\n        let result = !!valueOf(resolvedArgs[0]);\n        resolvedArgs.slice(1).forEach(arg => {\n          result = result || !!valueOf(arg);\n        });\n        return result;\n      },\n      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],\n    },\n    /**\n     * Compute logical NOT\n     * Note that it is also possible to use the logical and operator: `A && B`\n     * @param {any} - any data type -- will be cast to boolean\n     * @returns {boolean} The logical NOT applied to the input parameter\n     * @example\n     * not(length('bar') > 0)\n     * // false\n     * @function\n     */\n    not: {\n      _func: resolveArgs => !valueOf(resolveArgs[0]),\n      _signature: [{ types: [dataTypes.TYPE_ANY] }],\n    },\n\n    /**\n     * Return constant boolean true value.\n     * Note that expressions may also use the JSON literal true: `` `true` ``\n     * @returns {boolean} True\n     * @function\n     */\n    true: {\n      _func: () => true,\n      _signature: [],\n    },\n\n    /**\n     * Return constant boolean false value.\n     * Note that expressions may also use the JSON literal false: `` `false` ``\n     * @returns {boolean} False\n     * @function\n     */\n    false: {\n      _func: () => false,\n      _signature: [],\n    },\n\n    /**\n     * Return one of two values, depending on a condition\n     * @returns {boolean} True\n     * @param {any} condition logical expression to evaluate\n     * @param {any} result1 if logical condition is true\n     * @param {any} result2 if logical condition is false\n     * @return {any} either result1 or result2\n     * @function\n     */\n    if: {\n      _func: (unresolvedArgs, data, interpreter) => {\n        const conditionNode = unresolvedArgs[0];\n        const leftBranchNode = unresolvedArgs[1];\n        const rightBranchNode = unresolvedArgs[2];\n        const condition = interpreter.visit(conditionNode, data);\n        if (valueOf(condition)) {\n          return interpreter.visit(leftBranchNode, data);\n        }\n        return interpreter.visit(rightBranchNode, data);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] }],\n    },\n\n    /**\n     * Returns input `text`, with text `old` replaced by text `new` (when searching from the left).\n     * If `which` parameter is omitted, every occurrence of `old` is replaced with `new`;\n     * If `which` is provided, only that occurrence of `old` is replaced by `new`\n     * (starting the count from 1).\n     * If there is no match, or if `old` has length 0, `text` is returned unchanged.\n     * Note that `old` and `new` may have different lengths. If `which` < 1, return `text` unchanged\n     * @param {string} text\n     * @param {string} old text\n     * @param {string} new text\n     * @param {integer} which (optional) which occurence to replace\n     * @returns {string} replaced string\n     * @function\n     */\n    substitute: {\n      _func: args => {\n        const src = toString(args[0]);\n        const old = toString(args[1]);\n        const replacement = toString(args[2]);\n        // no third parameter? replace all instances\n        if (args.length <= 3) return src.replaceAll(old, replacement);\n        const whch = toNumber(args[3]);\n        if (whch < 1) return src;\n        // find the instance to replace\n        let pos = -1;\n        for (let i = 0; i < whch; i += 1) {\n          pos += 1;\n          const nextFind = src.slice(pos).indexOf(old);\n          // no instance to match 'Which'\n          if (nextFind === -1) return src;\n          pos += nextFind;\n        }\n        return src.slice(0, pos) + src.slice(pos).replace(old, replacement);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    /**\n     * Perform an indexed lookup on a map or array\n     * @param {map | array} object on which to perform the lookup\n     * @param {string | integer} index: a named child for a map or an integer offset for an array\n     * @returns {any} the result of the lookup -- or `null` if not found.\n     * @function\n     */\n    value: {\n      _func: args => {\n        const obj = args[0] || {};\n        const index = args[1];\n        const result = obj[index];\n        return result === undefined ? null : result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_OBJECT, dataTypes.TYPE_ARRAY, dataTypes.TYPE_NULL] },\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    lower: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toLowerCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    upper: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toUpperCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    exp: {\n      _func: args => {\n        const value = toNumber(args[0]);\n        return Math.exp(value);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    power: {\n      _func: args => {\n        const base = toNumber(args[0]);\n        const power = toNumber(args[1]);\n        return base ** power;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    find: {\n      _func: args => {\n        const query = toString(args[0]);\n        const text = toString(args[1]);\n        const startPos = args.length > 2 ? toNumber(args[2]) : 0;\n        const result = text.indexOf(query, startPos);\n        if (result === -1) {\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    left: {\n      _func: args => {\n        const numEntries = args.length > 1 ? toNumber(args[1]) : 1;\n        if (numEntries < 0) return null;\n        if (args[0] instanceof Array) {\n          return args[0].slice(0, numEntries);\n        }\n        const text = toString(args[0]);\n        return text.substr(0, numEntries);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    right: {\n      _func: args => {\n        const numEntries = args.length > 1 ? toNumber(args[1]) : 1;\n        if (numEntries < 0) return null;\n        if (args[0] instanceof Array) {\n          if (numEntries === 0) return [];\n          return args[0].slice(numEntries * -1);\n        }\n        const text = toString(args[0]);\n        const start = text.length - numEntries;\n        return text.substr(start, numEntries);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    mid: {\n      _func: args => {\n        const startPos = toNumber(args[1]);\n        const numEntries = toNumber(args[2]);\n        if (startPos < 0) return null;\n        if (args[0] instanceof Array) {\n          return args[0].slice(startPos, startPos + numEntries);\n        }\n        const text = toString(args[0]);\n        return text.substr(startPos, numEntries);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    mod: {\n      _func: args => {\n        const p1 = toNumber(args[0]);\n        const p2 = toNumber(args[1]);\n        return p1 % p2;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    proper: {\n      _func: args => {\n        const text = toString(args[0]);\n        const words = text.split(' ');\n        const properWords = words.map(word => word.charAt(0).toUpperCase()\n          + word.slice(1).toLowerCase());\n        return properWords.join(' ');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    rept: {\n      _func: args => {\n        const text = toString(args[0]);\n        const count = toNumber(args[1]);\n        if (count < 0) {\n          return null;\n        }\n        return text.repeat(count);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    replace: {\n      _func: args => {\n        const oldText = toString(args[0]);\n        const startNum = toNumber(args[1]);\n        const numChars = toNumber(args[2]);\n        const newText = toString(args[3]);\n        if (startNum < 0) {\n          return null;\n        }\n\n        const lhs = oldText.substr(0, startNum);\n        const rhs = oldText.substr(startNum + numChars);\n        return lhs + newText + rhs;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    round: {\n      _func: args => {\n        const number = toNumber(args[0]);\n        const digits = toNumber(args[1]);\n        return round(number, digits);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    sqrt: {\n      _func: args => {\n        const result = Math.sqrt(toNumber(args[0]));\n        if (Number.isNaN(result)) {\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    stdevp: {\n      _func: args => {\n        const values = args[0] || [];\n        if (values.length === 0) {\n          return null;\n        }\n        const coercedValues = values.map(value => toNumber(value));\n        const mean = coercedValues.reduce((a, b) => a + b, 0) / values.length;\n        const meanSumSquare = coercedValues.reduce((a, b) => a + b * b, 0) / values.length;\n        const result = Math.sqrt(meanSumSquare - mean * mean);\n        if (Number.isNaN(result)) {\n        // this would never happen\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n    stdev: {\n      _func: args => {\n        const values = args[0] || [];\n        if (values.length <= 1) {\n          return null;\n        }\n        const coercedValues = values.map(value => toNumber(value));\n        const mean = coercedValues.reduce((a, b) => a + b, 0) / values.length;\n        const sumSquare = coercedValues.reduce((a, b) => a + b * b, 0);\n        const result = Math.sqrt((sumSquare - values.length * mean * mean) / (values.length - 1));\n        if (Number.isNaN(result)) {\n        // this would never happen\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n    trim: {\n      _func: args => {\n        const text = toString(args[0]);\n        // only removes the space character\n        // other whitespace characters like \\t \\n left intact\n        return text.split(' ').filter(x => x).join(' ');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    trunc: {\n      _func: args => {\n        const number = toNumber(args[0]);\n        const digits = args.length > 1 ? toNumber(args[1]) : 0;\n        const method = number >= 0 ? Math.floor : Math.ceil;\n        return method(number * 10 ** digits) / 10 ** digits;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    charCode: {\n      _func: args => {\n        const code = toNumber(args[0]);\n        if (!Number.isInteger(code)) {\n          return null;\n        }\n        return String.fromCharCode(code);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    codePoint: {\n      _func: args => {\n        const text = toString(args[0]);\n        if (text.length === 0) {\n          return null;\n        }\n        return text.codePointAt(0);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    /**\n     * Return a date/time value.\n     * @param {integer} year\n     * @param {integer} day\n     * @param {integer} hours\n     * @param {integer} (optional) minutes\n     * @param {integer} (optional) seconds\n     * @param {integer} (optional) milliseconds\n     * @param {string} (optional) time zone name --\n     * according to IANA time zone names. e.g. \"America/Toronto\"\n     * @returns {number} the new date/time value\n     * @function\n     */\n    datetime: {\n      _func: args => {\n        const year = toNumber(args[0]);\n        const month = toNumber(args[1]);\n        const day = toNumber(args[2]);\n        const hours = args.length > 3 ? toNumber(args[3]) : 0;\n        const minutes = args.length > 4 ? toNumber(args[4]) : 0;\n        const seconds = args.length > 5 ? toNumber(args[5]) : 0;\n        const ms = args.length > 6 ? toNumber(args[6]) : 0;\n        const tz = args.length > 7 ? toString(args[7]) : null;\n        // javascript months starts from 0\n        let jsDate = new Date(year, month - 1, day, hours, minutes, seconds, ms);\n        if (tz) {\n          jsDate = adjustTimeZone(jsDate, tz);\n        }\n        return jsDate.getTime() / MS_IN_DAY;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n        { types: [dataTypes.TYPE_STRING], optional: true },\n      ],\n    },\n    /**\n     * Return a datetime value.\n     * @param {number} start_date The starting date\n     * @param {number} end_date The end date -- must be greater or equal to start_date\n     * @param {string} unit  One of:\n          `y` the number of whole years between start_date and end_date\n          `m` the number of whole months between start_date and end_date.\n          `d` the number of days between start_date and end_date\n          `md` the number of days between start_date and end_date after subtracting whole months.\n          `ym` the number of whole months between start_date and end_date\n             after subtracting whole years.\n          `yd` the number of days between start_date and end_date, assuming start_date\n             and end_date were no more than one year apart\n      * @returns {integer} The number of days/months/years difference\n      * @function\n      */\n    datedif: {\n      _func: args => {\n        const d1 = toNumber(args[0]);\n        const d2 = toNumber(args[1]);\n        const unit = toString(args[2]).toLowerCase();\n        if (d2 === d1) return 0;\n        if (d2 < d1) return null;\n        if (unit === 'd') return Math.floor(d2 - d1);\n        const date1 = new Date(d1 * MS_IN_DAY);\n        const date2 = new Date(d2 * MS_IN_DAY);\n        const yearDiff = date2.getFullYear() - date1.getFullYear();\n        let monthDiff = date2.getMonth() - date1.getMonth();\n        const dayDiff = date2.getDate() - date1.getDate();\n\n        if (unit === 'y') {\n          let y = yearDiff;\n          if (monthDiff < 0) y -= 1;\n          if (monthDiff === 0 && dayDiff < 0) y -= 1;\n          return y;\n        }\n        if (unit === 'm') {\n          return yearDiff * 12 + monthDiff + (dayDiff < 0 ? -1 : 0);\n        }\n        if (unit === 'ym') {\n          if (dayDiff < 0) monthDiff -= 1;\n          if (monthDiff <= 0 && yearDiff > 0) return 12 + monthDiff;\n          return monthDiff;\n        }\n        if (unit === 'yd') {\n          if (dayDiff < 0) monthDiff -= 1;\n          if (monthDiff < 0) date2.setFullYear(date1.getFullYear() + 1);\n          else date2.setFullYear(date1.getFullYear());\n          return Math.floor((date2.getTime() - date1.getTime()) / MS_IN_DAY);\n        }\n        throw new TypeError(`Unrecognized unit parameter \"${unit}\" for datedif()`);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    /**\n      * Summary: Returns the serial number of the end of a month, given date plus MonthAdd months\n      * @param {number} startDate The base date to start from\n      * @param {integer} monthAdd Number of months to add to start date\n      * @return {integer} the number of days in the computed month\n      * @function\n      */\n    eomonth: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const months = toNumber(args[1]);\n        const jsDate = new Date(date * MS_IN_DAY);\n        // We can give the constructor a month value > 11 and it will increment the years\n        // Since day is 1-based, giving zero will yield the last day of the previous month\n        const newDate = new Date(jsDate.getFullYear(), jsDate.getMonth() + months + 1, 0);\n        return newDate.getTime() / MS_IN_DAY;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    day: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const jsDate = new Date(date * MS_IN_DAY);\n        return jsDate.getDate();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    month: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const jsDate = new Date(date * MS_IN_DAY);\n        // javascript months start from 0\n        return jsDate.getMonth() + 1;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    year: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const jsDate = new Date(date * MS_IN_DAY);\n        return jsDate.getFullYear();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    time: {\n      _func: args => {\n        const hours = toNumber(args[0]);\n        const minutes = toNumber(args[1]);\n        const seconds = toNumber(args[2]);\n        const time = (hours * 3600 + minutes * 60 + seconds) / 86400;\n        if (time < 0) {\n          return null;\n        }\n        return time - Math.floor(time);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    hour: {\n      _func: args => {\n        // grab just the fraction part\n        const time = toNumber(args[0]) % 1;\n        if (time < 0) {\n          return null;\n        }\n        // Normally we'd round to 15 digits, but since we're also multiplying by 24,\n        // a reasonable precision is around 14 digits.\n\n        const hour = round(time * 24, 14);\n\n        return Math.floor(hour % 24);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    minute: {\n      _func: args => {\n        const time = toNumber(args[0]) % 1;\n        if (time < 0) {\n          return null;\n        }\n\n        // Normally we'd round to 15 digits, but since we're also multiplying by 1440,\n        // a reasonable precision is around 10 digits.\n        const minute = Math.round(time * 1440, 10);\n        return Math.floor(minute % 60);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    second: {\n      _func: args => {\n        const time = toNumber(args[0]) % 1;\n        if (time < 0) {\n          return null;\n        }\n\n        // Normally we'd round to 15 digits, but since we're also multiplying by 86400,\n        // a reasonable precision is around 10 digits.\n        const seconds = round(time * 86400, 10);\n        return Math.floor(seconds % 60);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    now: {\n      _func: () => Date.now() / MS_IN_DAY,\n      _signature: [],\n    },\n    today: {\n      _func: () => Math.floor(Date.now() / MS_IN_DAY),\n      _signature: [],\n    },\n    weekday: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const type = args.length > 1 ? toNumber(args[1]) : 1;\n        const jsDate = new Date(date * MS_IN_DAY);\n        const day = jsDate.getDay();\n        // day is in range [0-7) with 0 mapping to sunday\n        switch (type) {\n          case 1:\n            // range = [1, 7], sunday = 1\n            return day + 1;\n          case 2:\n            // range = [1, 7] sunday = 7\n            return ((day + 6) % 7) + 1;\n          case 3:\n            // range = [0, 6] sunday = 6\n            return (day + 6) % 7;\n          default:\n            return null;\n        }\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    entries: {\n      _func: args => {\n        const obj = valueOf(args[0]);\n        return Object.entries(obj);\n      },\n      _signature: [\n        {\n          types: [\n            dataTypes.TYPE_NUMBER,\n            dataTypes.TYPE_STRING,\n            dataTypes.TYPE_ARRAY,\n            dataTypes.TYPE_OBJECT,\n            dataTypes.TYPE_BOOLEAN,\n          ],\n        },\n      ],\n    },\n    fromEntries: {\n      _func: args => {\n        const array = args[0];\n        return Object.fromEntries(array);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_ARRAY] },\n      ],\n    },\n    split: {\n      _func: args => {\n        const str = toString(args[0]);\n        const separator = toString(args[1]);\n        return str.split(separator);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n  };\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nNOTICE:\nThis file is substantially modified from the original source taken from:\nhttps://github.com/jmespath/jmespath.js\n\n*/\n\n/* eslint-disable no-underscore-dangle */\nimport dataTypes from './dataTypes';\n\nexport default function functions(\n  interpreter,\n  isObject,\n  isArray,\n  toNumber,\n  getTypeName,\n  valueOf,\n  toString,\n) {\n  const {\n    TYPE_NUMBER,\n    TYPE_ANY,\n    TYPE_STRING,\n    TYPE_ARRAY,\n    TYPE_OBJECT,\n    TYPE_BOOLEAN,\n    TYPE_EXPREF,\n    TYPE_NULL,\n    TYPE_ARRAY_NUMBER,\n    TYPE_ARRAY_STRING,\n  } = dataTypes;\n\n  function createKeyFunction(exprefNode, allowedTypes) {\n    return x => {\n      const current = interpreter.visit(exprefNode, x);\n      if (allowedTypes.indexOf(getTypeName(current)) < 0) {\n        const msg = `TypeError: expected one of ${allowedTypes\n        }, received ${getTypeName(current)}`;\n        throw new Error(msg);\n      }\n      return current;\n    };\n  }\n\n  return {\n    // name: [function, <signature>]\n    // The <signature> can be:\n    //\n    // {\n    //   args: [[type1, type2], [type1, type2]],\n    //   variadic: true|false\n    // }\n    //\n    // Each arg in the arg list is a list of valid types\n    // (if the function is overloaded and supports multiple\n    // types.  If the type is \"any\" then no type checking\n    // occurs on the argument.  Variadic is optional\n    // and if not provided is assumed to be false.\n    abs: {\n      _func: resolvedArgs => Math.abs(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    avg: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        const inputArray = resolvedArgs[0];\n        inputArray.forEach(a => {\n          sum += a;\n        });\n        return sum / inputArray.length;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n    ceil: {\n      _func: resolvedArgs => Math.ceil(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    contains: {\n      _func: resolvedArgs => valueOf(resolvedArgs[0]).indexOf(valueOf(resolvedArgs[1])) >= 0,\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] },\n        { types: [TYPE_ANY] }],\n    },\n    endsWith: {\n      _func: resolvedArgs => {\n        const searchStr = valueOf(resolvedArgs[0]);\n        const suffix = valueOf(resolvedArgs[1]);\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n      },\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    floor: {\n      _func: resolvedArgs => Math.floor(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    length: {\n      _func: resolvedArgs => {\n        const arg = valueOf(resolvedArgs[0]);\n        if (isObject(arg)) return Object.keys(arg).length;\n\n        return isArray(arg) ? arg.length : toString(arg).length;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],\n    },\n\n    map: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[0];\n        return resolvedArgs[1].map(arg => interpreter.visit(exprefNode, arg));\n      },\n      _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }],\n    },\n\n    reduce: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[0];\n        return resolvedArgs[1].reduce(\n          (accumulated, current, index, array) => interpreter.visit(exprefNode, {\n            accumulated, current, index, array,\n          }),\n          resolvedArgs.length === 3 ? resolvedArgs[2] : null,\n        );\n      },\n      _signature: [\n        { types: [TYPE_EXPREF] },\n        { types: [TYPE_ARRAY] },\n        { types: [TYPE_ANY], optional: true },\n      ],\n    },\n\n    max: {\n      _func: resolvedArgs => {\n        if (resolvedArgs[0].length > 0) {\n          const typeName = getTypeName(resolvedArgs[0][0]);\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0].reduce(\n              (prev, cur) => (toNumber(prev) >= toNumber(cur) ? prev : cur),\n              resolvedArgs[0][0],\n            );\n          }\n          return resolvedArgs[0].reduce(\n            (a, b) => (toString(b).localeCompare(toString(a)) < 0 ? a : b),\n            resolvedArgs[0][0],\n          );\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n    },\n\n    merge: {\n      _func: resolvedArgs => {\n        const merged = {};\n        resolvedArgs.forEach(current => {\n          Object.entries(current).forEach(([key, value]) => {\n            merged[key] = value;\n          });\n        });\n        return merged;\n      },\n      _signature: [{ types: [TYPE_OBJECT], variadic: true }],\n    },\n\n    maxBy: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        const resolvedArray = resolvedArgs[0];\n        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n        let maxNumber = -Infinity;\n        let maxRecord;\n        let current;\n        resolvedArray.forEach(arg => {\n          current = keyFunction(arg);\n          if (current > maxNumber) {\n            maxNumber = current;\n            maxRecord = arg;\n          }\n        });\n        return maxRecord;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    sum: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        resolvedArgs[0].forEach(arg => {\n          sum += arg * 1;\n        });\n        return sum;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n\n    startsWith: {\n      _func: resolvedArgs => valueOf(resolvedArgs[0]).startsWith(valueOf(resolvedArgs[1])),\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    min: {\n      _func: resolvedArgs => {\n        if (resolvedArgs[0].length > 0) {\n          const typeName = getTypeName(resolvedArgs[0][0]);\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0].reduce(\n              (prev, cur) => (toNumber(prev) <= toNumber(cur) ? prev : cur),\n              resolvedArgs[0][0],\n            );\n          }\n          const elements = resolvedArgs[0];\n          let minElement = elements[0];\n          for (let i = 1; i < elements.length; i += 1) {\n            if (toString(elements[i]).localeCompare(toString(minElement)) < 0) {\n              minElement = elements[i];\n            }\n          }\n          return minElement;\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n    },\n\n    minBy: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        const resolvedArray = resolvedArgs[0];\n        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n        let minNumber = Infinity;\n        let minRecord;\n        let current;\n        resolvedArray.forEach(arg => {\n          current = keyFunction(arg);\n          if (current < minNumber) {\n            minNumber = current;\n            minRecord = arg;\n          }\n        });\n        return minRecord;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    type: {\n      _func: resolvedArgs => ({\n        [TYPE_NUMBER]: 'number',\n        [TYPE_STRING]: 'string',\n        [TYPE_ARRAY]: 'array',\n        [TYPE_OBJECT]: 'object',\n        [TYPE_BOOLEAN]: 'boolean',\n        [TYPE_EXPREF]: 'expref',\n        [TYPE_NULL]: 'null',\n      }[getTypeName(resolvedArgs[0])]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    keys: {\n      _func: resolvedArgs => Object.keys(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    values: {\n      _func: resolvedArgs => Object.values(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    sort: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length > 0) {\n          const normalize = getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER ? toNumber : toString;\n          sortedArray.sort((a, b) => {\n            const va = normalize(a);\n            const vb = normalize(b);\n            if (va < vb) return -1;\n            if (va > vb) return 1;\n            return 0;\n          });\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }],\n    },\n\n    sortBy: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n          return sortedArray;\n        }\n        const exprefNode = resolvedArgs[1];\n        const requiredType = getTypeName(\n          interpreter.visit(exprefNode, sortedArray[0]),\n        );\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n          throw new Error('TypeError');\n        }\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        const decorated = [];\n        for (let i = 0; i < sortedArray.length; i += 1) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort((a, b) => {\n          const exprA = interpreter.visit(exprefNode, a[1]);\n          const exprB = interpreter.visit(exprefNode, b[1]);\n          if (getTypeName(exprA) !== requiredType) {\n            throw new Error(\n              `TypeError: expected ${requiredType}, received ${\n                getTypeName(exprA)}`,\n            );\n          } else if (getTypeName(exprB) !== requiredType) {\n            throw new Error(\n              `TypeError: expected ${requiredType}, received ${\n                getTypeName(exprB)}`,\n            );\n          }\n          if (exprA > exprB) {\n            return 1;\n          }\n          if (exprA < exprB) {\n            return -1;\n          }\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        });\n        // Undecorate: extract out the original list elements.\n        for (let j = 0; j < decorated.length; j += 1) {\n          [, sortedArray[j]] = decorated[j];\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    join: {\n      _func: resolvedArgs => {\n        const joinChar = resolvedArgs[0];\n        const listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n      },\n      _signature: [\n        { types: [TYPE_STRING] },\n        { types: [TYPE_ARRAY_STRING] },\n      ],\n    },\n\n    reverse: {\n      _func: resolvedArgs => {\n        const originalStr = valueOf(resolvedArgs[0]);\n        const typeName = getTypeName(originalStr);\n        if (typeName === TYPE_STRING) {\n          let reversedStr = '';\n          for (let i = originalStr.length - 1; i >= 0; i -= 1) {\n            reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        }\n        const reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],\n    },\n\n    toArray: {\n      _func: resolvedArgs => {\n        if (getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n          return resolvedArgs[0];\n        }\n        return [resolvedArgs[0]];\n      },\n\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    toString: {\n      _func: resolvedArgs => {\n        if (getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n          return resolvedArgs[0];\n        }\n        return JSON.stringify(resolvedArgs[0]);\n      },\n\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    toNumber: {\n      _func: resolvedArgs => {\n        const typeName = getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_NUMBER) {\n          return resolvedArgs[0];\n        }\n        if (typeName === TYPE_STRING) {\n          return toNumber(resolvedArgs[0]);\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    notNull: {\n      _func: resolvedArgs => resolvedArgs.find(arg => getTypeName(arg) !== TYPE_NULL) || null,\n      _signature: [{ types: [TYPE_ANY], variadic: true }],\n    },\n    /**\n     * Returns a convolved (zipped) array containing grouped arrays of values from\n     * the array arguments from index 0, 1, 2, etc.\n     * This function accepts a variable number of arguments.\n     * The length of the returned array is equal to the length of the shortest array.\n     * @param {...array} arrays array of arrays to zip together\n     * @returns {array} An array of arrays with elements zipped together\n     * @function\n     */\n    zip: {\n      _func: args => {\n        const count = args.reduce((min, current) => Math.min(min, current.length), args[0].length);\n        const result = new Array(count);\n        for (let i = 0; i < count; i += 1) {\n          result[i] = []\n          args.forEach(a => {\n            result[i].push(a[i]);\n          });\n        }\n        return result;\n      },\n      _signature: [{ types: [TYPE_ARRAY], variadic: true }],\n    },\n  };\n}\n","/* eslint-disable no-underscore-dangle */\nimport TreeInterpreter from './TreeInterpreter';\nimport Parser from './Parser';\nimport dataTypes from './dataTypes';\nimport { matchType, getTypeName, getTypeNames } from './matchType';\nimport openFormulaFunctions from './openFormulaFunctions';\nimport functions from './functions';\nimport {\n  isArray, isObject, strictDeepEqual, getValueOf,\n} from './utils';\n\n// Type constants used to define functions.\nconst {\n  TYPE_CLASS,\n  TYPE_ANY,\n} = dataTypes;\n\nfunction JsonFormula() {\n  let toNumber;\n\n  function getToNumber(stringToNumber, debug = []) {\n    return value => {\n      const n = getValueOf(value); // in case it's an object that implements valueOf()\n      if (n === null) return null;\n      if (n instanceof Array) {\n        debug.push('Converted array to zero');\n        return 0;\n      }\n      const type = typeof n;\n      if (type === 'number') return n;\n      if (type === 'string') return stringToNumber(n, debug);\n      if (type === 'boolean') return n ? 1 : 0;\n      debug.push('Converted object to zero');\n      return 0;\n    };\n  }\n\n  function toString(a) {\n    if (a === null || a === undefined) return '';\n    // don't call a 'toString' method, since we could have a child named 'toString()'\n    return a.toString();\n  }\n\n  function isClass(obj) {\n    if (obj === null) return false;\n    if (Array.isArray(obj)) return false;\n    return obj.constructor.name !== 'Object';\n  }\n\n  function matchClass(arg, expectedList) {\n    // checking isClass() generates a dependency -- so call it only if necessary\n    return expectedList.includes(TYPE_CLASS) && isClass(arg);\n  }\n\n  class Runtime {\n    addFunctions(customFunctions = {}) {\n      this.functionTable = {\n        ...functions(\n          this._interpreter,\n          isObject,\n          isArray,\n          toNumber,\n          getTypeName,\n          getValueOf,\n          toString,\n        ),\n        ...openFormulaFunctions(getValueOf, toString, toNumber),\n        ...customFunctions,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    _validateArgs(argName, args, signature, bResolved) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      if (signature.length === 0) {\n        return;\n      }\n      let pluralized;\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? ' argument' : ' arguments';\n          throw new Error(`ArgumentError: ${argName}() `\n          + `takes at least${signature.length}${pluralized\n          } but received ${args.length}`);\n        }\n      } else if (args.length !== signature.length && !signature[signature.length - 1].optional) {\n        pluralized = signature.length === 1 ? ' argument' : ' arguments';\n        throw new Error(`ArgumentError: ${argName}() `\n        + `takes ${signature.length}${pluralized\n        } but received ${args.length}`);\n      }\n      // if the arguments are unresolved, there's no point in validating types\n      if (!bResolved) return;\n      let currentSpec;\n      let actualType;\n      const limit = Math.min(signature.length, args.length);\n      for (let i = 0; i < limit; i += 1) {\n        currentSpec = signature[i].types;\n        // Try to avoid checks that will introspect the object and generate dependencies\n        if (!matchClass(args[i], currentSpec) && !currentSpec.includes(TYPE_ANY)) {\n          actualType = getTypeNames(args[i]);\n          // eslint-disable-next-line no-param-reassign\n          args[i] = matchType(actualType, currentSpec, args[i], argName, toNumber, toString);\n        }\n      }\n    }\n\n    callFunction(name, resolvedArgs, data, interpreter, bResolved = true) {\n      // this check will weed out 'valueOf', 'toString' etc\n      if (!Object.prototype.hasOwnProperty.call(this.functionTable, name)) throw new Error(`Unknown function: ${name}()`);\n\n      const functionEntry = this.functionTable[name];\n      this._validateArgs(name, resolvedArgs, functionEntry._signature, bResolved);\n      return functionEntry._func.call(this, resolvedArgs, data, interpreter);\n    }\n  }\n\n  function compile(stream, allowedGlobalNames = [], debug = []) {\n    let ast;\n    try {\n      const parser = new Parser(allowedGlobalNames);\n      ast = parser.parse(stream, debug);\n    } catch (e) {\n      debug.push(e.toString());\n      throw e;\n    }\n    return ast;\n  }\n\n  function search(node, data, globals, customFunctions, stringToNumberFn, debug = [], language = 'en-US') {\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    const runtime = new Runtime(customFunctions);\n    runtime.debug = debug;\n    const defaultStringToNumber = (str => {\n      const n = +str;\n      return Number.isNaN(n) ? 0 : n;\n    });\n    toNumber = getToNumber(stringToNumberFn || defaultStringToNumber, debug);\n    const interpreter = new TreeInterpreter(runtime, globals, toNumber, toString, debug, language);\n    runtime._interpreter = interpreter;\n    runtime.addFunctions(customFunctions);\n\n    try {\n      return interpreter.search(node, data);\n    } catch (e) {\n      debug.push(e.message || e.toString());\n      throw e;\n    }\n  }\n  this.compile = compile;\n  this.search = search;\n  this.strictDeepEqual = strictDeepEqual;\n}\n\nexport default new JsonFormula();\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport jmespath from './jmespath/jmespath';\n\nexport class Formula {\n  constructor(\n    expression,\n    customFunctions = {},\n    stringToNumber = null,\n    allowedGlobalNames = [],\n    debug = [],\n    language = 'en-US',\n  ) {\n    this.expression = expression;\n    this.customFunctions = customFunctions;\n    this.stringToNumber = stringToNumber;\n    this.node = jmespath.compile(expression, allowedGlobalNames, debug);\n    this.debug = debug;\n    this.language = language;\n  }\n\n  search(json, globals) {\n    return jmespath.search(\n      this.node,\n      json,\n      globals,\n      { ...this.customFunctions },\n      this.stringToNumber,\n      this.debug,\n      this.language,\n    );\n  }\n}\n\n// eslint-disable-next-line import/prefer-default-export\nexport function jsonFormula(\n  json,\n  globals,\n  expression,\n  customFunctions = {},\n  stringToNumber = null,\n  debug = [],\n  language = 'en-US',\n) {\n  const formula = new Formula(\n    expression,\n    customFunctions,\n    stringToNumber,\n    Object.keys(globals),\n    debug,\n    language,\n  );\n  return formula.search(\n    json,\n    globals,\n    { ...customFunctions },\n    stringToNumber,\n    debug,\n    language,\n  );\n}\n","/* eslint-disable no-underscore-dangle */\n/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable class-methods-use-this */\n/*\n    Field class allows objects to evaluate correctly according to context.\n    - if used in an expression, will return a value or string.\n    - for JSON.stringify() returns a scalar\n    - BUT also allows explicit access to properties. e.g. field.required, field.name etc.\n\n    Should allow us to eliminate getFieldProperty()\n  */\n\nfunction createField(name, value, readonly = false, required = true) {\n  class Field {\n    valueOf() { return value; }\n\n    toString() { return value.toString(); }\n\n    toJSON() { return value; }\n\n    // Use getters and scope variables so that the children are not enumerable\n    get '$value'() { return value; }\n\n    get '$name'() { return name; }\n\n    get '$readonly'() { return readonly; }\n\n    get '$required'() { return required; }\n  }\n  return new Field();\n}\n/*\nfunction getProxy(f) {\n  const handler = {\n    getPrototypeOf() {\n      return f;\n    },\n    get() {\n      return Reflect.get(...arguments);\n    },\n  };\n\n  return new Proxy(f, handler);\n}\n*/\nfunction createFieldset(fsname, isObj, fields) {\n  class FieldsetObj {\n    get '$name'() { return fsname; }\n\n    get '$fields'() { return fields; }\n\n    _add(k, v) { this[k] = v; }\n  }\n  class FieldsetArray extends Array {\n    get '$name'() { return fsname; }\n\n    get '$fields'() { return fields; }\n\n    _add(k, v) { this[k] = v; }\n  }\n  const fieldset = isObj ? new FieldsetObj() : new FieldsetArray();\n  // const obj = isObj ? getProxy(fieldset) : fieldset;\n  // const obj = fieldset;\n  // return obj;\n  return fieldset;\n}\n\nfunction createFields(parent, childref, child) {\n  const result = [];\n  if (child instanceof Array) {\n    // parent._add(childref, createFieldset(childref, false));\n    parent._add(childref, createFieldset(childref, false, result));\n    child.forEach((item, index) => {\n      const fields = createFields(parent[childref], index, item);\n      result.push(...fields);\n    });\n  } else if (child !== null && typeof child === 'object') {\n    parent._add(childref, createFieldset(childref, true, result));\n    Object.keys(child).forEach(k => {\n      const fields = createFields(parent[childref], k, child[k]);\n      result.push(...fields);\n    });\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    const field = createField(childref, child);\n    parent[childref] = field;\n    result.push(field);\n  }\n  return result;\n}\n\nexport default function createForm(dataRoot) {\n  // if it's not an object or array (a scalar) then don't bother trying to create a form\n  if (dataRoot === null || typeof dataRoot !== 'object') return dataRoot;\n\n  const allFields = [];\n  const form = createFieldset('', !Array.isArray(dataRoot), allFields);\n  Object.entries(dataRoot).forEach(([k, v]) => {\n    allFields.push(...createFields(form, k, v));\n  });\n  return form;\n}\n","/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nexport default function stringToNumber(n, debug) {\n  const ret = +(n.replace(/\\$/, ''));\n  if (Number.isNaN(ret)) {\n    if (debug) debug.push(`Failed to convert ${n} to number`);\n    return 0;\n  }\n  return ret;\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* global window, document, fetch */\nimport { jsonFormula } from './json-formula';\nimport createForm from './Form';\nimport stringToNumber from './jmespath/stringToNumber';\n\nwindow.addEventListener('load', () => {\n  const dataElement = document.getElementById('data');\n  const expression = document.getElementById('expression');\n  const result = document.getElementById('result');\n  const debug = document.getElementById('debug');\n\n  const d = window.localStorage.getItem('data');\n  if (d) dataElement.value = d;\n  const exp = window.localStorage.getItem('expression');\n  if (exp) expression.value = exp;\n\n  function run() {\n    // save for next time...\n    window.localStorage.setItem('data', dataElement.value);\n    window.localStorage.setItem('expression', expression.value);\n    const input = expression.value;\n    const useFields = document.getElementById('use-fields').checked;\n    let jsonData;\n    try {\n      jsonData = JSON.parse(dataElement.value);\n      if (useFields) {\n        jsonData = createForm(jsonData);\n      }\n    } catch (e) {\n      result.value = e.toString();\n      return;\n    }\n\n    const debugInfo = [];\n    try {\n      const jsonResult = jsonFormula(\n        jsonData,\n        { $form: jsonData, $: {} },\n        input,\n        true,\n        stringToNumber,\n        debugInfo,\n      );\n      debug.innerHTML = debugInfo.join('\\n');\n      let r = jsonResult;\n      if (jsonResult !== null && jsonResult !== undefined) {\n        r = jsonResult.valueOf.call(jsonResult);\n      }\n      if (typeof r === 'object') {\n        result.value = JSON.stringify(r, null, 2);\n      } else {\n        result.value = r;\n      }\n    } catch (e) {\n      result.value = e.toString();\n      debug.innerHTML = debugInfo.join('\\n');\n    }\n  }\n\n  dataElement.addEventListener('blur', run);\n  expression.addEventListener('blur', run);\n  run();\n\n  fetch('../antlr/JSONFormula.g4').then(r => {\n    r.text().then(g4 => {\n      document.getElementById('grammar-out').innerHTML = g4;\n    });\n  });\n});\n"],"names":["exports","Symbol","toStringTag","Object","defineProperty","value","TYPE_NUMBER","TYPE_STRING","TYPE_ARRAY","TYPE_BOOLEAN","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","TOK_EXPREF","tokenDefinitions","TYPE_NAME_TABLE","getTypeName","inputObj","useValueOf","obj","valueOf","call","prototype","toString","jmespathType","getTypeNames","matchType","actuals","expectedList","argValue","context","toNumber","actual","findIndex","type","wrongType","length","includes","forEach","a","Array","Error","expected","find","e","subtype","returnArray","slice","i","indexType","isArray","isObject","getValueOf","map","strictDeepEqual","lhs","rhs","first","second","keysSeen","key","hasOwnProperty","key2","isFalse","TreeInterpreter","runtime","globals","debug","language","this","node","visit","n","v","visitFunctions","Field","field","name","undefined","push","available","keys","Subexpression","result","children","IndexExpression","left","Index","index","Slice","sliceParams","param","computeSliceParams","start","stop","step","Projection","base","collected","b","current","ValueProjection","projection","values","val","FilterProjection","filtered","filter","finalResults","f","Comparator","original","merged","_node","child","matched","applyOperator","concat","callFunction","resolvedArgs","refNode","fn","arrayLength","capSliceRange","arrayLen","stp","actualValue","error","stepValueNegative","operator","shorter","diff","Math","abs","fill","Number","isFinite","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RBRACKET","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_NUMBER","TOK_CURRENT","TOK_PIPE","TOK_OR","TOK_AND","TOK_DOT","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","basicTokens","operatorStartToken","skipChars","isNum","ch","includeSign","isAlphaNum","isIdentifier","stream","pos","Lexer","allowedGlobalNames","_allowedGlobalNames","identifier","token","tokens","_current","prev","_isGlobal","_consumeGlobal","_consumeUnquotedIdentifier","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","prevToken","maxLength","foundNonAlpha","replace","JSON","parse","replaceAll","parseFloat","parseInt","global","startingChar","inQuotes","literalString","trimStart","str","ex","_looksLikeJSON","TOK_EOF","TOK_CONCATENATE","TOK_RBRACE","TOK_GLOBAL","TOK_FIELD","TOK_SUBTRACT","TOK_MULTIPLY","TOK_POWER","TOK_DIVIDE","TOK_UNION","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_LBRACE","bindingPower","Parser","expression","_loadTokens","ast","_lookahead","t","_lookaheadToken","tokenize","rbp","leftToken","_advance","nud","currentToken","led","number","args","Not","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseUnchainedIndexExpression","Expref","_match","_errorToken","tokenName","condition","right","Concatenate","Dot","_parseDotRHS","Pipe","Or","And","Add","Subtract","Multiply","Divide","Power","Filter","_parseComparator","_parseChainedIndexExpression","_projectIfSlice","tokenType","oldIndex","_getIndex","_parseSliceExpression","_setIndex","firstToken","_parseMultiselectList","indexExpr","parts","comparator","lookahead","indexOf","expressions","keyToken","keyName","pairs","identifierTypes","round","num","digits","precision","MS_IN_DAY","adjustTimeZone","dateObj","timeZone","baseDate","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","tzOffset","Intl","DateTimeFormat","timeZoneName","format","offset","exec","sign","offsetMS","openFormulaFunctions","casefold","_func","_data","interpreter","toLocaleUpperCase","toLocaleLowerCase","_signature","types","and","arg","variadic","or","not","resolveArgs","true","false","if","unresolvedArgs","data","conditionNode","leftBranchNode","rightBranchNode","substitute","src","old","replacement","whch","nextFind","optional","lower","toLowerCase","upper","toUpperCase","exp","power","query","text","startPos","numEntries","substr","mid","mod","proper","split","word","charAt","join","rept","count","repeat","oldText","startNum","numChars","newText","sqrt","isNaN","stdevp","coercedValues","mean","reduce","meanSumSquare","stdev","sumSquare","trim","x","trunc","floor","ceil","charCode","code","isInteger","String","fromCharCode","codePoint","codePointAt","datetime","year","month","day","hours","minutes","seconds","ms","tz","jsDate","getTime","datedif","d1","d2","unit","date1","date2","yearDiff","monthDiff","dayDiff","y","setFullYear","TypeError","eomonth","date","months","time","hour","minute","now","today","weekday","getDay","entries","fromEntries","array","separator","functions","createKeyFunction","exprefNode","allowedTypes","msg","avg","sum","inputArray","contains","endsWith","searchStr","suffix","accumulated","max","cur","localeCompare","merge","maxBy","maxRecord","resolvedArray","keyFunction","maxNumber","startsWith","min","elements","minElement","minBy","minRecord","minNumber","Infinity","sort","sortedArray","normalize","va","vb","sortBy","requiredType","decorated","exprA","exprB","j","joinChar","reverse","originalStr","reversedStr","reversedArray","toArray","stringify","typeName","notNull","zip","getToNumber","stringToNumber","Runtime","customFunctions","functionTable","_interpreter","argName","signature","bResolved","pluralized","currentSpec","actualType","limit","constructor","functionEntry","_validateArgs","compile","parser","search","stringToNumberFn","defaultStringToNumber","addFunctions","message","Formula","jmespath","json","createFieldset","fsname","isObj","fields","FieldsetObj","k","FieldsetArray","createFields","parent","childref","_add","item","readonly","required","createField","ret","window","addEventListener","dataElement","document","getElementById","d","localStorage","getItem","run","setItem","jsonData","input","useFields","checked","dataRoot","allFields","form","createForm","debugInfo","jsonResult","jsonFormula","$form","$","innerHTML","r","fetch","then","g4"],"sourceRoot":""}