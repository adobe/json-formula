{"version":3,"file":"tutorial.js","mappings":"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","sources":["webpack://JSONFormula/webpack/bootstrap","webpack://JSONFormula/webpack/runtime/make namespace object","webpack://JSONFormula/./src/jmespath/dataTypes.js","webpack://JSONFormula/./src/jmespath/tokenDefinitions.js","webpack://JSONFormula/./src/jmespath/matchType.js","webpack://JSONFormula/./src/jmespath/utils.js","webpack://JSONFormula/./src/jmespath/TreeInterpreter.js","webpack://JSONFormula/./src/jmespath/Lexer.js","webpack://JSONFormula/./src/jmespath/Parser.js","webpack://JSONFormula/./src/jmespath/openFormulaFunctions.js","webpack://JSONFormula/./src/jmespath/functions.js","webpack://JSONFormula/./src/jmespath/jmespath.js","webpack://JSONFormula/./src/json-formula.js","webpack://JSONFormula/./src/Form.js","webpack://JSONFormula/./src/jmespath/stringToNumber.js","webpack://JSONFormula/./src/tutorial.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// Type constants used to define functions.\nexport default {\n  TYPE_NUMBER: 0,\n  TYPE_ANY: 1,\n  TYPE_STRING: 2,\n  TYPE_ARRAY: 3,\n  TYPE_OBJECT: 4,\n  TYPE_BOOLEAN: 5,\n  TYPE_EXPREF: 6,\n  TYPE_NULL: 7,\n  TYPE_ARRAY_NUMBER: 8,\n  TYPE_ARRAY_STRING: 9,\n  TYPE_CLASS: 10,\n  TYPE_ARRAY_ARRAY: 11,\n};\n","export default {\n  TOK_EOF: 'EOF',\n  TOK_UNQUOTEDIDENTIFIER: 'UnquotedIdentifier',\n  TOK_QUOTEDIDENTIFIER: 'QuotedIdentifier',\n  TOK_RBRACKET: 'Rbracket',\n  TOK_RPAREN: 'Rparen',\n  TOK_COMMA: 'Comma',\n  TOK_COLON: 'Colon',\n  TOK_CONCATENATE: 'Concatenate',\n  TOK_RBRACE: 'Rbrace',\n  TOK_NUMBER: 'Number',\n  TOK_CURRENT: 'Current',\n  TOK_GLOBAL: 'Global',\n  TOK_FIELD: 'Field',\n  TOK_EXPREF: 'Expref',\n  TOK_PIPE: 'Pipe',\n  TOK_OR: 'Or',\n  TOK_AND: 'And',\n  TOK_ADD: 'Add',\n  TOK_SUBTRACT: 'Subtract',\n  TOK_MULTIPLY: 'Multiply',\n  TOK_POWER: 'Power',\n  TOK_DIVIDE: 'Divide',\n  TOK_EQ: 'EQ',\n  TOK_GT: 'GT',\n  TOK_LT: 'LT',\n  TOK_GTE: 'GTE',\n  TOK_LTE: 'LTE',\n  TOK_NE: 'NE',\n  TOK_FLATTEN: 'Flatten',\n  TOK_STAR: 'Star',\n  TOK_FILTER: 'Filter',\n  TOK_DOT: 'Dot',\n  TOK_NOT: 'Not',\n  TOK_LBRACE: 'Lbrace',\n  TOK_LBRACKET: 'Lbracket',\n  TOK_LPAREN: 'Lparen',\n  TOK_LITERAL: 'Literal',\n};\n","import dataTypes from './dataTypes';\nimport tokenDefinitions from './tokenDefinitions';\n\nconst {\n  TYPE_NUMBER,\n  TYPE_ANY,\n  TYPE_STRING,\n  TYPE_ARRAY,\n  TYPE_OBJECT,\n  TYPE_BOOLEAN,\n  TYPE_EXPREF,\n  TYPE_NULL,\n  TYPE_ARRAY_NUMBER,\n  TYPE_ARRAY_STRING,\n  TYPE_CLASS,\n  TYPE_ARRAY_ARRAY,\n} = dataTypes;\n\nconst {\n  TOK_EXPREF,\n} = tokenDefinitions;\n\nconst TYPE_NAME_TABLE = {\n  [TYPE_NUMBER]: 'number',\n  [TYPE_ANY]: 'any',\n  [TYPE_STRING]: 'string',\n  [TYPE_ARRAY]: 'array',\n  [TYPE_OBJECT]: 'object',\n  [TYPE_BOOLEAN]: 'boolean',\n  [TYPE_EXPREF]: 'expression',\n  [TYPE_NULL]: 'null',\n  [TYPE_ARRAY_NUMBER]: 'Array<number>',\n  [TYPE_ARRAY_STRING]: 'Array<string>',\n  [TYPE_CLASS]: 'class',\n  [TYPE_ARRAY_ARRAY]: 'Array<array>',\n};\n\nexport function getTypeName(inputObj, useValueOf = true) {\n  if (inputObj === null) return TYPE_NULL;\n  const obj = useValueOf ? Object.getPrototypeOf(inputObj).valueOf.call(inputObj) : inputObj;\n  switch (Object.prototype.toString.call(obj)) {\n    case '[object String]':\n      return TYPE_STRING;\n    case '[object Number]':\n      return TYPE_NUMBER;\n    case '[object Array]':\n      return TYPE_ARRAY;\n    case '[object Boolean]':\n      return TYPE_BOOLEAN;\n    case '[object Null]':\n      return TYPE_NULL;\n    case '[object Object]':\n      // Check if it's an expref.  If it has, it's been\n      // tagged with a jmespathType attr of 'Expref';\n      if (obj.jmespathType === TOK_EXPREF) {\n        return TYPE_EXPREF;\n      }\n      return TYPE_OBJECT;\n    default:\n      return TYPE_OBJECT;\n  }\n}\n\nexport function getTypeNames(inputObj) {\n  // return the types with and without using valueOf\n  // needed for the cases where we really need an object passed to a function -- not it's value\n  const type1 = getTypeName(inputObj);\n  const type2 = getTypeName(inputObj, false);\n  return [type1, type2];\n}\n\nexport function matchType(actuals, expectedList, argValue, context, toNumber) {\n  const actual = actuals[0];\n  if (expectedList.findIndex(\n    type => type === TYPE_ANY || actual === type,\n  ) !== -1\n  ) return argValue;\n  // Can't coerce Objects to any other type,\n  // and cannot coerce anything to a Class\n  let wrongType = false;\n  if (actual === TYPE_OBJECT || (expectedList.length === 1 && expectedList[0] === TYPE_CLASS)) {\n    wrongType = true;\n  }\n  if (actual === TYPE_ARRAY && (expectedList.length === 1 && expectedList[0] === TYPE_OBJECT)) {\n    wrongType = true;\n  }\n  if (expectedList.includes(TYPE_ARRAY_ARRAY)) {\n    if (actual === TYPE_ARRAY) {\n      argValue.forEach(a => {\n        if (!(a instanceof Array)) wrongType = true;\n      });\n      if (!wrongType) return argValue;\n    }\n    wrongType = true;\n  }\n  if (wrongType) {\n    throw new Error(`TypeError: ${context} expected argument to be type ${TYPE_NAME_TABLE[expectedList[0]]} but received type ${TYPE_NAME_TABLE[actual]} instead.`);\n  }\n  // no exact match in the list of possible types, see if we can coerce an array type\n  let expected = -1;\n  if (actual === TYPE_ARRAY) {\n    if (expectedList.includes(TYPE_ARRAY_STRING) && expectedList.includes(TYPE_ARRAY_NUMBER)) {\n      // choose the array type based on the first element\n      if (argValue.length > 0 && typeof argValue[0] === 'string') expected = TYPE_ARRAY_STRING;\n      else expected = TYPE_ARRAY_NUMBER;\n    }\n  }\n  if (expected === -1 && [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(actual)) {\n    expected = expectedList.find(\n      e => [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER, TYPE_ARRAY].includes(e),\n    );\n  }\n  // no match, just take the first type\n  if (expected === -1) [expected] = expectedList;\n  if (expected === TYPE_ANY) return argValue;\n  if (expected === TYPE_ARRAY_STRING\n      || expected === TYPE_ARRAY_NUMBER\n      || expected === TYPE_ARRAY) {\n    if (expected === TYPE_ARRAY) {\n      if (actual === TYPE_ARRAY_NUMBER || actual === TYPE_ARRAY_STRING) return argValue;\n      return argValue === null ? [] : [argValue];\n    }\n    // The expected type can either just be array,\n    // or it can require a specific subtype (array of numbers).\n    const subtype = expected === TYPE_ARRAY_NUMBER ? TYPE_NUMBER : TYPE_STRING;\n    if (actual === TYPE_ARRAY) {\n      // Otherwise we need to check subtypes.\n      // We're going to modify the array, so take a copy\n      const returnArray = argValue.slice();\n      for (let i = 0; i < returnArray.length; i += 1) {\n        const indexType = getTypeNames(returnArray[i]);\n        returnArray[i] = matchType(indexType, [subtype], returnArray[i], context, toNumber);\n      }\n      return returnArray;\n    }\n    if ([TYPE_NUMBER, TYPE_STRING, TYPE_NULL, TYPE_BOOLEAN].includes(subtype)) {\n      return [matchType(actuals, [subtype], argValue, context, toNumber)];\n    }\n  } else {\n    if (expected === TYPE_NUMBER) {\n      if ([TYPE_STRING, TYPE_BOOLEAN, TYPE_NULL].includes(actual)) return toNumber(argValue);\n      /* TYPE_ARRAY, TYPE_EXPREF, TYPE_OBJECT, TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING */\n      return 0;\n    }\n    if (expected === TYPE_STRING) {\n      if (actual === TYPE_NULL || actual === TYPE_OBJECT) return '';\n      return Object.getPrototypeOf(argValue).toString.call(argValue);\n    }\n    if (expected === TYPE_BOOLEAN) {\n      return !!argValue;\n    }\n    if (expected === TYPE_OBJECT && actuals[1] === TYPE_OBJECT) {\n      return argValue;\n    }\n  }\n  throw new Error('unhandled argument');\n}\n","export function isArray(obj) {\n  if (obj !== null) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  }\n  return false;\n}\n\nexport function isObject(obj) {\n  if (obj !== null) {\n    return Object.prototype.toString.call(obj) === '[object Object]';\n  }\n  return false;\n}\n\nexport function getValueOf(a) {\n  if (a === null || a === undefined) return a;\n  if (isArray(a)) {\n    return a.map(i => getValueOf(i));\n  }\n  return a.valueOf();\n}\n\nexport function strictDeepEqual(lhs, rhs) {\n  const first = getValueOf(lhs);\n  const second = getValueOf(rhs);\n  // Check the scalar case first.\n  if (first === second) {\n    return true;\n  }\n\n  // Check if they are the same type.\n  const firstType = Object.prototype.toString.call(first);\n  if (firstType !== Object.prototype.toString.call(second)) {\n    return false;\n  }\n  // We know that first and second have the same type so we can just check the\n  // first type from now on.\n  if (isArray(first) === true) {\n    // Short circuit if they're not the same length;\n    if (first.length !== second.length) {\n      return false;\n    }\n    for (let i = 0; i < first.length; i += 1) {\n      if (strictDeepEqual(first[i], second[i]) === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (isObject(first) === true) {\n    // An object is equal if it has the same key/value pairs.\n    const keysSeen = {};\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in first) {\n      if (hasOwnProperty.call(first, key)) {\n        if (strictDeepEqual(first[key], second[key]) === false) {\n          return false;\n        }\n        keysSeen[key] = true;\n      }\n    }\n    // Now check that there aren't any keys in second that weren't\n    // in first.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key2 in second) {\n      if (hasOwnProperty.call(second, key2)) {\n        if (keysSeen[key2] !== true) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  return false;\n}\n","import { matchType, getTypeNames } from './matchType';\nimport dataTypes from './dataTypes';\nimport tokenDefinitions from './tokenDefinitions';\nimport {\n  isArray, isObject, strictDeepEqual, getValueOf,\n} from './utils';\n\nconst {\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_EQ,\n  TOK_GT,\n  TOK_LT,\n  TOK_GTE,\n  TOK_LTE,\n  TOK_NE,\n  TOK_FLATTEN,\n} = tokenDefinitions;\n\nconst {\n  TYPE_STRING,\n  TYPE_ARRAY_STRING,\n} = dataTypes;\n\nfunction isFalse(value) {\n  // From the spec:\n  // A false value corresponds to the following values:\n  // Empty list\n  // Empty object\n  // Empty string\n  // False boolean\n  // null value\n  // (new) use JS truthy evaluation.  This changes the spec behavior.\n  // Where in the past a zero (0) would be True, it's now false\n\n  // First check the scalar values.\n  if (value === null) return true;\n  // in case it's an object with a valueOf defined\n  const obj = getValueOf(value);\n  if (obj === '' || obj === false || obj === null) {\n    return true;\n  }\n  if (isArray(obj) && obj.length === 0) {\n    // Check for an empty array.\n    return true;\n  }\n  if (isObject(obj)) {\n    // Check for an empty object.\n    // eslint-disable-next-line no-restricted-syntax\n    for (const key in obj) {\n      // If there are any keys, then\n      // the object is not empty so the object\n      // is not false.\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return !obj;\n}\n\nfunction objValues(obj) {\n  return Object.values(obj);\n}\n\nexport default class TreeInterpreter {\n  constructor(runtime, globals, toNumber, toString, debug, language) {\n    this.runtime = runtime;\n    this.globals = globals;\n    this.toNumber = toNumber;\n    this.toString = toString;\n    this.debug = debug;\n    this.language = language;\n  }\n\n  search(node, value) {\n    return this.visit(node, value);\n  }\n\n  visit(n, v) {\n    const visitFunctions = {\n      Field: (node, value) => {\n        if (value !== null && isObject(value)) {\n          let field = value[node.name];\n          // fields can be objects with overridden methods. e.g. valueOf\n          // so don't resolve to a function...\n          if (typeof field === 'function') field = undefined;\n          if (field === undefined) {\n            try {\n              this.debug.push(`Failed to find: '${node.name}'`);\n              const available = Object.keys(value).map(a => `'${a}'`).toString();\n              if (available.length) this.debug.push(`Available fields: ${available}`);\n            // eslint-disable-next-line no-empty\n            } catch (e) {}\n            return null;\n          }\n          return field;\n        }\n        return null;\n      },\n\n      Subexpression: (node, value) => {\n        let result = this.visit(node.children[0], value);\n        for (let i = 1; i < node.children.length; i += 1) {\n          result = this.visit(node.children[1], result);\n          if (result === null) return null;\n        }\n        return result;\n      },\n\n      IndexExpression: (node, value) => {\n        const left = this.visit(node.children[0], value);\n        return this.visit(node.children[1], left);\n      },\n\n      Index: (node, value) => {\n        if (isArray(value)) {\n          let index = this.toNumber(this.visit(node.value, value));\n          if (index < 0) {\n            index = value.length + index;\n          }\n          const result = value[index];\n          if (result === undefined) {\n            this.debug.push(`Index ${index} out of range`);\n            return null;\n          }\n          return result;\n        }\n        if (isObject(value)) {\n          const key = this.toString(this.visit(node.value, value));\n          const result = value[key];\n          if (result === undefined) {\n            this.debug.push(`Key ${key} does not exist`);\n            return null;\n          }\n          return result;\n        }\n        this.debug.push(`left side of index expression ${value} is not an array or object.`);\n        return null;\n      },\n\n      Slice: (node, value) => {\n        if (!isArray(value)) return null;\n        const sliceParams = node.children.slice(0).map(\n          param => (param != null ? this.toNumber(this.visit(param, value)) : null),\n        );\n        const computed = this.computeSliceParams(value.length, sliceParams);\n        const [start, stop, step] = computed;\n        const result = [];\n        if (step > 0) {\n          for (let i = start; i < stop; i += step) {\n            result.push(value[i]);\n          }\n        } else {\n          for (let i = start; i > stop; i += step) {\n            result.push(value[i]);\n          }\n        }\n        return result;\n      },\n\n      Projection: (node, value) => {\n      // Evaluate left child.\n        const base = this.visit(node.children[0], value);\n        if (!isArray(base)) return null;\n        const collected = [];\n        base.forEach(b => {\n          const current = this.visit(node.children[1], b);\n          if (current !== null) {\n            collected.push(current);\n          }\n        });\n        return collected;\n      },\n\n      ValueProjection: (node, value) => {\n      // Evaluate left child.\n        const projection = this.visit(node.children[0], value);\n        if (!isObject(getValueOf(projection))) return null;\n        const collected = [];\n        const values = objValues(projection);\n        values.forEach(val => {\n          const current = this.visit(node.children[1], val);\n          if (current !== null) collected.push(current);\n        });\n        return collected;\n      },\n\n      FilterProjection: (node, value) => {\n        const base = this.visit(node.children[0], value);\n        if (!isArray(base)) return null;\n        const filtered = base.filter(b => {\n          const matched = this.visit(node.children[2], b);\n          return !isFalse(matched);\n        });\n\n        const finalResults = [];\n        filtered.forEach(f => {\n          const current = this.visit(node.children[1], f);\n          if (current !== null) finalResults.push(current);\n        });\n        return finalResults;\n      },\n\n      Comparator: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n\n        if (node.name === TOK_EQ) return strictDeepEqual(first, second);\n        if (node.name === TOK_NE) return !strictDeepEqual(first, second);\n        if (node.name === TOK_GT) return first > second;\n        if (node.name === TOK_GTE) return first >= second;\n        if (node.name === TOK_LT) return first < second;\n        if (node.name === TOK_LTE) return first <= second;\n        throw new Error(`Unknown comparator: ${node.name}`);\n      },\n\n      [TOK_FLATTEN]: (node, value) => {\n        const original = this.visit(node.children[0], value);\n        if (!isArray(original)) return null;\n        const merged = [];\n        original.forEach(current => {\n          if (isArray(current)) {\n            merged.push(...current);\n          } else {\n            merged.push(current);\n          }\n        });\n        return merged;\n      },\n\n      Identity: (_node, value) => value,\n\n      MultiSelectList: (node, value) => {\n        if (value === null) return null;\n        return node.children.map(child => this.visit(child, value));\n      },\n\n      MultiSelectHash: (node, value) => {\n        if (value === null) return null;\n        const collected = {};\n        node.children.forEach(child => {\n          collected[child.name] = this.visit(child.value, value);\n        });\n        return collected;\n      },\n\n      OrExpression: (node, value) => {\n        let matched = this.visit(node.children[0], value);\n        if (isFalse(matched)) matched = this.visit(node.children[1], value);\n        return matched;\n      },\n\n      AndExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n\n        if (isFalse(first) === true) return first;\n        return this.visit(node.children[1], value);\n      },\n\n      AddExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        return this.toNumber(first) + this.toNumber(this.visit(node.children[1], value));\n      },\n\n      ConcatenateExpression: (node, value) => {\n        let first = this.visit(node.children[0], value);\n        let second = this.visit(node.children[1], value);\n        first = matchType(getTypeNames(first), [TYPE_STRING, TYPE_ARRAY_STRING], first, 'concatenate', this.toNumber);\n        second = matchType(getTypeNames(second), [TYPE_STRING, TYPE_ARRAY_STRING], second, 'concatenate', this.toNumber);\n        return this.applyOperator(first, second, '&');\n      },\n\n      SubtractExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        return first - this.visit(node.children[1], value);\n      },\n\n      MultiplyExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const second = this.visit(node.children[1], value);\n        return this.applyOperator(first, second, '*');\n      },\n\n      DivideExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        const result = first / this.visit(node.children[1], value);\n        return Number.isFinite(result) ? result : null;\n      },\n\n      PowerExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        return first ** this.visit(node.children[1], value);\n      },\n\n      NotExpression: (node, value) => {\n        const first = this.visit(node.children[0], value);\n        return isFalse(first);\n      },\n\n      Literal: node => node.value,\n\n      Number: node => node.value,\n\n      [TOK_PIPE]: (node, value) => {\n        const left = this.visit(node.children[0], value);\n        return this.visit(node.children[1], left);\n      },\n\n      [TOK_CURRENT]: (_node, value) => value,\n\n      [TOK_GLOBAL]: node => {\n        const result = this.globals[node.name];\n        return result === undefined ? null : result;\n      },\n\n      Function: (node, value) => {\n      // Special case for if()\n      // we need to make sure the results are called only after the condition is evaluated\n      // Otherwise we end up with both results invoked -- which could include side effects\n        if (node.name === 'if') return this.runtime.callFunction(node.name, node.children, value, this);\n        const resolvedArgs = node.children.map(child => this.visit(child, value));\n        return this.runtime.callFunction(node.name, resolvedArgs, value, this);\n      },\n\n      ExpressionReference: node => {\n        const [refNode] = node.children;\n        // Tag the node with a specific attribute so the type\n        // checker verify the type.\n        refNode.jmespathType = TOK_EXPREF;\n        return refNode;\n      },\n    };\n    const fn = n && visitFunctions[n.type];\n    if (!fn) throw new Error(`Unknown/missing node type ${(n && n.type) || ''}`);\n    return fn(n, v);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  computeSliceParams(arrayLength, sliceParams) {\n    function capSliceRange(arrayLen, actual, stp) {\n      let actualValue = actual;\n      if (actualValue < 0) {\n        actualValue += arrayLen;\n        if (actualValue < 0) {\n          actualValue = stp < 0 ? -1 : 0;\n        }\n      } else if (actualValue >= arrayLen) {\n        actualValue = stp < 0 ? arrayLen - 1 : arrayLen;\n      }\n      return actualValue;\n    }\n\n    let [start, stop, step] = sliceParams;\n    if (step === null) {\n      step = 1;\n    } else if (step === 0) {\n      const error = new Error('Invalid slice, step cannot be 0');\n      error.name = 'RuntimeError';\n      throw error;\n    }\n    const stepValueNegative = step < 0;\n\n    if (start === null) {\n      start = stepValueNegative ? arrayLength - 1 : 0;\n    } else {\n      start = capSliceRange(arrayLength, start, step);\n    }\n\n    if (stop === null) {\n      stop = stepValueNegative ? -1 : arrayLength;\n    } else {\n      stop = capSliceRange(arrayLength, stop, step);\n    }\n    return [start, stop, step];\n  }\n\n  applyOperator(first, second, operator) {\n    // TODO: fill in remaining operators\n    if (isArray(first) && isArray(second)) {\n      const len = Math.min(first.length, second.length);\n      const result = [];\n      let i;\n      for (i = 0; i < len; i += 1) {\n        if (isArray(first[i]) || isArray(second[i])) {\n          result.push(this.applyOperator(first[i], second[i], operator));\n        } else if (operator === '*') {\n          result.push(first[i] * second[i]);\n        } else if (operator === '&') {\n          result.push(first[i] + second[i]);\n        } else throw new Error('unimplemented');\n      }\n      for (i = len; i < Math.max(first.length, second.length); i += 1) {\n        // Result of the operator applied with 'null'\n        if (operator === '&') result.push('');\n        else if (operator === '*') result.push(0);\n      }\n      return result;\n    }\n\n    if (isArray(first) || isArray(second)) {\n      const [arr, scalar] = isArray(first) ? [first, second] : [second, first];\n      if (operator === '*') return arr.map(a => this.toNumber(a) * this.toNumber(scalar));\n      if (operator === '&') return arr.map(a => a + scalar);\n    }\n    if (operator === '*') return this.toNumber(first) * this.toNumber(second);\n    if (operator === '&') return first + second;\n    throw new Error(`unimplemented array operator: ${operator}`);\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport tokenDefinitions from './tokenDefinitions';\n\nconst {\n  TOK_UNQUOTEDIDENTIFIER,\n  TOK_QUOTEDIDENTIFIER,\n  TOK_RBRACKET,\n  TOK_RPAREN,\n  TOK_COMMA,\n  TOK_COLON,\n  TOK_CONCATENATE,\n  TOK_RBRACE,\n  TOK_NUMBER,\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_OR,\n  TOK_AND,\n  TOK_ADD,\n  TOK_SUBTRACT,\n  TOK_MULTIPLY,\n  TOK_POWER,\n  TOK_DIVIDE,\n  TOK_EQ,\n  TOK_GT,\n  TOK_LT,\n  TOK_GTE,\n  TOK_LTE,\n  TOK_NE,\n  TOK_FLATTEN,\n  TOK_STAR,\n  TOK_FILTER,\n  TOK_DOT,\n  TOK_NOT,\n  TOK_LBRACE,\n  TOK_LBRACKET,\n  TOK_LPAREN,\n  TOK_LITERAL,\n} = tokenDefinitions;\n\n// The \"&\", \"[\", \"<\", \">\" tokens\n// are not in basicToken because\n// there are two token variants\n// (\"&&\", \"[?\", \"<=\", \">=\").  This is specially handled\n// below.\n\nconst basicTokens = {\n  '.': TOK_DOT,\n  // \"*\": TOK_STAR,\n  ',': TOK_COMMA,\n  ':': TOK_COLON,\n  '{': TOK_LBRACE,\n  '}': TOK_RBRACE,\n  ']': TOK_RBRACKET,\n  '(': TOK_LPAREN,\n  ')': TOK_RPAREN,\n  '@': TOK_CURRENT,\n};\n\nconst globalStartToken = '$';\nconst operatorStartToken = {\n  '<': true,\n  '>': true,\n  '=': true,\n  '!': true,\n};\n\nconst skipChars = {\n  ' ': true,\n  '\\t': true,\n  '\\n': true,\n};\n\nfunction isNum(ch, includeSign) {\n  return (ch >= '0' && ch <= '9')\n             || (includeSign && ch === '-')\n             || (ch === '.');\n}\n\nfunction isAlphaNum(ch) {\n  return (ch >= 'a' && ch <= 'z')\n           || (ch >= 'A' && ch <= 'Z')\n           || (ch >= '0' && ch <= '9')\n           || ch === '_';\n}\n\nfunction isIdentifier(stream, pos) {\n  const ch = stream[pos];\n  // $ is special -- it's allowed to be part of an identifier if it's the first character\n  if (ch === '$') {\n    return stream.length > pos && isAlphaNum(stream[pos + 1]);\n  }\n  // return whether character 'isAlpha'\n  return (ch >= 'a' && ch <= 'z')\n          || (ch >= 'A' && ch <= 'Z')\n          || ch === '_';\n}\n\nexport default class Lexer {\n  constructor(allowedGlobalNames = [], debug = []) {\n    this._allowedGlobalNames = allowedGlobalNames;\n    this.debug = debug;\n  }\n\n  tokenize(stream) {\n    const tokens = [];\n    this._current = 0;\n    let start;\n    let identifier;\n    let token;\n    while (this._current < stream.length) {\n      const prev = tokens.length ? tokens.slice(-1)[0].type : null;\n\n      if (this._isGlobal(prev, stream, this._current)) {\n        tokens.push(this._consumeGlobal(stream));\n      } else if (isIdentifier(stream, this._current)) {\n        start = this._current;\n        identifier = this._consumeUnquotedIdentifier(stream);\n        tokens.push({\n          type: TOK_UNQUOTEDIDENTIFIER,\n          value: identifier,\n          start,\n        });\n      } else if (basicTokens[stream[this._current]] !== undefined) {\n        tokens.push({\n          type: basicTokens[stream[this._current]],\n          value: stream[this._current],\n          start: this._current,\n        });\n        this._current += 1;\n      } else if ((stream[this._current] === '-' && ![TOK_NUMBER, TOK_RPAREN, TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER].includes(prev)) || isNum(stream[this._current], false)) {\n        token = this._consumeNumber(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '[') {\n        // No need to increment this._current.  This happens\n        // in _consumeLBracket\n        token = this._consumeLBracket(stream);\n        tokens.push(token);\n      } else if (stream[this._current] === '\"') {\n        start = this._current;\n        identifier = this._consumeQuotedIdentifier(stream);\n        tokens.push({\n          type: TOK_QUOTEDIDENTIFIER,\n          value: identifier,\n          start,\n        });\n      } else if (stream[this._current] === \"'\") {\n        start = this._current;\n        identifier = this._consumeRawStringLiteral(stream);\n        tokens.push({\n          type: TOK_LITERAL,\n          value: identifier,\n          start,\n        });\n      } else if (stream[this._current] === '`') {\n        start = this._current;\n        const literal = this._consumeLiteral(stream);\n        tokens.push({\n          type: TOK_LITERAL,\n          value: literal,\n          start,\n        });\n      } else if (operatorStartToken[stream[this._current]] !== undefined) {\n        tokens.push(this._consumeOperator(stream));\n      } else if (skipChars[stream[this._current]] !== undefined) {\n        // Ignore whitespace.\n        this._current += 1;\n      } else if (stream[this._current] === '&') {\n        start = this._current;\n        this._current += 1;\n        if (stream[this._current] === '&') {\n          this._current += 1;\n          tokens.push({ type: TOK_AND, value: '&&', start });\n        } else if (prev === TOK_COMMA || prev === TOK_LPAREN) {\n          // based on previous token we'll know if this & is a JMESPath expression-type\n          // or if it's a concatenation operator\n          // if we're a function arg then it's an expression-type\n          tokens.push({ type: TOK_EXPREF, value: '&', start });\n        } else {\n          tokens.push({ type: TOK_CONCATENATE, value: '&', start });\n        }\n      } else if (stream[this._current] === '+') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_ADD, value: '+', start });\n      } else if (stream[this._current] === '-') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_SUBTRACT, value: '-', start });\n      } else if (stream[this._current] === '*') {\n        start = this._current;\n        this._current += 1;\n        // based on previous token we'll know if this asterix is a star -- not a multiply\n        // might be better to list the prev tokens that are valid for multiply?\n        const prevToken = tokens.length && tokens.slice(-1)[0].type;\n        if (tokens.length === 0 || [\n          TOK_LBRACKET,\n          TOK_DOT,\n          TOK_PIPE,\n          TOK_AND,\n          TOK_OR,\n          TOK_COMMA,\n          TOK_COLON,\n        ].includes(prevToken)) {\n          tokens.push({ type: TOK_STAR, value: '*', start });\n        } else {\n          tokens.push({ type: TOK_MULTIPLY, value: '*', start });\n        }\n      } else if (stream[this._current] === '/') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_DIVIDE, value: '/', start });\n      } else if (stream[this._current] === '^') {\n        start = this._current;\n        this._current += 1;\n        tokens.push({ type: TOK_POWER, value: '^', start });\n      } else if (stream[this._current] === '|') {\n        start = this._current;\n        this._current += 1;\n        if (stream[this._current] === '|') {\n          this._current += 1;\n          tokens.push({ type: TOK_OR, value: '||', start });\n        } else {\n          tokens.push({ type: TOK_PIPE, value: '|', start });\n        }\n      } else {\n        const error = new Error(`Unknown character:${stream[this._current]}`);\n        error.name = 'LexerError';\n        throw error;\n      }\n    }\n    return tokens;\n  }\n\n  _consumeUnquotedIdentifier(stream) {\n    const start = this._current;\n    this._current += 1;\n    while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n      this._current += 1;\n    }\n    return stream.slice(start, this._current);\n  }\n\n  _consumeQuotedIdentifier(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    let foundNonAlpha = !isIdentifier(stream, start + 1);\n    while (stream[this._current] !== '\"' && this._current < maxLength) {\n      // You can escape a double quote and you can escape an escape.\n      let current = this._current;\n      if (!isAlphaNum(stream[current])) foundNonAlpha = true;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                             || stream[current + 1] === '\"')) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const val = stream.slice(start, this._current);\n    // Check for unnecessary double quotes.\n    // json-formula uses double quotes to escape characters that don't belong in names names.\n    // e.g. \"purchase-order\".address\n    // If we find a double-quoted entity with spaces or all legal characters, issue a warning\n    try {\n      if (!foundNonAlpha || val.includes(' ')) {\n        this.debug.push(`Suspicious quotes: ${val}`);\n        this.debug.push(`Did you intend a literal? '${val.replace(/\"/g, '')}'?`);\n      }\n    // eslint-disable-next-line no-empty\n    } catch (e) {}\n    return JSON.parse(val);\n  }\n\n  _consumeRawStringLiteral(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (stream[this._current] !== \"'\" && this._current < maxLength) {\n      // You can escape a single quote and you can escape an escape.\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                             || stream[current + 1] === \"'\")) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    this._current += 1;\n    const literal = stream.slice(start + 1, this._current - 1);\n    return literal.replace(\"\\\\'\", \"'\");\n  }\n\n  _consumeNumber(stream) {\n    const start = this._current;\n    this._current += 1;\n    const maxLength = stream.length;\n    while (isNum(stream[this._current], false) && this._current < maxLength) {\n      this._current += 1;\n    }\n    const n = stream.slice(start, this._current);\n    let value;\n    if (n.includes('.')) {\n      value = parseFloat(n);\n    } else {\n      value = parseInt(n, 10);\n    }\n    return { type: TOK_NUMBER, value, start };\n  }\n\n  _consumeLBracket(stream) {\n    const start = this._current;\n    this._current += 1;\n    if (stream[this._current] === '?') {\n      this._current += 1;\n      return { type: TOK_FILTER, value: '[?', start };\n    }\n    if (stream[this._current] === ']') {\n      this._current += 1;\n      return { type: TOK_FLATTEN, value: '[]', start };\n    }\n    return { type: TOK_LBRACKET, value: '[', start };\n  }\n\n  _isGlobal(prev, stream, pos) {\n    // global tokens occur only at the start of an expression\n    if (prev !== null && prev === TOK_DOT) return false;\n    const ch = stream[pos];\n    if (ch !== globalStartToken) return false;\n    // $ is special -- it's allowed to be part of an identifier if it's the first character\n    let i = pos + 1;\n    while (i < stream.length && isAlphaNum(stream[i])) i += 1;\n    const global = stream.slice(pos, i);\n    return this._allowedGlobalNames.includes(global);\n  }\n\n  _consumeGlobal(stream) {\n    const start = this._current;\n    this._current += 1;\n    while (this._current < stream.length && isAlphaNum(stream[this._current])) this._current += 1;\n    const global = stream.slice(start, this._current);\n\n    return { type: TOK_GLOBAL, name: global, start };\n  }\n\n  _consumeOperator(stream) {\n    const start = this._current;\n    const startingChar = stream[start];\n    this._current += 1;\n    if (startingChar === '!') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_NE, value: '!=', start };\n      }\n      return { type: TOK_NOT, value: '!', start };\n    }\n    if (startingChar === '<') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_LTE, value: '<=', start };\n      }\n      return { type: TOK_LT, value: '<', start };\n    }\n    if (startingChar === '>') {\n      if (stream[this._current] === '=') {\n        this._current += 1;\n        return { type: TOK_GTE, value: '>=', start };\n      }\n      return { type: TOK_GT, value: '>', start };\n    }\n    // startingChar is '='\n    if (stream[this._current] === '=') {\n      this._current += 1;\n      return { type: TOK_EQ, value: '==', start };\n    }\n    return { type: TOK_EQ, value: '=', start };\n  }\n\n  _consumeLiteral(stream) {\n    function _looksLikeJSON(str) {\n      if (str === '') return false;\n      if ('[{\"'.includes(str[0])) return true;\n      if (['true', 'false', 'null'].includes(str)) return true;\n\n      if ('-0123456789'.includes(str[0])) {\n        try {\n          JSON.parse(str);\n          return true;\n        } catch (ex) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n\n    this._current += 1;\n    const start = this._current;\n    const maxLength = stream.length;\n    let literal;\n    while (stream[this._current] !== '`' && this._current < maxLength) {\n      // You can escape a literal char or you can escape the escape.\n      let current = this._current;\n      if (stream[current] === '\\\\' && (stream[current + 1] === '\\\\'\n                                             || stream[current + 1] === '`')) {\n        current += 2;\n      } else {\n        current += 1;\n      }\n      this._current = current;\n    }\n    let literalString = stream.slice(start, this._current).trimStart();\n    literalString = literalString.replace('\\\\`', '`');\n    if (_looksLikeJSON(literalString)) {\n      literal = JSON.parse(literalString);\n    } else {\n      // Try to JSON parse it as \"<literal>\"\n      literal = JSON.parse(`\"${literalString}\"`);\n    }\n    // +1 gets us to the ending \"`\", +1 to move on to the next char.\n    this._current += 1;\n    return literal;\n  }\n}\n","import Lexer from './Lexer';\nimport tokenDefinitions from './tokenDefinitions';\n\n/* eslint-disable no-underscore-dangle */\nconst {\n  TOK_LITERAL,\n  TOK_COLON,\n  TOK_EOF,\n  TOK_UNQUOTEDIDENTIFIER,\n  TOK_QUOTEDIDENTIFIER,\n  TOK_RBRACKET,\n  TOK_RPAREN,\n  TOK_COMMA,\n  TOK_CONCATENATE,\n  TOK_RBRACE,\n  TOK_NUMBER,\n  TOK_CURRENT,\n  TOK_GLOBAL,\n  TOK_FIELD,\n  TOK_EXPREF,\n  TOK_PIPE,\n  TOK_OR,\n  TOK_AND,\n  TOK_ADD,\n  TOK_SUBTRACT,\n  TOK_MULTIPLY,\n  TOK_POWER,\n  TOK_DIVIDE,\n  TOK_EQ,\n  TOK_GT,\n  TOK_LT,\n  TOK_GTE,\n  TOK_LTE,\n  TOK_NE,\n  TOK_FLATTEN,\n  TOK_STAR,\n  TOK_FILTER,\n  TOK_DOT,\n  TOK_NOT,\n  TOK_LBRACE,\n  TOK_LBRACKET,\n  TOK_LPAREN,\n} = tokenDefinitions;\n\nconst bindingPower = {\n  [TOK_EOF]: 0,\n  [TOK_UNQUOTEDIDENTIFIER]: 0,\n  [TOK_QUOTEDIDENTIFIER]: 0,\n  [TOK_RBRACKET]: 0,\n  [TOK_RPAREN]: 0,\n  [TOK_COMMA]: 0,\n  [TOK_RBRACE]: 0,\n  [TOK_NUMBER]: 0,\n  [TOK_CURRENT]: 0,\n  [TOK_GLOBAL]: 0,\n  [TOK_FIELD]: 0,\n  [TOK_EXPREF]: 0,\n  [TOK_PIPE]: 1,\n  [TOK_OR]: 2,\n  [TOK_AND]: 3,\n  [TOK_ADD]: 6,\n  [TOK_SUBTRACT]: 6,\n  [TOK_CONCATENATE]: 7,\n  [TOK_MULTIPLY]: 7,\n  [TOK_DIVIDE]: 7,\n  [TOK_POWER]: 7,\n  [TOK_EQ]: 5,\n  [TOK_GT]: 5,\n  [TOK_LT]: 5,\n  [TOK_GTE]: 5,\n  [TOK_LTE]: 5,\n  [TOK_NE]: 5,\n  [TOK_FLATTEN]: 9,\n  [TOK_STAR]: 20,\n  [TOK_FILTER]: 21,\n  [TOK_DOT]: 40,\n  [TOK_NOT]: 45,\n  [TOK_LBRACE]: 50,\n  [TOK_LBRACKET]: 55,\n  [TOK_LPAREN]: 60,\n};\n\nexport default class Parser {\n  constructor(allowedGlobalNames = []) {\n    this._allowedGlobalNames = allowedGlobalNames;\n  }\n\n  parse(expression, debug) {\n    this._loadTokens(expression, debug);\n    this.index = 0;\n    const ast = this.expression(0);\n    if (this._lookahead(0) !== TOK_EOF) {\n      const t = this._lookaheadToken(0);\n      const error = new Error(\n        `Unexpected token type: ${t.type}, value: ${t.value}`,\n      );\n      error.name = 'ParserError';\n      throw error;\n    }\n    return ast;\n  }\n\n  _loadTokens(expression, debug) {\n    const lexer = new Lexer(this._allowedGlobalNames, debug);\n    const tokens = lexer.tokenize(expression);\n    tokens.push({ type: TOK_EOF, value: '', start: expression.length });\n    this.tokens = tokens;\n  }\n\n  expression(rbp) {\n    const leftToken = this._lookaheadToken(0);\n    this._advance();\n    let left = this.nud(leftToken);\n    let currentToken = this._lookahead(0);\n    while (rbp < bindingPower[currentToken]) {\n      this._advance();\n      left = this.led(currentToken, left);\n      currentToken = this._lookahead(0);\n    }\n    return left;\n  }\n\n  _lookahead(number) {\n    return this.tokens[this.index + number].type;\n  }\n\n  _lookaheadToken(number) {\n    return this.tokens[this.index + number];\n  }\n\n  _advance() {\n    this.index += 1;\n  }\n\n  _getIndex() {\n    return this.index;\n  }\n\n  _setIndex(index) {\n    this.index = index;\n  }\n\n  // eslint-disable-next-line consistent-return\n  nud(token) {\n    let left;\n    let right;\n    let expression;\n    let node;\n    let args;\n    switch (token.type) {\n      case TOK_LITERAL:\n        return { type: 'Literal', value: token.value };\n      case TOK_NUMBER:\n        return { type: 'Number', value: token.value };\n      case TOK_UNQUOTEDIDENTIFIER:\n        return { type: 'Field', name: token.value };\n      case TOK_QUOTEDIDENTIFIER:\n        node = { type: 'Field', name: token.value };\n        if (this._lookahead(0) === TOK_LPAREN) {\n          throw new Error('Quoted identifier not allowed for function names.');\n        }\n        return node;\n      case TOK_NOT:\n        right = this.expression(bindingPower.Not);\n        return { type: 'NotExpression', children: [right] };\n      case TOK_STAR:\n        left = { type: 'Identity' };\n        if (this._lookahead(0) === TOK_RBRACKET) {\n          // This can happen in a multiselect,\n          // [a, b, *]\n          right = { type: 'Identity' };\n        } else {\n          right = this._parseProjectionRHS(bindingPower.Star);\n        }\n        return { type: 'ValueProjection', children: [left, right] };\n      case TOK_FILTER:\n        return this.led(token.type, { type: 'Identity' });\n      case TOK_LBRACE:\n        return this._parseMultiselectHash();\n      case TOK_FLATTEN:\n        left = { type: TOK_FLATTEN, children: [{ type: 'Identity' }] };\n        right = this._parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', children: [left, right] };\n      case TOK_LBRACKET:\n        if (this._lookahead(0) === TOK_STAR\n            && this._lookahead(1) === TOK_RBRACKET) {\n          this._advance();\n          this._advance();\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return {\n            type: 'Projection',\n            children: [{ type: 'Identity' }, right],\n          };\n        }\n        return this._parseUnchainedIndexExpression();\n      case TOK_CURRENT:\n        return { type: TOK_CURRENT };\n      case TOK_GLOBAL:\n        return { type: TOK_GLOBAL, name: token.name };\n      case TOK_FIELD:\n        return { type: TOK_FIELD };\n      case TOK_EXPREF:\n        expression = this.expression(bindingPower.Expref);\n        return { type: 'ExpressionReference', children: [expression] };\n      case TOK_LPAREN:\n        args = [];\n        while (this._lookahead(0) !== TOK_RPAREN) {\n          if (this._lookahead(0) === TOK_CURRENT) {\n            expression = { type: TOK_CURRENT };\n            this._advance();\n          } else {\n            expression = this.expression(0);\n          }\n          args.push(expression);\n        }\n        this._match(TOK_RPAREN);\n        return args[0];\n      default:\n        this._errorToken(token);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  led(tokenName, left) {\n    let condition;\n    let right;\n    let name;\n    let args;\n    let expression;\n    let node;\n    let rbp;\n    let leftNode;\n    let rightNode;\n    switch (tokenName) {\n      case TOK_CONCATENATE:\n        right = this.expression(bindingPower.Concatenate);\n        return { type: 'ConcatenateExpression', children: [left, right] };\n      case TOK_DOT:\n        rbp = bindingPower.Dot;\n        if (this._lookahead(0) !== TOK_STAR) {\n          right = this._parseDotRHS(rbp);\n          return { type: 'Subexpression', children: [left, right] };\n        }\n        // Creating a projection.\n        this._advance();\n        right = this._parseProjectionRHS(rbp);\n        return { type: 'ValueProjection', children: [left, right] };\n      case TOK_PIPE:\n        right = this.expression(bindingPower.Pipe);\n        return { type: TOK_PIPE, children: [left, right] };\n      case TOK_OR:\n        right = this.expression(bindingPower.Or);\n        return { type: 'OrExpression', children: [left, right] };\n      case TOK_AND:\n        right = this.expression(bindingPower.And);\n        return { type: 'AndExpression', children: [left, right] };\n      case TOK_ADD:\n        right = this.expression(bindingPower.Add);\n        return { type: 'AddExpression', children: [left, right] };\n      case TOK_SUBTRACT:\n        right = this.expression(bindingPower.Subtract);\n        return { type: 'SubtractExpression', children: [left, right] };\n      case TOK_MULTIPLY:\n        right = this.expression(bindingPower.Multiply);\n        return { type: 'MultiplyExpression', children: [left, right] };\n      case TOK_DIVIDE:\n        right = this.expression(bindingPower.Divide);\n        return { type: 'DivideExpression', children: [left, right] };\n      case TOK_POWER:\n        right = this.expression(bindingPower.Power);\n        return { type: 'PowerExpression', children: [left, right] };\n      case TOK_LPAREN:\n        name = left.name;\n        args = [];\n        while (this._lookahead(0) !== TOK_RPAREN) {\n          expression = this.expression(0);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          }\n          args.push(expression);\n        }\n        this._match(TOK_RPAREN);\n        node = { type: 'Function', name, children: args };\n        return node;\n      case TOK_FILTER:\n        condition = this.expression(0);\n        this._match(TOK_RBRACKET);\n        if (this._lookahead(0) === TOK_FLATTEN) {\n          right = { type: 'Identity' };\n        } else {\n          right = this._parseProjectionRHS(bindingPower.Filter);\n        }\n        return { type: 'FilterProjection', children: [left, right, condition] };\n      case TOK_FLATTEN:\n        leftNode = { type: TOK_FLATTEN, children: [left] };\n        rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n        return { type: 'Projection', children: [leftNode, rightNode] };\n      case TOK_EQ:\n      case TOK_NE:\n      case TOK_GT:\n      case TOK_GTE:\n      case TOK_LT:\n      case TOK_LTE:\n        return this._parseComparator(left, tokenName);\n      case TOK_LBRACKET:\n        if (this._lookahead(0) === TOK_STAR\n            && this._lookahead(1) === TOK_RBRACKET) {\n          this._advance();\n          this._advance();\n          right = this._parseProjectionRHS(bindingPower.Star);\n          return { type: 'Projection', children: [left, right] };\n        }\n        right = this._parseChainedIndexExpression();\n        return this._projectIfSlice(left, right);\n      default:\n        this._errorToken(this._lookaheadToken(0));\n    }\n  }\n\n  _match(tokenType) {\n    if (this._lookahead(0) === tokenType) {\n      this._advance();\n    } else {\n      const t = this._lookaheadToken(0);\n      const error = new Error(`Expected ${tokenType}, got: ${t.type}`);\n      error.name = 'ParserError';\n      throw error;\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _errorToken(token) {\n    const error = new Error(`Invalid token (${\n      token.type}): \"${\n      token.value}\"`);\n    error.name = 'ParserError';\n    throw error;\n  }\n\n  _parseChainedIndexExpression() {\n    const oldIndex = this._getIndex();\n    if (this._lookahead(0) === TOK_COLON) {\n      return this._parseSliceExpression();\n    }\n    // look ahead of the first expression to determine the type\n    const first = this.expression(0);\n    const token = this._lookahead(0);\n    if (token === TOK_COLON) {\n      // now that we know the type revert back to the old position and parse\n      this._setIndex(oldIndex);\n      return this._parseSliceExpression();\n    }\n    this._match(TOK_RBRACKET);\n    return {\n      type: 'Index',\n      value: first,\n    };\n  }\n\n  _parseUnchainedIndexExpression() {\n    const oldIndex = this._getIndex();\n    const firstToken = this._lookahead(0);\n    if (firstToken === TOK_COLON) {\n      const right = this._parseSliceExpression();\n      return this._projectIfSlice({ type: 'Identity' }, right);\n    }\n    const first = this.expression(0);\n    const currentToken = this._lookahead(0);\n    if (currentToken === TOK_COMMA) {\n      this._setIndex(oldIndex);\n      return this._parseMultiselectList();\n    }\n    if (currentToken === TOK_COLON) {\n      this._setIndex(oldIndex);\n      const right = this._parseSliceExpression();\n      return this._projectIfSlice({ type: 'Identity' }, right);\n    }\n    if (firstToken === TOK_NUMBER) {\n      this._match(TOK_RBRACKET);\n      return {\n        type: 'Index',\n        value: first,\n      };\n    }\n    this._setIndex(oldIndex);\n    return this._parseMultiselectList();\n  }\n\n  _projectIfSlice(left, right) {\n    const indexExpr = { type: 'IndexExpression', children: [left, right] };\n    if (right.type === 'Slice') {\n      return {\n        type: 'Projection',\n        children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)],\n      };\n    }\n    return indexExpr;\n  }\n\n  _parseSliceExpression() {\n    // [start:end:step] where each part is optional, as well as the last\n    // colon.\n    const parts = [null, null, null];\n    let index = 0;\n    let currentToken = this._lookahead(0);\n    while (currentToken !== TOK_RBRACKET && index < 3) {\n      if (currentToken === TOK_COLON && index < 2) { // there can't be more than 2 colons\n        index += 1;\n        this._advance();\n      } else {\n        parts[index] = this.expression(0);\n        // check next token to be either colon or rbracket\n        const t = this._lookahead(0);\n        if (t !== TOK_COLON && t !== TOK_RBRACKET) {\n          const error = new Error(`Syntax error, unexpected token: ${\n            t.value}(${t.type})`);\n          error.name = 'Parsererror';\n          throw error;\n        }\n      }\n      currentToken = this._lookahead(0);\n    }\n    this._match(TOK_RBRACKET);\n    return {\n      type: 'Slice',\n      children: parts,\n    };\n  }\n\n  _parseComparator(left, comparator) {\n    const right = this.expression(bindingPower[comparator]);\n    return { type: 'Comparator', name: comparator, children: [left, right] };\n  }\n\n  // eslint-disable-next-line consistent-return\n  _parseDotRHS(rbp) {\n    const lookahead = this._lookahead(0);\n    const exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n    if (exprTokens.indexOf(lookahead) >= 0) {\n      return this.expression(rbp);\n    }\n    if (lookahead === TOK_LBRACKET) {\n      this._match(TOK_LBRACKET);\n      return this._parseMultiselectList();\n    }\n    if (lookahead === TOK_LBRACE) {\n      this._match(TOK_LBRACE);\n      return this._parseMultiselectHash();\n    }\n  }\n\n  _parseProjectionRHS(rbp) {\n    let right;\n    if (bindingPower[this._lookahead(0)] < 10) {\n      right = { type: 'Identity' };\n    } else if (this._lookahead(0) === TOK_LBRACKET) {\n      right = this.expression(rbp);\n    } else if (this._lookahead(0) === TOK_FILTER) {\n      right = this.expression(rbp);\n    } else if (this._lookahead(0) === TOK_DOT) {\n      this._match(TOK_DOT);\n      right = this._parseDotRHS(rbp);\n    } else {\n      const t = this._lookaheadToken(0);\n      const error = new Error(`Sytanx error, unexpected token: ${\n        t.value}(${t.type})`);\n      error.name = 'ParserError';\n      throw error;\n    }\n    return right;\n  }\n\n  _parseMultiselectList() {\n    const expressions = [];\n    while (this._lookahead(0) !== TOK_RBRACKET) {\n      const expression = this.expression(0);\n      expressions.push(expression);\n      if (this._lookahead(0) === TOK_COMMA) {\n        this._match(TOK_COMMA);\n        if (this._lookahead(0) === TOK_RBRACKET) {\n          throw new Error('Unexpected token Rbracket');\n        }\n      }\n    }\n    this._match(TOK_RBRACKET);\n    return { type: 'MultiSelectList', children: expressions };\n  }\n\n  _parseMultiselectHash() {\n    const pairs = [];\n    const identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n    let keyToken; let keyName; let value; let\n      node;\n    if (this._lookahead(0) === TOK_RBRACE) {\n      this._advance();\n      return { type: 'MultiSelectHash', children: [] };\n    }\n    for (;;) {\n      keyToken = this._lookaheadToken(0);\n      if (identifierTypes.indexOf(keyToken.type) < 0) {\n        throw new Error(`Expecting an identifier token, got: ${\n          keyToken.type}`);\n      }\n      keyName = keyToken.value;\n      this._advance();\n      this._match(TOK_COLON);\n      value = this.expression(0);\n      node = { type: 'KeyValuePair', name: keyName, value };\n      pairs.push(node);\n      if (this._lookahead(0) === TOK_COMMA) {\n        this._match(TOK_COMMA);\n      } else if (this._lookahead(0) === TOK_RBRACE) {\n        this._match(TOK_RBRACE);\n        break;\n      }\n    }\n    return { type: 'MultiSelectHash', children: pairs };\n  }\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport dataTypes from './dataTypes';\n\nexport default function openFormulaFunctions(valueOf, toString, toNumber) {\n  return {\n  /**\n   * Return a lower-case string using locale-specific mappings.\n   * e.g. Strings with German lowercase letter '' can be compared to 'ss'\n   * @param {string} input string to casefold\n   * @returns {string} A new string converted to lower case\n   * @function\n   */\n    casefold: {\n      _func: (args, data, interpreter) => {\n        const str = toString(args[0]);\n        return str.toLocaleUpperCase(interpreter.language).toLocaleLowerCase(interpreter.language);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    /**\n     * Returns the logical AND result of all parameters\n     * @param {any} first logical expression -- will be cast to boolean\n     * @param {...any} operand any number of additional expressions\n     * @returns {boolean} The logical result of applying AND to all parameters\n     * @example\n     * and(10 > 8, length('foo') < 5)\n     * // true\n     * @function\n     */\n    and: {\n      _func: resolvedArgs => {\n        let result = !!valueOf(resolvedArgs[0]);\n        resolvedArgs.slice(1).forEach(arg => {\n          result = result && !!valueOf(arg);\n        });\n        return result;\n      },\n      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],\n    },\n    /**\n     * Returns the logical OR result of two parameters\n     * @param {any} first logical expression -- will be cast to boolean\n     * @param {...any} operand any number of additional expressions\n     * @returns {boolean} The logical result of applying OR to all parameters\n     * @example\n     * or((x / 2) == y, (y * 2) == x)\n     * // true\n     * @function\n     */\n    or: {\n      _func: resolvedArgs => {\n        let result = !!valueOf(resolvedArgs[0]);\n        resolvedArgs.slice(1).forEach(arg => {\n          result = result || !!valueOf(arg);\n        });\n        return result;\n      },\n      _signature: [{ types: [dataTypes.TYPE_ANY], variadic: true }],\n    },\n    /**\n     * Compute logical NOT\n     * Note that it is also possible to use the logical and operator: `A && B`\n     * @param {any} - any data type -- will be cast to boolean\n     * @returns {boolean} The logical NOT applied to the input parameter\n     * @example\n     * not(length('bar') > 0)\n     * // false\n     * @function\n     */\n    not: {\n      _func: resolveArgs => !valueOf(resolveArgs[0]),\n      _signature: [{ types: [dataTypes.TYPE_ANY] }],\n    },\n\n    /**\n     * Return constant boolean true value.\n     * Note that expressions may also use the JSON literal true: `` `true` ``\n     * @returns {boolean} True\n     * @function\n     */\n    true: {\n      _func: () => true,\n      _signature: [],\n    },\n\n    /**\n     * Return constant boolean false value.\n     * Note that expressions may also use the JSON literal false: `` `false` ``\n     * @returns {boolean} False\n     * @function\n     */\n    false: {\n      _func: () => false,\n      _signature: [],\n    },\n\n    /**\n     * Return one of two values, depending on a condition\n     * @returns {boolean} True\n     * @param {any} condition logical expression to evaluate\n     * @param {any} result1 if logical condition is true\n     * @param {any} result2 if logical condition is false\n     * @return {any} either result1 or result2\n     * @function\n     */\n    if: {\n      _func: (unresolvedArgs, data, interpreter) => {\n        const conditionNode = unresolvedArgs[0];\n        const leftBranchNode = unresolvedArgs[1];\n        const rightBranchNode = unresolvedArgs[2];\n        const condition = interpreter.visit(conditionNode, data);\n        if (valueOf(condition)) {\n          return interpreter.visit(leftBranchNode, data);\n        }\n        return interpreter.visit(rightBranchNode, data);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] },\n        { types: [dataTypes.TYPE_ANY] }],\n    },\n\n    /**\n     * Returns input `text`, with text `old` replaced by text `new` (when searching from the left).\n     * If `which` parameter is omitted, every occurrence of `old` is replaced with `new`;\n     * If `which` is provided, only that occurrence of `old` is replaced by `new`\n     * (starting the count from 1).\n     * If there is no match, or if `old` has length 0, `text` is returned unchanged.\n     * Note that `old` and `new` may have different lengths. If `which` < 1, return `text` unchanged\n     * @param {string} text\n     * @param {string} old text\n     * @param {string} new text\n     * @param {integer} which (optional) which occurence to replace\n     * @returns {string} replaced string\n     * @function\n     */\n    substitute: {\n      _func: args => {\n        const src = toString(args[0]);\n        const old = toString(args[1]);\n        const replacement = toString(args[2]);\n        // no third parameter? replace all instances\n        if (args.length <= 3) return src.replaceAll(old, replacement);\n        const whch = toNumber(args[3]);\n        if (whch < 1) return src;\n        // find the instance to replace\n        let pos = -1;\n        for (let i = 0; i < whch; i += 1) {\n          pos += 1;\n          const nextFind = src.slice(pos).indexOf(old);\n          // no instance to match 'Which'\n          if (nextFind === -1) return src;\n          pos += nextFind;\n        }\n        return src.slice(0, pos) + src.slice(pos).replace(old, replacement);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    lower: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toLowerCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    upper: {\n      _func: args => {\n        const value = toString(args[0]);\n        return value.toUpperCase();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    exp: {\n      _func: args => {\n        const value = toNumber(args[0]);\n        return Math.exp(value);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    power: {\n      _func: args => {\n        const base = toNumber(args[0]);\n        const power = toNumber(args[1]);\n        return base ** power;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    find: {\n      _func: args => {\n        const query = toString(args[0]);\n        const text = toString(args[1]);\n        const startPos = args.length > 2 ? toNumber(args[2]) : 0;\n        const result = text.indexOf(query, startPos);\n        if (result === -1) {\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    left: {\n      _func: args => {\n        const numEntries = args.length > 1 ? toNumber(args[1]) : 1;\n        if (numEntries < 0) return null;\n        if (args[0] instanceof Array) {\n          return args[0].slice(0, numEntries);\n        }\n        const text = toString(args[0]);\n        return text.substr(0, numEntries);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    right: {\n      _func: args => {\n        const numEntries = args.length > 1 ? toNumber(args[1]) : 1;\n        if (numEntries < 0) return null;\n        if (args[0] instanceof Array) {\n          if (numEntries === 0) return [];\n          return args[0].slice(numEntries * -1);\n        }\n        const text = toString(args[0]);\n        const start = text.length - numEntries;\n        return text.substr(start, numEntries);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    mid: {\n      _func: args => {\n        const startPos = toNumber(args[1]);\n        const numEntries = toNumber(args[2]);\n        if (startPos < 0) return null;\n        if (args[0] instanceof Array) {\n          return args[0].slice(startPos, startPos + numEntries);\n        }\n        const text = toString(args[0]);\n        return text.substr(startPos, numEntries);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING, dataTypes.TYPE_ARRAY] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    proper: {\n      _func: args => {\n        const text = toString(args[0]);\n        const words = text.split(' ');\n        const properWords = words.map(word => word.charAt(0).toUpperCase()\n          + word.slice(1).toLowerCase());\n        return properWords.join(' ');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    rept: {\n      _func: args => {\n        const text = toString(args[0]);\n        const count = toNumber(args[1]);\n        if (count < 0) {\n          return null;\n        }\n        return text.repeat(count);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    replace: {\n      _func: args => {\n        const oldText = toString(args[0]);\n        const startNum = toNumber(args[1]);\n        const numChars = toNumber(args[2]);\n        const newText = toString(args[3]);\n        if (startNum < 0) {\n          return null;\n        }\n\n        const lhs = oldText.substr(0, startNum);\n        const rhs = oldText.substr(startNum + numChars);\n        return lhs + newText + rhs;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    round: {\n      _func: args => {\n        const number = toNumber(args[0]);\n        const digits = toNumber(args[1]);\n        return Math.round(number * 10 ** digits) / 10 ** digits;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    sqrt: {\n      _func: args => {\n        const result = Math.sqrt(toNumber(args[0]));\n        if (Number.isNaN(result)) {\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    stdevp: {\n      _func: args => {\n        const values = args[0] || [];\n        if (values.length === 0) {\n          return null;\n        }\n        const coercedValues = values.map(value => toNumber(value));\n        const mean = coercedValues.reduce((a, b) => a + b, 0) / values.length;\n        const meanSumSquare = coercedValues.reduce((a, b) => a + b * b, 0) / values.length;\n        const result = Math.sqrt(meanSumSquare - mean * mean);\n        if (Number.isNaN(result)) {\n        // this would never happen\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n    stdev: {\n      _func: args => {\n        const values = args[0] || [];\n        if (values.length <= 1) {\n          return null;\n        }\n        const coercedValues = values.map(value => toNumber(value));\n        const mean = coercedValues.reduce((a, b) => a + b, 0) / values.length;\n        const sumSquare = coercedValues.reduce((a, b) => a + b * b, 0);\n        const result = Math.sqrt((sumSquare - values.length * mean * mean) / (values.length - 1));\n        if (Number.isNaN(result)) {\n        // this would never happen\n          return null;\n        }\n        return result;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_NUMBER] },\n      ],\n    },\n    trim: {\n      _func: args => {\n        const text = toString(args[0]);\n        // only removes the space character\n        // other whitespace characters like \\t \\n left intact\n        return text.split(' ').filter(x => x).join(' ');\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    trunc: {\n      _func: args => {\n        const number = toNumber(args[0]);\n        const digits = args.length > 1 ? toNumber(args[1]) : 0;\n        const method = number >= 0 ? Math.floor : Math.ceil;\n        return method(number * 10 ** digits) / 10 ** digits;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    charCode: {\n      _func: args => {\n        const code = toNumber(args[0]);\n        if (!Number.isInteger(code)) {\n          return null;\n        }\n        return String.fromCharCode(code);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    codePoint: {\n      _func: args => {\n        const text = toString(args[0]);\n        if (text.length === 0) {\n          return null;\n        }\n        return text.codePointAt(0);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n    date: {\n      _func: args => {\n        const year = toNumber(args[0]);\n        const month = toNumber(args[1]);\n        const day = toNumber(args[2]);\n        // javascript months starts from 0\n        const jsDate = Date.UTC(year, month - 1, day);\n        return Math.floor(jsDate / 86400000);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    day: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const jsDate = new Date(date * 86400000);\n        return jsDate.getUTCDate();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    month: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const jsDate = new Date(date * 86400000);\n        // javascript months start from 0\n        return jsDate.getUTCMonth() + 1;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    year: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const jsDate = new Date(date * 86400000);\n        return jsDate.getUTCFullYear();\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    time: {\n      _func: args => {\n        const hours = toNumber(args[0]);\n        const minutes = toNumber(args[1]);\n        const seconds = toNumber(args[2]);\n        const time = (hours * 3600 + minutes * 60 + seconds) / 86400;\n        if (time < 0) {\n          return null;\n        }\n        return time - Math.floor(time);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    hour: {\n      _func: args => {\n        const time = toNumber(args[0]);\n        if (time < 0) {\n          return null;\n        }\n        const hour = (time * 86400) / 3600;\n        return hour % 24;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    minute: {\n      _func: args => {\n        const time = toNumber(args[0]);\n        if (time < 0) {\n          return null;\n        }\n        const minute = (time * 1440);\n        return minute % 60;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    second: {\n      _func: args => {\n        const time = toNumber(args[0]);\n        if (time < 0) {\n          return null;\n        }\n        const seconds = (time * 86400);\n        return seconds % 60;\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n      ],\n    },\n    now: {\n      _func: () => {\n        const localDateTime = new Date();\n        const year = localDateTime.getFullYear();\n        const month = localDateTime.getMonth();\n        const date = localDateTime.getDate();\n        const hours = localDateTime.getHours();\n        const minutes = localDateTime.getMinutes();\n        const seconds = localDateTime.getSeconds();\n        return Date.UTC(year, month, date, hours, minutes, seconds) / 86400000;\n      },\n      _signature: [],\n    },\n    today: {\n      _func: () => {\n        const localDateTime = new Date();\n        const year = localDateTime.getFullYear();\n        const month = localDateTime.getMonth();\n        const date = localDateTime.getDate();\n        return Math.floor(Date.UTC(year, month, date) / 86400000);\n      },\n      _signature: [],\n    },\n    weekday: {\n      _func: args => {\n        const date = toNumber(args[0]);\n        const type = args.length > 1 ? toNumber(args[1]) : 1;\n        const jsDate = new Date(date * 86400000);\n        const day = jsDate.getUTCDay();\n        // day is in range [0-7) with 0 mapping to sunday\n        switch (type) {\n          case 1:\n            // range = [1, 7], sunday = 1\n            return day + 1;\n          case 2:\n            // range = [1, 7] sunday = 7\n            return ((day + 6) % 7) + 1;\n          case 3:\n            // range = [0, 6] sunday = 6\n            return (day + 6) % 7;\n          default:\n            return null;\n        }\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_NUMBER] },\n        { types: [dataTypes.TYPE_NUMBER], optional: true },\n      ],\n    },\n    entries: {\n      _func: args => {\n        const obj = valueOf(args[0]);\n        return Object.entries(obj);\n      },\n      _signature: [\n        {\n          types: [\n            dataTypes.TYPE_NUMBER,\n            dataTypes.TYPE_STRING,\n            dataTypes.TYPE_ARRAY,\n            dataTypes.TYPE_OBJECT,\n            dataTypes.TYPE_BOOLEAN,\n          ],\n        },\n      ],\n    },\n    fromEntries: {\n      _func: args => {\n        const array = args[0];\n        return Object.fromEntries(array);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_ARRAY_ARRAY] },\n      ],\n    },\n    split: {\n      _func: args => {\n        const str = toString(args[0]);\n        const separator = toString(args[1]);\n        return str.split(separator);\n      },\n      _signature: [\n        { types: [dataTypes.TYPE_STRING] },\n        { types: [dataTypes.TYPE_STRING] },\n      ],\n    },\n  };\n}\n","/*\nCopyright 2014 James Saryerwinnie\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nNOTICE:\nThis file is substantially modified from the original source taken from:\nhttps://github.com/jmespath/jmespath.js\n\n*/\n\n/* eslint-disable no-underscore-dangle */\nimport dataTypes from './dataTypes';\n\nexport default function functions(\n  interpreter,\n  isObject,\n  isArray,\n  toNumber,\n  getTypeName,\n  valueOf,\n  toString,\n) {\n  const {\n    TYPE_NUMBER,\n    TYPE_ANY,\n    TYPE_STRING,\n    TYPE_ARRAY,\n    TYPE_OBJECT,\n    TYPE_BOOLEAN,\n    TYPE_EXPREF,\n    TYPE_NULL,\n    TYPE_ARRAY_NUMBER,\n    TYPE_ARRAY_STRING,\n  } = dataTypes;\n\n  function createKeyFunction(exprefNode, allowedTypes) {\n    return x => {\n      const current = interpreter.visit(exprefNode, x);\n      if (allowedTypes.indexOf(getTypeName(current)) < 0) {\n        const msg = `TypeError: expected one of ${allowedTypes\n        }, received ${getTypeName(current)}`;\n        throw new Error(msg);\n      }\n      return current;\n    };\n  }\n\n  return {\n    // name: [function, <signature>]\n    // The <signature> can be:\n    //\n    // {\n    //   args: [[type1, type2], [type1, type2]],\n    //   variadic: true|false\n    // }\n    //\n    // Each arg in the arg list is a list of valid types\n    // (if the function is overloaded and supports multiple\n    // types.  If the type is \"any\" then no type checking\n    // occurs on the argument.  Variadic is optional\n    // and if not provided is assumed to be false.\n    abs: {\n      _func: resolvedArgs => Math.abs(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    avg: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        const inputArray = resolvedArgs[0];\n        inputArray.forEach(a => {\n          sum += a;\n        });\n        return sum / inputArray.length;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n    ceil: {\n      _func: resolvedArgs => Math.ceil(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n    contains: {\n      _func: resolvedArgs => valueOf(resolvedArgs[0]).indexOf(valueOf(resolvedArgs[1])) >= 0,\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] },\n        { types: [TYPE_ANY] }],\n    },\n    endsWith: {\n      _func: resolvedArgs => {\n        const searchStr = valueOf(resolvedArgs[0]);\n        const suffix = valueOf(resolvedArgs[1]);\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n      },\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    floor: {\n      _func: resolvedArgs => Math.floor(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_NUMBER] }],\n    },\n\n    length: {\n      _func: resolvedArgs => {\n        const arg = valueOf(resolvedArgs[0]);\n        if (isObject(arg)) return Object.keys(arg).length;\n\n        return isArray(arg) ? arg.length : toString(arg).length;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }],\n    },\n\n    map: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[0];\n        return resolvedArgs[1].map(arg => interpreter.visit(exprefNode, arg));\n      },\n      _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }],\n    },\n\n    max: {\n      _func: resolvedArgs => {\n        if (resolvedArgs[0].length > 0) {\n          const typeName = getTypeName(resolvedArgs[0][0]);\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0].reduce(\n              (prev, cur) => (toNumber(prev) >= toNumber(cur) ? prev : cur),\n              resolvedArgs[0][0],\n            );\n          }\n          return resolvedArgs[0].reduce(\n            (a, b) => (toString(b).localeCompare(toString(a)) < 0 ? a : b),\n            resolvedArgs[0][0],\n          );\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n    },\n\n    merge: {\n      _func: resolvedArgs => {\n        const merged = {};\n        resolvedArgs.forEach(current => {\n          Object.entries(current).forEach(([key, value]) => {\n            merged[key] = value;\n          });\n        });\n        return merged;\n      },\n      _signature: [{ types: [TYPE_OBJECT], variadic: true }],\n    },\n\n    maxBy: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        const resolvedArray = resolvedArgs[0];\n        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n        let maxNumber = -Infinity;\n        let maxRecord;\n        let current;\n        resolvedArray.forEach(arg => {\n          current = keyFunction(arg);\n          if (current > maxNumber) {\n            maxNumber = current;\n            maxRecord = arg;\n          }\n        });\n        return maxRecord;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    sum: {\n      _func: resolvedArgs => {\n        let sum = 0;\n        resolvedArgs[0].forEach(arg => {\n          sum += arg * 1;\n        });\n        return sum;\n      },\n      _signature: [{ types: [TYPE_ARRAY_NUMBER] }],\n    },\n\n    startsWith: {\n      _func: resolvedArgs => valueOf(resolvedArgs[0]).startsWith(valueOf(resolvedArgs[1])),\n      _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }],\n    },\n\n    min: {\n      _func: resolvedArgs => {\n        if (resolvedArgs[0].length > 0) {\n          const typeName = getTypeName(resolvedArgs[0][0]);\n          if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0].reduce(\n              (prev, cur) => (toNumber(prev) <= toNumber(cur) ? prev : cur),\n              resolvedArgs[0][0],\n            );\n          }\n          const elements = resolvedArgs[0];\n          let minElement = elements[0];\n          for (let i = 1; i < elements.length; i += 1) {\n            if (toString(elements[i]).localeCompare(toString(minElement)) < 0) {\n              minElement = elements[i];\n            }\n          }\n          return minElement;\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }],\n    },\n\n    minBy: {\n      _func: resolvedArgs => {\n        const exprefNode = resolvedArgs[1];\n        const resolvedArray = resolvedArgs[0];\n        const keyFunction = createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n        let minNumber = Infinity;\n        let minRecord;\n        let current;\n        resolvedArray.forEach(arg => {\n          current = keyFunction(arg);\n          if (current < minNumber) {\n            minNumber = current;\n            minRecord = arg;\n          }\n        });\n        return minRecord;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    type: {\n      _func: resolvedArgs => ({\n        [TYPE_NUMBER]: 'number',\n        [TYPE_STRING]: 'string',\n        [TYPE_ARRAY]: 'array',\n        [TYPE_OBJECT]: 'object',\n        [TYPE_BOOLEAN]: 'boolean',\n        [TYPE_EXPREF]: 'expref',\n        [TYPE_NULL]: 'null',\n      }[getTypeName(resolvedArgs[0])]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    keys: {\n      _func: resolvedArgs => Object.keys(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    values: {\n      _func: resolvedArgs => Object.values(resolvedArgs[0]),\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    sort: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length > 0) {\n          const normalize = getTypeName(resolvedArgs[0][0]) === TYPE_NUMBER ? toNumber : toString;\n          sortedArray.sort((a, b) => {\n            const va = normalize(a);\n            const vb = normalize(b);\n            if (va < vb) return -1;\n            if (va > vb) return 1;\n            return 0;\n          });\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY, TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }],\n    },\n\n    sortBy: {\n      _func: resolvedArgs => {\n        const sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n          return sortedArray;\n        }\n        const exprefNode = resolvedArgs[1];\n        const requiredType = getTypeName(\n          interpreter.visit(exprefNode, sortedArray[0]),\n        );\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n          throw new Error('TypeError');\n        }\n        // In order to get a stable sort out of an unstable\n        // sort algorithm, we decorate/sort/undecorate (DSU)\n        // by creating a new list of [index, element] pairs.\n        // In the cmp function, if the evaluated elements are\n        // equal, then the index will be used as the tiebreaker.\n        // After the decorated list has been sorted, it will be\n        // undecorated to extract the original elements.\n        const decorated = [];\n        for (let i = 0; i < sortedArray.length; i += 1) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort((a, b) => {\n          const exprA = interpreter.visit(exprefNode, a[1]);\n          const exprB = interpreter.visit(exprefNode, b[1]);\n          if (getTypeName(exprA) !== requiredType) {\n            throw new Error(\n              `TypeError: expected ${requiredType}, received ${\n                getTypeName(exprA)}`,\n            );\n          } else if (getTypeName(exprB) !== requiredType) {\n            throw new Error(\n              `TypeError: expected ${requiredType}, received ${\n                getTypeName(exprB)}`,\n            );\n          }\n          if (exprA > exprB) {\n            return 1;\n          }\n          if (exprA < exprB) {\n            return -1;\n          }\n          // If they're equal compare the items by their\n          // order to maintain relative order of equal keys\n          // (i.e. to get a stable sort).\n          return a[0] - b[0];\n        });\n        // Undecorate: extract out the original list elements.\n        for (let j = 0; j < decorated.length; j += 1) {\n          [, sortedArray[j]] = decorated[j];\n        }\n        return sortedArray;\n      },\n      _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }],\n    },\n\n    join: {\n      _func: resolvedArgs => {\n        const joinChar = resolvedArgs[0];\n        const listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n      },\n      _signature: [\n        { types: [TYPE_STRING] },\n        { types: [TYPE_ARRAY_STRING] },\n      ],\n    },\n\n    reverse: {\n      _func: resolvedArgs => {\n        const originalStr = valueOf(resolvedArgs[0]);\n        const typeName = getTypeName(originalStr);\n        if (typeName === TYPE_STRING) {\n          let reversedStr = '';\n          for (let i = originalStr.length - 1; i >= 0; i -= 1) {\n            reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        }\n        const reversedArray = resolvedArgs[0].slice(0);\n        reversedArray.reverse();\n        return reversedArray;\n      },\n      _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }],\n    },\n\n    toArray: {\n      _func: resolvedArgs => {\n        if (getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n          return resolvedArgs[0];\n        }\n        return [resolvedArgs[0]];\n      },\n\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    toString: {\n      _func: resolvedArgs => {\n        if (getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n          return resolvedArgs[0];\n        }\n        return JSON.stringify(resolvedArgs[0]);\n      },\n\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    toNumber: {\n      _func: resolvedArgs => {\n        const typeName = getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_NUMBER) {\n          return resolvedArgs[0];\n        }\n        if (typeName === TYPE_STRING) {\n          return toNumber(resolvedArgs[0]);\n        }\n        return null;\n      },\n      _signature: [{ types: [TYPE_ANY] }],\n    },\n\n    notNull: {\n      _func: resolvedArgs => resolvedArgs.find(arg => getTypeName(arg) !== TYPE_NULL) || null,\n      _signature: [{ types: [TYPE_ANY], variadic: true }],\n    },\n  };\n}\n","/* eslint-disable no-underscore-dangle */\nimport TreeInterpreter from './TreeInterpreter';\nimport Parser from './Parser';\nimport dataTypes from './dataTypes';\nimport { matchType, getTypeName, getTypeNames } from './matchType';\nimport openFormulaFunctions from './openFormulaFunctions';\nimport functions from './functions';\nimport {\n  isArray, isObject, strictDeepEqual, getValueOf,\n} from './utils';\n\n// Type constants used to define functions.\nconst {\n  TYPE_CLASS,\n} = dataTypes;\n\nfunction JsonFormula() {\n  let toNumber;\n\n  function getToNumber(stringToNumber, debug = []) {\n    return value => {\n      const n = getValueOf(value); // in case it's an object that implements valueOf()\n      if (n === null) return null;\n      if (n instanceof Array) {\n        debug.push('Converted array to zero');\n        return 0;\n      }\n      const type = typeof n;\n      if (type === 'number') return n;\n      if (type === 'string') return stringToNumber(n, debug);\n      if (type === 'boolean') return n ? 1 : 0;\n      debug.push('Converted object to zero');\n      return 0;\n    };\n  }\n\n  function toString(a) {\n    if (a === null || a === undefined) return '';\n    return Object.getPrototypeOf(a).toString.call(a);\n  }\n\n  function isClass(obj) {\n    if (obj === null) return false;\n    if (Array.isArray(obj)) return false;\n    return typeof obj === 'object' && obj.constructor.name !== 'Object';\n  }\n\n  function matchClass(arg, expectedList) {\n    return isClass(arg) && expectedList.includes(TYPE_CLASS);\n  }\n\n  class Runtime {\n    addFunctions(customFunctions = {}) {\n      this.functionTable = {\n        ...functions(\n          this._interpreter,\n          isObject,\n          isArray,\n          toNumber,\n          getTypeName,\n          getValueOf,\n          toString,\n        ),\n        ...openFormulaFunctions(getValueOf, toString, toNumber),\n        ...customFunctions,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    _validateArgs(argName, args, signature) {\n      // Validating the args requires validating\n      // the correct arity and the correct type of each arg.\n      // If the last argument is declared as variadic, then we need\n      // a minimum number of args to be required.  Otherwise it has to\n      // be an exact amount.\n      if (signature.length === 0) {\n        return;\n      }\n      let pluralized;\n      if (signature[signature.length - 1].variadic) {\n        if (args.length < signature.length) {\n          pluralized = signature.length === 1 ? ' argument' : ' arguments';\n          throw new Error(`ArgumentError: ${argName}() `\n          + `takes at least${signature.length}${pluralized\n          } but received ${args.length}`);\n        }\n      } else if (args.length !== signature.length && !signature[signature.length - 1].optional) {\n        pluralized = signature.length === 1 ? ' argument' : ' arguments';\n        throw new Error(`ArgumentError: ${argName}() `\n        + `takes ${signature.length}${pluralized\n        } but received ${args.length}`);\n      }\n      let currentSpec;\n      let actualType;\n      const limit = Math.min(signature.length, args.length);\n      for (let i = 0; i < limit; i += 1) {\n        currentSpec = signature[i].types;\n        // First check for a match using matchClass\n        // this check will not call valueOf or toString on the object, and so\n        // will not trigger a dependency\n        if (!matchClass(args[i], currentSpec)) {\n          actualType = getTypeNames(args[i]);\n          // eslint-disable-next-line no-param-reassign\n          args[i] = matchType(actualType, currentSpec, args[i], argName, toNumber);\n        }\n      }\n    }\n\n    callFunction(name, resolvedArgs, data, interpreter) {\n      const functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) throw new Error(`Unknown function: ${name}()`);\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs, data, interpreter);\n    }\n  }\n\n  function compile(stream, allowedGlobalNames = [], debug = []) {\n    let ast;\n    try {\n      const parser = new Parser(allowedGlobalNames);\n      ast = parser.parse(stream, debug);\n    } catch (e) {\n      debug.push(e.toString());\n      throw e;\n    }\n    return ast;\n  }\n\n  function search(node, data, globals, customFunctions, stringToNumberFn, debug = [], language = 'en-US') {\n    // This needs to be improved.  Both the interpreter and runtime depend on\n    // each other.  The runtime needs the interpreter to support exprefs.\n    // There's likely a clean way to avoid the cyclic dependency.\n    const runtime = new Runtime(customFunctions);\n    runtime.debug = debug;\n    const defaultStringToNumber = (str => {\n      const n = +str;\n      return Number.isNaN(n) ? 0 : n;\n    });\n    toNumber = getToNumber(stringToNumberFn || defaultStringToNumber, debug);\n    const interpreter = new TreeInterpreter(runtime, globals, toNumber, toString, debug, language);\n    runtime._interpreter = interpreter;\n    runtime.addFunctions(customFunctions);\n\n    try {\n      return interpreter.search(node, data);\n    } catch (e) {\n      debug.push(e.message || e.toString());\n      throw e;\n    }\n  }\n  this.compile = compile;\n  this.search = search;\n  this.strictDeepEqual = strictDeepEqual;\n}\n\nexport default new JsonFormula();\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport jmespath from './jmespath/jmespath';\n\nexport class Formula {\n  constructor(\n    expression,\n    customFunctions = {},\n    stringToNumber = null,\n    allowedGlobalNames = [],\n    debug = [],\n    language = 'en-US',\n  ) {\n    this.expression = expression;\n    this.customFunctions = customFunctions;\n    this.stringToNumber = stringToNumber;\n    this.node = jmespath.compile(expression, allowedGlobalNames, debug);\n    this.debug = debug;\n    this.language = language;\n  }\n\n  search(json, globals) {\n    return jmespath.search(\n      this.node,\n      json,\n      globals,\n      { ...this.customFunctions },\n      this.stringToNumber,\n      this.debug,\n      this.language,\n    );\n  }\n}\n\n// eslint-disable-next-line import/prefer-default-export\nexport function jsonFormula(\n  json,\n  globals,\n  expression,\n  customFunctions = {},\n  stringToNumber = null,\n  debug = [],\n  language = 'en-US',\n) {\n  const formula = new Formula(\n    expression,\n    customFunctions,\n    stringToNumber,\n    Object.keys(globals),\n    debug,\n    language,\n  );\n  return formula.search(\n    json,\n    globals,\n    { ...customFunctions },\n    stringToNumber,\n    debug,\n    language,\n  );\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* eslint-disable no-param-reassign */\n/* eslint-disable max-classes-per-file */\n/* eslint-disable class-methods-use-this */\n/*\n    Field class allows objects to evaluate correctly according to context.\n    - if used in an expression, will return a value or string.\n    - for JSON.stringify() returns a scalar\n    - BUT also allows explicit access to properties. e.g. field.required, field.name etc.\n\n    Should allow us to eliminate getFieldProperty()\n  */\n\nfunction createField(name, value, readonly = false, required = true) {\n  class Field {\n    valueOf() { return value; }\n\n    toString() { return value.toString(); }\n\n    toJSON() { return value; }\n\n    // Use getters and scope variables so that the children are not enumerable\n    get '$value'() { return value; }\n\n    get '$name'() { return name; }\n\n    get '$readonly'() { return readonly; }\n\n    get '$required'() { return required; }\n  }\n  const newField = new Field();\n  return newField;\n}\n\nfunction createFields(parent, childref, child) {\n  const result = [];\n  if (child instanceof Array) {\n    parent[childref] = [];\n    child.forEach((item, index) => {\n      const fields = createFields(parent[childref], index, item);\n      result.push(...fields);\n    });\n  } else if (child !== null && typeof child === 'object') {\n    parent[childref] = {};\n    Object.keys(child).forEach(k => {\n      const fields = createFields(parent[childref], k, child[k]);\n      result.push(...fields);\n    });\n  } else {\n    // eslint-disable-next-line no-param-reassign\n    const field = createField(childref, child);\n    parent[childref] = field;\n    result.push(field);\n  }\n  return result;\n}\n\nexport default class Form {\n  constructor(fieldData, dataRoot) {\n    this.fieldData = fieldData;\n    this.allFields = createFields(fieldData, 'data', dataRoot);\n    Object.keys(fieldData.data).forEach(k => {\n      this[k] = fieldData.data[k];\n    });\n  }\n\n  valueOf() { return this.fieldData; }\n\n  stringify() { return JSON.stringify(this.fieldData.data, null, 2); }\n\n  get '$fields'() { return this.allFields; }\n}\n","/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nexport default function stringToNumber(n, debug) {\n  const ret = +(n.replace(/\\$/, ''));\n  if (Number.isNaN(ret)) {\n    if (debug) debug.push(`Failed to convert ${n} to number`);\n    return 0;\n  }\n  return ret;\n}\n","/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/* global window, document, fetch */\nimport { jsonFormula } from './json-formula';\nimport Form from './Form';\nimport stringToNumber from './jmespath/stringToNumber';\n\nwindow.addEventListener('load', () => {\n  const dataElement = document.getElementById('data');\n  const expression = document.getElementById('expression');\n  const result = document.getElementById('result');\n  const debug = document.getElementById('debug');\n\n  const d = window.localStorage.getItem('data');\n  if (d) dataElement.value = d;\n  const exp = window.localStorage.getItem('expression');\n  if (exp) expression.value = exp;\n\n  function run() {\n    // save for next time...\n    window.localStorage.setItem('data', dataElement.value);\n    window.localStorage.setItem('expression', expression.value);\n    const input = expression.value;\n    const useFields = document.getElementById('use-fields').checked;\n    let root = null;\n    const fieldData = {};\n    let jsonData;\n    try {\n      jsonData = JSON.parse(dataElement.value);\n      if (useFields) {\n        root = new Form(fieldData, jsonData);\n      }\n    } catch (e) {\n      result.value = e.toString();\n      return;\n    }\n\n    const debugInfo = [];\n    try {\n      const jsonResult = jsonFormula(\n        useFields ? fieldData.data : jsonData,\n        { $form: root, $: {} },\n        input,\n        true,\n        stringToNumber,\n        debugInfo,\n      );\n      debug.innerHTML = debugInfo.join('\\n');\n      let r = jsonResult;\n      if (jsonResult !== null && jsonResult !== undefined) {\n        r = Object.getPrototypeOf(jsonResult).valueOf.call(jsonResult);\n      }\n      if (typeof r === 'object') {\n        result.value = JSON.stringify(r, null, 2);\n      } else {\n        result.value = r;\n      }\n    } catch (e) {\n      result.value = e.toString();\n      debug.innerHTML = debugInfo.join('\\n');\n    }\n  }\n\n  dataElement.addEventListener('blur', run);\n  expression.addEventListener('blur', run);\n  run();\n\n  fetch('../antlr/JSONFormula.g4').then(r => {\n    r.text().then(g4 => {\n      document.getElementById('grammar-out').innerHTML = g4;\n    });\n  });\n});\n"],"names":["exports","Symbol","toStringTag","Object","defineProperty","value","TYPE_NUMBER","TYPE_STRING","TYPE_ARRAY","TYPE_BOOLEAN","TYPE_NULL","TYPE_ARRAY_NUMBER","TYPE_ARRAY_STRING","TOK_EXPREF","tokenDefinitions","TYPE_NAME_TABLE","getTypeName","inputObj","useValueOf","obj","getPrototypeOf","valueOf","call","prototype","toString","jmespathType","getTypeNames","matchType","actuals","expectedList","argValue","context","toNumber","actual","findIndex","type","wrongType","length","includes","forEach","a","Array","Error","expected","find","e","subtype","returnArray","slice","i","indexType","isArray","isObject","getValueOf","map","strictDeepEqual","lhs","rhs","first","second","keysSeen","key","hasOwnProperty","key2","isFalse","TreeInterpreter","runtime","globals","debug","language","this","node","visit","n","v","visitFunctions","Field","field","name","undefined","push","available","keys","Subexpression","result","children","IndexExpression","left","Index","index","Slice","sliceParams","param","computeSliceParams","start","stop","step","Projection","base","collected","b","current","ValueProjection","projection","values","val","FilterProjection","filtered","filter","finalResults","f","Comparator","original","merged","_node","child","matched","applyOperator","Number","isFinite","callFunction","resolvedArgs","refNode","fn","arrayLength","capSliceRange","arrayLen","stp","actualValue","error","stepValueNegative","operator","len","Math","min","max","arr","scalar","TOK_UNQUOTEDIDENTIFIER","TOK_QUOTEDIDENTIFIER","TOK_RPAREN","TOK_COMMA","TOK_COLON","TOK_NUMBER","TOK_PIPE","TOK_OR","TOK_AND","TOK_DOT","TOK_LBRACKET","TOK_LPAREN","TOK_LITERAL","basicTokens","operatorStartToken","skipChars","isNum","ch","includeSign","isAlphaNum","isIdentifier","stream","pos","Lexer","allowedGlobalNames","_allowedGlobalNames","identifier","token","tokens","_current","prev","_isGlobal","_consumeGlobal","_consumeUnquotedIdentifier","_consumeNumber","_consumeLBracket","_consumeQuotedIdentifier","_consumeRawStringLiteral","literal","_consumeLiteral","_consumeOperator","prevToken","maxLength","foundNonAlpha","replace","JSON","parse","parseFloat","parseInt","global","startingChar","literalString","trimStart","str","ex","_looksLikeJSON","TOK_EOF","TOK_RBRACKET","TOK_CONCATENATE","TOK_RBRACE","TOK_CURRENT","TOK_GLOBAL","TOK_FIELD","TOK_SUBTRACT","TOK_MULTIPLY","TOK_POWER","TOK_DIVIDE","TOK_FLATTEN","TOK_STAR","TOK_FILTER","TOK_LBRACE","bindingPower","Parser","expression","_loadTokens","ast","_lookahead","t","_lookaheadToken","tokenize","rbp","leftToken","_advance","nud","currentToken","led","number","args","Not","_parseProjectionRHS","Star","_parseMultiselectHash","Flatten","_parseUnchainedIndexExpression","Expref","_match","_errorToken","tokenName","condition","right","Concatenate","Dot","_parseDotRHS","Pipe","Or","And","Add","Subtract","Multiply","Divide","Power","Filter","_parseComparator","_parseChainedIndexExpression","_projectIfSlice","tokenType","oldIndex","_getIndex","_parseSliceExpression","_setIndex","firstToken","_parseMultiselectList","indexExpr","parts","comparator","lookahead","indexOf","expressions","keyToken","keyName","pairs","identifierTypes","openFormulaFunctions","casefold","_func","data","interpreter","toLocaleUpperCase","toLocaleLowerCase","_signature","types","and","arg","variadic","or","not","resolveArgs","true","false","if","unresolvedArgs","conditionNode","leftBranchNode","rightBranchNode","substitute","src","old","replacement","replaceAll","whch","nextFind","optional","lower","toLowerCase","upper","toUpperCase","exp","power","query","text","startPos","numEntries","substr","mid","proper","split","word","charAt","join","rept","count","repeat","oldText","startNum","numChars","newText","round","digits","sqrt","isNaN","stdevp","coercedValues","mean","reduce","meanSumSquare","stdev","sumSquare","trim","x","trunc","floor","ceil","charCode","code","isInteger","String","fromCharCode","codePoint","codePointAt","date","year","month","day","jsDate","Date","UTC","getUTCDate","getUTCMonth","getUTCFullYear","time","hour","minute","now","localDateTime","getFullYear","getMonth","getDate","hours","getHours","minutes","getMinutes","seconds","getSeconds","today","weekday","getUTCDay","entries","fromEntries","array","separator","functions","createKeyFunction","exprefNode","allowedTypes","msg","abs","avg","sum","inputArray","contains","endsWith","searchStr","suffix","cur","localeCompare","merge","maxBy","maxRecord","resolvedArray","keyFunction","maxNumber","startsWith","elements","minElement","minBy","minRecord","minNumber","Infinity","sort","sortedArray","normalize","va","vb","sortBy","requiredType","decorated","exprA","exprB","j","joinChar","reverse","originalStr","reversedStr","reversedArray","toArray","stringify","typeName","notNull","getToNumber","stringToNumber","Runtime","customFunctions","functionTable","_interpreter","argName","signature","pluralized","currentSpec","actualType","limit","constructor","functionEntry","_validateArgs","compile","parser","search","stringToNumberFn","defaultStringToNumber","addFunctions","message","Formula","jmespath","json","createFields","parent","childref","item","fields","k","readonly","required","createField","Form","fieldData","dataRoot","allFields","ret","window","addEventListener","dataElement","document","getElementById","d","localStorage","getItem","run","setItem","jsonData","input","useFields","checked","root","debugInfo","jsonResult","jsonFormula","$form","$","innerHTML","r","fetch","then","g4"],"sourceRoot":""}