== abs

*abs(num) ⇒ number*

Find the absolute value of the provided argument `value`.

*Returns*: number - the absolute value of the `value` argument

[cols=",,",options="header",]
|===
|Param |Type |Description
|num |number |a numeric value
|===

*Example*

[source,js]
----
abs(-1) // returns 1
----

== and

*and(firstOperand, […additionalOperands]) ⇒ boolean*

Finds the logical AND result of all parameters. If the parameters are
not boolean they will be cast to boolean as per the type coercion rules

*Returns*: boolean - The logical result of applying AND to all
parameters

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|firstOperand |any |logical expression
|[…additionalOperands] |any |any number of additional expressions
|===

*Example*

[source,js]
----
and(10 > 8, length("foo") < 5) // returns true
and(`null`, length("foo") < 5) // returns false
----

== avg

*avg(elements) ⇒ number*

Finds the average of the elements in an array. An empty array will
return an average of `null`.

*Returns*: number - average value

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|elements |Array.<number> |array of numeric values
|===

*Example*

[source,js]
----
avg(`[]`) // returns null
avg([1, 2, 3]) // returns 2
----

== casefold

*casefold(input) ⇒ string*

Generates a lower-case string of the `input` string using
locale-specific mappings. e.g. Strings with German letter ß can be
compared to ``ss''

*Returns*: string - A new string converted to lower case

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |string |string to casefold
|===

*Example*

[source,js]
----
casefold("AbC") // returns "abc"
----

== charCode

*charCode(codePoint) ⇒ number*

Create a string created from the specified code unit.

*Returns*: number - A string from a given code point

[cols=",,",options="header",]
|===
|Param |Type |Description
|codePoint |integer |unicode code point value
|===

*Example*

[source,js]
----
charCode(65) // "A"
charCode(65) == "\u0041" // true
----

== ceil

*ceil(num) ⇒ integer*

Finds the next highest integer value of the argument `num` by rounding
up if necessary.

*Returns*: integer - The smallest integer greater than or equal to num

[cols=",,",options="header",]
|===
|Param |Type |Description
|num |number |numeric value
|===

*Example*

[source,js]
----
ceil(10) // returns 10
ceil(10.4) // return 11
----

== codePoint

*codePoint(str) ⇒ integer*

Retrieve the code point from the first character of a string

*Returns*: integer - unicode code point value

[cols=",,",options="header",]
|===
|Param |Type |Description
|str |string |source string
|===

*Example*

[source,js]
----
codePoint("ABC") // 65
----

== contains

*contains(subject, search) ⇒ boolean*

Determines if the given `subject` contains the `search` string. If
`subject` is an array, this function returns true if one of the elements
in the array is equal to the provided `search` value. If `subject` is a
string, this function returns true if the string contains the `search`
value.

*Returns*: boolean - true if found

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |array {vbar} string |the subject in which the element has to
be searched

|search |string {vbar} boolean {vbar} number {vbar} date |element to
search
|===

*Example*

[source,js]
----
contains([1, 2, 3, 4], 2) // returns true
contains([1, 2, 3, 4], -1) // returns false
contains("Abcd", "d") // returns true
contains("Abcd", "x") // returns false
----

== datedif

*datedif(start_date, end_date, unit) ⇒ integer*

Return difference between two date values. The measurement of the
difference is determined by the `unit` parameter. One of:

* `y` the number of whole years between start_date and end_date
* `m` the number of whole months between start_date and end_date.
* `d` the number of days between start_date and end_date
* `md` the number of days between start_date and end_date after
subtracting whole months.
* `ym` the number of whole months between start_date and end_date after
subtracting whole years.
* `yd` the number of days between start_date and end_date, assuming
start_date and end_date were no more than one year apart

*Returns*: integer - The number of days/months/years difference

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|start_date |number |The starting date. Date/time values can be
generated using the <<_datetime>>, <<_today>>,
<<_now>> and <<_time>> functions.

|end_date |number |The end date – must be greater or equal to
start_date.

|unit |string |
|===

*Example*

[source,js]
----
datedif(datetime(2001, 1, 1), datetime(2003, 1, 1), "y") // returns 2
datedif(datetime(2001, 6, 1), datetime(2003, 8, 15), "D") // returns 805
// 805 days between June 1, 2001, and August 15, 2003
datedif(datetime(2001, 6, 1), datetime(2003, 8, 15), "YD") // returns 75
// 75 days between June 1 and August 15, ignoring the years of the dates (75)
----

== datetime

*datetime(year, month, day, [hours], [minutes], [seconds],
[milliseconds]) ⇒ number*

Return a date/time value.

*Returns*: number - A date/time numeric value to be used with other
date/time functions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|year |integer | |The year to use for date construction. Values from 0
to 99 map to the years 1900 to 1999. All other values are the actual
year

|month |integer | |The month: beginning with 1 for January to 12 for
December.

|day |integer | |The day of the month.

|[hours] |integer |0 |Integer value between 0 and 23 representing the
hour of the day.

|[minutes] |integer |0 |Integer value representing the minute segment of
a time.

|[seconds] |integer |0 |Integer value representing the second segment of
a time.

|[milliseconds] |integer |0 |Integer value representing the millisecond
segment of a time.
|===

*Example*

[source,js]
----
datetime(2010, 10, 10) // returns representation of October 10, 2010
datetime(2010, 2, 28) // returns representation of February 28, 2010
----

== day

*day(date) ⇒ integer*

Finds the day of a date

*Returns*: integer - The day of the month ranging from 1 to 31.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|date |number |of the day you are trying to find. Date/time values can
be generated using the <<_datetime>>, <<_today>>,
<<_now>> and <<_time>> functions.
|===

*Example*

[source,js]
----
day(datetime(2008,5,23)) // returns 23
----

== deepScan

*deepScan(object, name) ⇒ Array.<any>*

Searches a nested hierarchy of objects to return an array of key values
that match a `name`. The name can be either a key into an object or an
array index. This is similar to the JSONPath deep scan operator (..)

*Returns*: Array.<any> - The array of matched elements

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|object |object {vbar} array |The starting object or array where we
start the search

|name |string {vbar} integer |The name (or index position) of the
elements to find
|===

*Example*

[source,js]
----
deepScan({a : {b1 : {c : 2}, b2 : {c : 3}}}, "c") // returns [2, 3]
----

== endsWith

*endsWith(subject, suffix) ⇒ boolean*

Determines if the `subject` string ends with a specific `suffix`

*Returns*: boolean - true if the `suffix` value is at the end of the
`subject`

[cols=",,",options="header",]
|===
|Param |Type |Description
|subject |string |source string in which to search
|suffix |string |search string
|===

*Example*

[source,js]
----
endsWith("Abcd", "d") // returns true
endsWith("Abcd", "A") // returns false
----

== entries

*entries(obj) ⇒ Array.<any>*

Returns an array of `[key, value]` pairs from an object. The
`fromEntries()` function may be used to convert the array back to an
object.

*Returns*: Array.<any> - an array of arrays where each child array has
two elements representing the key and value of a pair

[cols=",,",options="header",]
|===
|Param |Type |Description
|obj |object |source object
|===

*Example*

[source,js]
----
entries({a: 1, b: 2}) // returns [["a", 1], ["b", 2]]
----

== eomonth

*eomonth(startDate, monthAdd) ⇒ integer*

Finds the serial number of the end of a month, given `startDate` plus
`monthAdd` months

*Returns*: integer - the number of days in the computed month

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|startDate |number |The base date to start from. Date/time values can be
generated using the <<_datetime>>, <<_today>>,
<<_now>> and <<_time>> functions.

|monthAdd |integer |Number of months to add to start date
|===

*Example*

[source,js]
----
eomonth(datetime(2011, 1, 1), 1) | [month(@), day(@)] // returns [2, 28]
eomonth(datetime(2011, 1, 1), -3) | [month(@), day(@)] // returns [10, 31]
----

== exp

*exp(x) ⇒ number*

Finds e (the base of natural logarithms) raised to a power x. (i.e. ex)

*Returns*: number - e (the base of natural logarithms) raised to a power
x

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|x |number |A numeric expression representing the power of e.
|===

*Example*

[source,js]
----
exp(10) // returns 22026.465794806718
----

== false

*false() ⇒ boolean*

Return constant boolean false value. Note that expressions may also use
the JSON literal false: `\'false\'`

*Returns*: boolean - constant boolean value `false` +

== find

*find(query, text, [start]) ⇒ integer {vbar} <<_null>>*

finds and returns the index of query in text from a start position

*Returns*: integer {vbar} <<_null>> - The position of the found
string, null if not found.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|query |string | |string to search
|text |string | |text to be searched
|[start] |integer |0 |zero-based position to start searching
|===

*Example*

[source,js]
----
find("m", "abm") // returns 2
find("M", "abMcdM", 3) // returns 5
find("M", "ab") // returns `null`
find("M", "abMcdM", 2) // returns 2
----

== fromEntries

*fromEntries(pairs) ⇒ object*

returns an object by transforming a list of key-value `pairs` into an
object. `fromEntries()` is the inverse operation of `entries()`.

*Returns*: object - An object constructed from the provided key-value
pairs

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|pairs |Array.<any> |A nested array of key-value pairs to create the
object from
|===

*Example*

[source,js]
----
fromEntries([["a", 1], ["b", 2]]) // returns {a: 1, b: 2}
----

== floor

*floor(num) ⇒ integer*

Calculates the next lowest integer value of the argument `num` by
rounding down if necessary.

*Returns*: integer - The largest integer smaller than or equal to num

[cols=",,",options="header",]
|===
|Param |Type |Description
|num |number |numeric value
|===

*Example*

[source,js]
----
floor(10.4) // returns 10
floor(10) // returns 10
----

== hour

*hour(date) ⇒ integer*

Extract the hour from a date/time representation

*Returns*: integer - value between 0 and 23

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|date |number |The datetime/time for which the hour is to be returned.
Date/time values can be generated using the <<_datetime>>,
<<_today>>, <<_now>> and <<_time>> functions.
|===

*Example*

[source,js]
----
hour(datetime(2008,5,23,12, 0, 0)) // returns 12
hour(time(12, 0, 0)) // returns 12
----

== if

*if(condition, result1, result2) ⇒ any*

Return one of two values `result1` or `result2`, depending on the
`condition`

*Returns*: any - either result1 or result2

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|condition |any |boolean result of a logical expression
|result1 |any |if condition is true
|result2 |any |if condition is false
|===

*Example*

[source,js]
----
if(true(), 1, 2) // returns 1
if(false(), 1, 2) // returns 2
----

== join

*join(glue, stringsarray) ⇒ string*

Combines all the elements from the provided array, joined together using
the `glue` argument as a separator between each.

*Returns*: string - String representation of the array

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|glue |string |

|stringsarray |Array.<string> |array of strings or values that can be
coerced to strings
|===

*Example*

[source,js]
----
join(",", ["a", "b", "c"]) // returns "a,b,c"
join(" and ", ["apples", "bananas"]) // returns "apples and bananas"
----

== keys

*keys(obj) ⇒ array*

Generates an array of the keys of the input object. If the object is
null, the value return an empty array

*Returns*: array - the array of all the key names

[cols=",,",options="header",]
|===
|Param |Type |Description
|obj |object |the object to examine
|===

*Example*

[source,js]
----
keys({a : 3, b : 4}) // returns ["a", "b"]
----

== left

*left(subject, [elements]) ⇒ string {vbar} array*

Return a substring from the start of a string or the left-most elements
of an array

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|subject |string {vbar} array | |The source text/array of
characters/elements

|[elements] |integer |1 |number of elements to pick
|===

*Example*

[source,js]
----
left("Sale Price", 4) // returns "Sale"
left("Sweden") // returns "S"
left([4, 5, 6], 2) // returns [4, 5]
----

== length

*length(subject) ⇒ integer*

Calculates the length of the input argument based on types:

* string: returns the number of code points
* array: returns the number of array elements
* object: returns the number of key-value pairs

*Returns*: integer - the length of the input subject

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string {vbar} array {vbar} object |subject whose length to
calculate
|===

*Example*

[source,js]
----
length(`[]`) // returns 0
length("") // returns 0
length("abcd") // returns 4
length([1, 2, 3, 4]) // returns 4
length({}) // returns 0
length({a : 3, b : 4}) // returns 2
----

== lower

*lower(input) ⇒ string*

Converts all the alphabetic characters in a string to lowercase. If the
value is not a string it will be converted into string.

*Returns*: string - the lower case value of the input string

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |string |input string
|===

*Example*

[source,js]
----
lower("E. E. Cummings") // returns e. e. cummings
----

== map

*map(expr, elements) ⇒ array*

Apply an expression to every element in an array and return the array of
results. An input array of length N will return an array of length N.

*Returns*: array - the mapped array

[cols=",,",options="header",]
|===
|Param |Type |Description
|expr |expression |expression to evaluate
|elements |array |array of elements to process
|===

*Example*

[source,js]
----
map(&(@ + 1), [1, 2, 3, 4]) // returns [2, 3, 4, 5]
map(&length(@), ["doe", "nick", "chris"]) // returns [3, 4, 5]
----

== max

*max(collection) ⇒ number*

Calculates the largest value in the provided `collection` arguments. If
all collections are empty `null` is returned. max() can work on numbers
or strings. If a mix of numbers and strings are provided, all values
with be coerced to the type of the first value.

*Returns*: number - the largest value found

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|collection |Array.<number> {vbar} Array.<string> |array in which the
maximum element is to be calculated
|===

*Example*

[source,js]
----
max([1, 2, 3], [4, 5, 6], 7) // returns 7
max(`[]`) // returns null
max(["a", "a1", "b"]) // returns "b"
----

== merge

*merge(…args) ⇒ object*

Accepts one or more objects, and returns a single object with all
objects merged. The first object is copied, and then and each key value
pair from each subsequent object are added to the first object.
Duplicate keys in subsequent objects will override those found in
earlier objects.

*Returns*: object - The combined object

[cols=",",options="header",]
|===
|Param |Type
|…args |object
|===

*Example*

[source,js]
----
merge({a: 1, b: 2}, {c : 3, d: 4}) // returns {a :1, b: 2, c: 3, d: 4}
merge({a: 1, b: 2}, {a : 3, d: 4}) // returns {a :3, b: 2, d: 4}
----

== mid

*mid(subject, startPos, length) ⇒ string {vbar} array*

Extracts a substring from source text, or a subset of an array. or in
case of array, extracts a subset of the array from start till the length
number of elements. Returns null if the `startPos` is greater than the
length of the array

*Returns*: string {vbar} array - The resulting substring or array
subset

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string {vbar} array |the text string or array of characters
or elements to extract.

|startPos |integer |the zero-position of the first character or element
to extract.

|length |integer |The number of characters or elements to return from
the string or array. If greater then the length of `subject` the
argument is set to the length of the subject.
|===

*Example*

[source,js]
----
mid("Fluid Flow", 0, 5) // returns "Fluid"
mid("Fluid Flow", 6, 20) // returns "Flow"
mid("Fluid Flow, 20, 5) // returns ""
mid([0,1,2,3,4,5,6,7,8,9], 2, 3) // returns [2,3,4]
----

== min

*min(collection) ⇒ number*

Calculates the smallest value in the input arguments. If all collections
are empty `null` is returned. min() can work on numbers or strings. If a
mix of numbers and strings are provided, the type of the first value
will be used.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|collection |…Array.<number> {vbar} Array.<string> {vbar} number
{vbar} string |to search for the minimum value
|===

*Example*

[source,js]
----
min([1, 2, 3], [4, 5, 6], 7) // returns 1
min(`[]`) // returns null
min(["a", "a1", "b"]) // returns "a"
----

== minute

*minute(date) ⇒ integer*

Extract the minute (0 through 59) from a time/datetime representation

*Returns*: integer - Number of minutes in the time portion of the
date/time value

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|date |number |A datetime/time value. Date/time values can be generated
using the <<_datetime>>, <<_today>>, <<_now>>
and <<_time>> functions.
|===

*Example*

[source,js]
----
minute(datetime(2008,5,23,12, 10, 0)) // returns 10
minute(time(12, 10, 0)) // returns 10
----

== mod

*mod(dividend, divisor) ⇒ number*

Return the remainder when one number is divided by another number.

*Returns*: number - Computes the remainder of `dividend`/`divisor`. If
`dividend` is negative, the result will also be negative.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|dividend |number |The number for which to find the remainder.
|divisor |number |The number by which to divide number.
|===

*Example*

[source,js]
----
mod(3, 2) // returns 1
mod(-3, 2) // returns -1
----

== month

*month(date) ⇒ number*

Finds the month of a date.

*Returns*: number - The month number as an integer, ranging from 1
(January) to 12 (December).

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|date |number |source date value. Date/time values can be generated
using the <<_datetime>>, <<_today>>, <<_now>>
and <<_time>> functions.
|===

*Example*

[source,js]
----
month(datetime(2008,5,23)) // returns 5
----

== not

*not(value) ⇒ boolean*

Compute logical NOT of a value. If the parameter is not boolean it will
be cast to boolean as per the type coercion rules. Note the related
unary not operator: `!`

*Returns*: boolean - The logical NOT applied to the input parameter

[cols=",,",options="header",]
|===
|Param |Type |Description
|value |any |any data type
|===

*Example*

[source,js]
----
not(length("bar") > 0) // returns false
not(false()) // returns true
not("abcd") // returns false
not("") // returns true
----

== notNull

*notNull(…argument) ⇒ any*

Finds the first argument that does not resolve to `null`. This function
accepts one or more arguments, and will evaluate them in order until a
non-null argument is encountered. If all arguments values resolve to
null, then return a null value.

[cols=",",options="header",]
|===
|Param |Type
|…argument |any
|===

*Example*

[source,js]
----
notNull(1, 2, 3, 4, `null`) // returns 1
notNull(`null`, 2, 3, 4, `null`) // returns 2
----

== now

*now() ⇒ number*

Retrieve the current date/time.

*Returns*: number - representation of current date/time as a number +

== null

*null() ⇒ boolean*

Return constant null value. Note that expressions may also use the JSON
literal null: `\'null\'`

*Returns*: boolean - True +

== or

*or(first, […operand]) ⇒ boolean*

Determines the logical OR result of a set of parameters. If the
parameters are not boolean they will be cast to boolean as per the type
coercion rules. Note the related `or' operator: `A || B`.

*Returns*: boolean - The logical result of applying OR to all parameters

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|first |any |logical expression
|[…operand] |any |any number of additional expressions
|===

*Example*

[source,js]
----
or((x / 2) == y, (y * 2) == x) // true
----

== power

*power(a, x) ⇒ number*

Computes `a` raised to a power `x`. (ax)

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|a |number |The base number – can be any real number.
|x |number |The exponent to which the base number is raised.
|===

*Example*

[source,js]
----
power(10, 2) // returns 100 (10 raised to power 2)
----

== proper

*proper(text) ⇒ string*

Apply proper casing to a string. Proper casing is where the first letter
of each word is converted to an uppercase letter and the rest of the
letters in the word converted to lowercase.

*Returns*: string - source string with proper casing applied.

[cols=",,",options="header",]
|===
|Param |Type |Description
|text |string |source string
|===

*Example*

[source,js]
----
proper("this is a TITLE") // returns "This Is A Title"
proper("2-way street") // returns "2-Way Street"
proper("76BudGet") // returns "76Budget"
----

== random

*random() ⇒ number*

Generate a pseudo random number.

*Returns*: number - A value greater than or equal to zero, and less than
one. +
*Example*

[source,js]
----
random() // 0.022585461160693265
----

== reduce

*reduce(expr, elements, initialValue) ⇒ any*

Executes a user-supplied reducer expression on each element of an array,
in order, passing in the return value from the expression from the
preceding element. The final result of running the reducer across all
elements of the input array is a single value. The expression can access
the following properties of the current object:

* accumulated: accumulated value based on the previous expression. For
the first array element use the `initialValue` parameter. If not
provided, then `null`
* current: current element to process
* index: index of the current element in the array
* array: original array

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|expr |expression |reducer expression to be executed on each element

|elements |array |array of elements on which the expression will be
evaluated

|initialValue |any |the accumulated value to pass to the first array
element
|===

*Example*

[source,js]
----
reduce(&(accumulated + current), [1, 2, 3]) // returns 6
// find maximum entry by age
reduce(
  &max(@.accumulated.age, @.current.age),
  [{age: 10, name: "Joe"},{age: 20, name: "John"}], @[0].age
)
reduce(&accumulated * current, [3, 3, 3], 1) // returns 27
----

== register

*register(functionName, expr) ⇒ Object*

Register a function. The registered function may take one parameter. If
more parameters are needed, combine them in an array or object.

*Returns*: Object - returns an empty object

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|functionName |string |Name of the function to register
|expr |expression |Expression to execute with this function call
|===

*Example*

[source,js]
----
register("product", &@[0] * @[1]) // can now call: product([2,21]) => returns 42
----

== replace

*replace(text, start, length, replacement) ⇒ string*

Generates text where an old text is substituted at a given start
position and length, with a new text.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|text |string |original text

|start |integer |zero-based index in the original text from where to
begin the replacement.

|length |integer |number of characters to be replaced

|replacement |string |string to insert at the start index
|===

*Example*

[source,js]
----
replace("abcdefghijk", 5, 5, "*") // returns abcde*k
replace("2009",2,2,"10") // returns  2010
replace("123456",0,3,"@") // returns @456
----

== rept

*rept(text, count) ⇒ string*

Return text repeated `count` times.

*Returns*: string - Text generated from the repeated text

[cols=",,",options="header",]
|===
|Param |Type |Description
|text |string |text to repeat
|count |integer |number of times to repeat the text
|===

*Example*

[source,js]
----
rept("x", 5) // returns "xxxxx"
----

== reverse

*reverse(argument) ⇒ array*

Reverses the order of an array or string

*Returns*: array - The resulting reversed array or string

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|argument |string {vbar} array |the source to be reversed
|===

*Example*

[source,js]
----
reverse(["a", "b", "c"]) // returns ["c", "b", "a"]
----

== right

*right(subject, [elements]) ⇒ string {vbar} array*

Generates a string from the right-most characters of a string or a
subset of elements from the end of an array

*Returns*: string {vbar} array - The extracted characters or array
subset Returns null if the number of elements is less than 0

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|subject |string {vbar} array | |The text/array containing the
characters/elements to extract

|[elements] |integer |1 |number of elements to pick
|===

*Example*

[source,js]
----
right("Sale Price", 4) // returns "rice"
right("Sweden") // returns "n"
right([4, 5, 6], 2) // returns [5, 6]
----

== round

*round(num, precision) ⇒ number*

Round a number to a specified precision:

* If `precision` is greater than zero, round to the specified number of
decimal places.
* If `precision` is 0, round to the nearest integer.
* If `precision` is less than 0, round to the left of the decimal point.

*Returns*: number - rounded value

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|num |number |number to round
|precision |integer |precision to use for the rounding operation.
|===

*Example*

[source,js]
----
round(2.15, 1) // returns 2.2
round(626.3,-3) // returns 1000 (Rounds 626.3 to the nearest multiple of 1000)
round(626.3, 0) // returns 626
round(1.98,-1) // returns 0 (Rounds 1.98 to the nearest multiple of 10)
round(-50.55,-2) // -100 (round -50.55 to the nearest multiple of 100)
----

== search

*search(findText, withinText, [startPos]) ⇒ array*

Perform a wildcard search. The search is case-sensitive and supports two
forms of wildcards: `{asterisk}` finds a sequence of characters and `?` finds a
single character. To use `{asterisk}` or `?` as text values, precede them with a
tilde (`~`) character. Note that the wildcard search is not greedy.
e.g. `search("a{asterisk}b", "abb")` will return `[0, "ab"]` Not
`[0, "abb"]`

*Returns*: array - returns an array with two values:

* The start position of the found text and the text string that was
found.
* If a match was not found, an empty array is returned.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|findText |string | |the search string – which may include wild cards.

|withinText |string | |The string to search.

|[startPos] |integer |0 |The zero-based position of withinText to start
searching.
|===

*Example*

[source,js]
----
search("a?c", "acabc") // returns [2, "abc"]
----

== second

*second(date) ⇒ integer*

Extract the seconds of the time value in a time/datetime representation

*Returns*: integer - The number of seconds: 0 through 59

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|date |number |datetime/time for which the second is to be returned.
Date/time values can be generated using the <<_datetime>>,
<<_today>>, <<_now>> and <<_time>> functions.
|===

*Example*

[source,js]
----
second(datetime(2008,5,23,12, 10, 53)) // returns 53
second(time(12, 10, 53)) // returns 53
----

== sort

*sort(list) ⇒ Array.<number> {vbar} Array.<string>*

This function accepts an array of strings or numbers and returns a
re-orderd array with the elements in sorted order. String sorting is
based on code points. Locale is not taken into account.

*Returns*: Array.<number> {vbar} Array.<string> - The ordered result

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|list |Array.<number> {vbar} Array.<string> |to be sorted
|===

*Example*

[source,js]
----
sort([1, 2, 4, 3, 1]) // returns [1, 1, 2, 3, 4]
----

== sortBy

*sortBy(elements, expr) ⇒ array*

Sort an array using an expression to find the sort key. For each element
in the array, the expression is applied and the resulting value is used
as the sort value. If the result of evaluating the expression against
the current array element results in type other than a number or a
string, a type-error will occur.

*Returns*: array - The sorted array

[cols=",,",options="header",]
|===
|Param |Type |Description
|elements |array |Array to be sorted
|expr |expression |The comparision expression
|===

*Example*

[source,js]
----
sortBy(["abcd", "e", "def"], &length(@)) // returns ["e", "def", "abcd"]

// returns [{year: 1910}, {year: 2010}, {year: 2020}]
sortBy([{year: 2010}, {year: 2020}, {year: 1910}], &year)
sortBy([-15, 30, -10, -11, 5], &abs(@)) // [5, -10, -11, -15, 30]
----

== split

*split(string, separator) ⇒ Array.<string>*

split a string into an array, given a separator

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|string |string |string to split
|separator |string |separator where the split(s) should occur
|===

*Example*

[source,js]
----
split("abcdef", "") // returns ["a", "b", "c", "d", "e", "f"]
split("abcdef", "e") // returns ["abcd", "f"]
----

== sqrt

*sqrt(num) ⇒ number*

Return the square root of a number

*Returns*: number - the calculated square root value

[cols=",,",options="header",]
|===
|Param |Type |Description
|num |number |source number
|===

*Example*

[source,js]
----
sqrt(4) // returns 2
----

== startsWith

*startsWith(subject, prefix) ⇒ boolean*

Determine if a string starts with a prefix.

*Returns*: boolean - true if `prefix` matches the start of `subject`

[cols=",,",options="header",]
|===
|Param |Type |Description
|subject |string |string to search
|prefix |string |prefix to search for
|===

*Example*

[source,js]
----
startsWith("jack is at home", "jack") // returns true
----

== stdev

*stdev(numbers) ⇒ number*

Estimates standard deviation based on a sample. `stdev` assumes that its
arguments are a sample of the entire population. If your data represents
a entire population, then compute the standard deviation using
<<_stdevp>>.

*Returns*: number -
https://en.wikipedia.org/wiki/Standard_deviation[Standard deviation]

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|numbers |Array.<number> |The array of numbers comprising the population
|===

*Example*

[source,js]
----
stdev([1345, 1301, 1368]) // returns 34.044089061098404
stdevp([1345, 1301, 1368]) // returns 27.797
----

== stdevp

*stdevp(numbers) ⇒ number*

Calculates standard deviation based on the entire population given as
arguments. `stdevp` assumes that its arguments are the entire
population. If your data represents a sample of the population, then
compute the standard deviation using <<_stdev>>.

*Returns*: number - Calculated standard deviation

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|numbers |Array.<number> |The array of numbers comprising the population
|===

*Example*

[source,js]
----
stdevp([1345, 1301, 1368]) // returns 27.797
stdev([1345, 1301, 1368]) // returns 34.044
----

== substitute

*substitute(text, old, new, [which]) ⇒ string*

Generates a string from the input `text`, with text `old` replaced by
text `new` (when searching from the left). If there is no match, or if
`old` has length 0, `text` is returned unchanged. Note that `old` and
`new` may have different lengths. If `which` < 1, return `text`
unchanged

*Returns*: string - replaced string

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|text |string |The text for which to substitute characters.

|old |string |The text to replace.

|new |string |The text to replace `old` with.

|[which] |integer |The one-based occurrence of `old` text to replace
with `new` text. If `which` parameter is omitted, every occurrence of
`old` is replaced with `new`.
|===

*Example*

[source,js]
----
substitute("Sales Data", "Sales", "Cost") // returns "Cost Data"
substitute("Quarter 1, 2008", "1", "2", 1) // returns "Quarter 2, 2008"
substitute("Quarter 1, 1008", "1", "2", 2) // returns "Quarter 1, 2008"
----

== sum

*sum(collection) ⇒ number*

Calculates the sum of the provided array. An empty array will produce a
return value of 0.

*Returns*: number - The sum of elements

[cols=",,",options="header",]
|===
|Param |Type |Description
|collection |Array.<number> |array of elements
|===

*Example*

[source,js]
----
sum([1, 2, 3]) // returns 6
----

== time

*time(hours, [minutes], [seconds]) ⇒ number*

Construct and returns a time value.

*Returns*: number - Returns a date/time value representing the fraction
of the day consumed by the given time

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|hours |integer | |Zero-based integer value between 0 and 23
representing the hour of the day.

|[minutes] |integer |0 |Zero-based integer value representing the minute
segment of a time.

|[seconds] |integer |0 |Zero-based integer value representing the
seconds segment of a time.
|===

*Example*

[source,js]
----
time(12, 0, 0) | [hour(@), minute(@), second(@)] // returns [12, 0, 0]
----

== toArray

*toArray(arg) ⇒ array*

Converts the provided argument to an array. The conversion happens as
per the following rules:

* array - Returns the provided value.
* number/string/object/boolean/null - Returns a one element array
containing the argument.

*Returns*: array - The resulting array

[cols=",,",options="header",]
|===
|Param |Type |Description
|arg |any |parameter to turn into an array
|===

*Example*

[source,js]
----
toArray(1) // returns [1]
toArray(null()) // returns [`null`]
----

== today

*today() ⇒ number*

Returns a date/time value representing the start of the current day.
i.e. midnight

*Returns*: number - today at midnight +

== toNumber

*toNumber(arg) ⇒ number*

Converts the provided arg to a number. The conversion happens as per the
type coercion rules.

[cols=",,",options="header",]
|===
|Param |Type |Description
|arg |any |to convert to number
|===

*Example*

[source,js]
----
toNumber(1) // returns 1
toNumber("10") // returns 10
toNumber({a: 1}) // returns null
toNumber(true()) // returns 1
toNumber("10f") // returns 0
----

== toString

*toString(arg) ⇒ string*

Converts the provided argument to a string. The conversion happens as
per the type coercion rules.

*Returns*: string - The result string

[cols=",,",options="header",]
|===
|Param |Type |Description
|arg |any |Value to be converted to a string
|===

*Example*

[source,js]
----
toString(1) // returns "1"
toString(true()) // returns "true"
toString({sum: 12 + 13}) // "{"sum":25}"
----

== trim

*trim(text) ⇒ string*

Remove leading and trailing spaces, and replace all internal multiple
spaces with a single space.

*Returns*: string - trimmed string

[cols=",,",options="header",]
|===
|Param |Type |Description
|text |string |string to trim
|===

*Example*

[source,js]
----
trim("   ab    c   ") // returns "ab c"
----

== true

*true() ⇒ boolean*

Return constant boolean true value. Note that expressions may also use
the JSON literal true: `\'true\'`

*Returns*: boolean - True +

== trunc

*trunc(numA, [numB]) ⇒ number*

Truncates a number to an integer by removing the fractional part of the
number.

*Returns*: number - Truncated value

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|numA |number | |number to truncate

|[numB] |integer |0 |A number specifying the number of decimal digits to
preserve.
|===

*Example*

[source,js]
----
trunc(8.9) // returns 8
trunc(-8.9) // returns -8
trunc(8.912, 2) // returns 8.91
----

== type

*type(subject) ⇒ string*

Finds the JavaScript type of the given `subject` argument as a string
value. The return value MUST be one of the following:

* number
* string
* boolean
* array
* object
* null

*Returns*: string - The type of the subject

[cols=",,",options="header",]
|===
|Param |Type |Description
|subject |any |type to evaluate
|===

*Example*

[source,js]
----
type(1) // returns "number"
type("") // returns "string"
----

== unique

*unique(input) ⇒ array*

Find the set of unique elements within an array

*Returns*: array - array with duplicate elements removed

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |array |input array
|===

*Example*

[source,js]
----
unique([1, 2, 3, 4, 1, 1, 2]) // returns [1, 2, 3, 4]
----

== upper

*upper(input) ⇒ string*

Converts all the alphabetic characters in a string to uppercase. If the
value is not a string it will be converted into string according to the
type coercion rules.

*Returns*: string - the upper case value of the input string

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |string |input string
|===

*Example*

[source,js]
----
upper("abcd") // returns "ABCD"
----

== value

*value(object, index) ⇒ any*

Perform an indexed lookup on an object or array

*Returns*: any - the result of the lookup – or `null` if not found.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|object |object {vbar} array |on which to perform the lookup

|index |string {vbar} integer |a named child for an object or an
integer offset for an array
|===

*Example*

[source,js]
----
value({a: 1, b:2, c:3}, "a") // returns 1
value([1, 2, 3, 4], 2) // returns 3
----

== values

*values(obj) ⇒ array*

Generates an array of the values of the provided object. Note that
because JSON objects are inherently unordered, the values associated
with the provided object are also unordered.

*Returns*: array - array of the key values

[cols=",,",options="header",]
|===
|Param |Type |Description
|obj |object |source object
|===

*Example*

[source,js]
----
values({a : 3, b : 4}) // returns [3, 4]
----

== weekday

*weekday(date, [returnType]) ⇒ integer*

Extract the day of the week from a date. The specific numbering of the
day of week is controlled by the `returnType` parameter:

* 1 : Sunday (1), Monday (2), …, Saturday (7)
* 2 : Monday (1), Tuesday (2), …, Sunday(7)
* 3 : Monday (0), Tuesday (2), …., Sunday(6)

*Returns*: integer - day of the week

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|Param |Type |Default |Description
|date |number | |datetime for which the day of the week is to be
returned. Date/time values can be generated using the
<<_datetime>>, <<_today>>, <<_now>> and
<<_time>> functions.

|[returnType] |integer |1 |Determines the representation of the result
|===

*Example*

[source,js]
----
weekday(datetime(2006,5,21)) // 1
weekday(datetime(2006,5,21), 2) // 7
weekday(datetime(2006,5,21), 3) // 6
----

== year

*year(date) ⇒ integer*

Finds the year of a datetime value

*Returns*: integer - The year value

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|date |number |input date/time value. Date/time values can be generated
using the <<_datetime>>, <<_today>>, <<_now>>
and <<_time>> functions.
|===

*Example*

[source,js]
----
year(datetime(2008,5,23)) // returns 2008
----

== zip

*zip(…arrays) ⇒ array*

Generates a convolved (zipped) array containing grouped arrays of values
from the array arguments from index 0, 1, 2, etc. This function accepts
a variable number of arguments. The length of the returned array is
equal to the length of the shortest array.

*Returns*: array - An array of arrays with elements zipped together

[cols=",,",options="header",]
|===
|Param |Type |Description
|…arrays |array |array of arrays to zip together
|===

*Example*

[source,js]
----
zip([1, 2, 3], [4, 5, 6, 7]) // returns [[1, 4], [2, 5], [3, 6]]
----

== encodeUrlComponent

*encodeUrlComponent(uriComponent) ⇒ string*

Encode a URL component as per:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent[encodeUrlComponent]

*Returns*: string - encoded value

[cols=",,",options="header",]
|===
|Param |Type |Description
|uriComponent |string |to encode
|===

*Example*

[source,js]
----
encodeURIComponent("a=b") // returns "a%3Db"
----

== encodeUrl

*encodeUrl(uri) ⇒ string*

Encode a URL as per:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI[encodeURI()]

*Returns*: string - encoded value

[cols=",,",options="header",]
|===
|Param |Type |Description
|uri |string |to encode
|===

*Example*

[source,js]
----
encodeUrl("https://example.com/&a=4% of 15") // returns ("a=b") // https://example.com/&a=4%25%20of%2015
----

== decodeUrlComponent

*decodeUrlComponent(encodedString) ⇒ string*

Decode a URL component as per:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent[decodeURIComponent]

*Returns*: string - decoded value

[cols=",,",options="header",]
|===
|Param |Type |Description
|encodedString |string |to decode
|===

*Example*

[source,js]
----
decodeUrlComponent("%3B%2C%2F%3F%3A%40%26%3D%2B%24") // ";,/?:@&=+$"
----

== decodeUrl

*decodeUrl(encodedURL) ⇒ string*

Decode a URL as per:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURI[decodeURI]

*Returns*: string - decoded URL

[cols=",,",options="header",]
|===
|Param |Type |Description
|encodedURL |string |to decode
|===

*Example*

[source,js]
----
decodeUrl("https://example.com/?foo=%5Ba%25%5D") // "https://example.com/?foo=[a%]"
----
