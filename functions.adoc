== abs(value) ⇒ number

Returns the absolute value of the provided argument `value`.

*Kind*: global function +
*Returns*: number - returns the absolute value of the `value` argument

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|value |number |argument whose absolute value has to be returned
|===

*Example*

[source,js]
----
abs(-1) //returns 1
----

== avg(elements) ⇒ number

Returns the average of the elements in the provided array. An empty
array will produce a return value of `null`.

*Kind*: global function +
*Returns*: number - average value

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|elements |Array.<number> |array of elements whose average has to be
computed
|===

*Example*

[source,js]
----
avg(`[]`) //returns null
----

*Example*

[source,js]
----
avg([1, 2, 3]) //returns 2
----

== ceil(num) ⇒ number

Returns the next highest integer value of the argument `num` by rounding
up if necessary.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|num |number |number whose next highest integer value has to be computed
|===

*Example*

[source,js]
----
ceil(10) //returns 10
----

*Example*

[source,js]
----
ceil(10.4) //return 11
----

== contains(subject, search) ⇒ boolean

Returns true if the given `subject` contains the provided `search`
string. If `subject` is an array, this function returns true if one of
the elements in the array is equal to the provided `search` value. If
the provided `subject` is a string, this function returns true if the
string contains the provided `search` argument.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |array | string |the subject in which the element has to be
searched

|search |string | boolean | number | date |element to search
|===

*Example*

[source,js]
----
contains([1, 2, 3, 4], 2) //returns true
----

*Example*

[source,js]
----
contains([1, 2, 3, 4], -1) //returns false
----

*Example*

[source,js]
----
contains('Abcd', 'd') //returns true
----

*Example*

[source,js]
----
contains('Abcd', 'x') //returns false
----

== endsWith(subject, suffix) ⇒ boolean

Returns true if the `subject` ends with the `suffix`, otherwise this
function returns false.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string |subject in which the `suffix` is being searched for
|suffix |string |suffix to search in the subject
|===

*Example*

[source,js]
----
endsWith('Abcd', 'd') //returns true
----

*Example*

[source,js]
----
endsWith('Abcd', 'A') //returns false
----

== floor(num) ⇒ number

Returns the next lowest integer value of the argument `num` by rounding
down if necessary.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|num |number |number whose next lowest integer value has to be returned
|===

*Example*

[source,js]
----
floor(10.4) //returns 10
----

*Example*

[source,js]
----
floor(10) //returns 10
----

== join(glue, stringsarray) ⇒ string

Returns all the elements from the provided `stringsarray` array joined
together using the `glue` argument as a separator between each.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|glue |string
|stringsarray |Array.<string>
|===

*Example*

[source,js]
----
join(',', ['a', 'b', 'c']) //returns 'a,b,c'
----

== keys(obj) ⇒ array

Returns an array containing the keys of the provided object `obj`. If
the passed object is null, the value returned is an empty array

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|obj |object |the object whose keys need to be extracted
|===

*Example*

[source,js]
----
keys({a : 3, b : 4}) //returns ['a', 'b']
----

== length(subject) ⇒ number

Returns the length of the given argument `subject` using the following
types rules: * string: returns the number of code points in the string *
array: returns the number of elements in the array * object: returns the
number of key-value pairs in the object

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string | array | object |subject whose length has to be
calculated
|===

*Example*

[source,js]
----
length(`[]`) //returns 0
----

*Example*

[source,js]
----
length('') //returns 0
----

*Example*

[source,js]
----
length('abcd') //returns 4
----

*Example*

[source,js]
----
length([1, 2, 3, 4]) //returns 4
----

*Example*

[source,js]
----
length({}) // returns 0
----

*Example*

[source,js]
----
length({a : 3, b : 4}) //returns 2
----

== map(expr, elements) ⇒ array

Apply the `expr` to every element in the `elements` array and return the
array of results. An elements of length N will produce a return array of
length N. Unlike a projection, `[*].bar`, `map()` will include the
result of applying the `expr` for every element in the elements array,
even if the result is `null`.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|expr |expression |expression to evaluate on each element

|elements |array |array of elements on which the expression will be
evaluated
|===

*Example*

[source,js]
----
map(&(@ + 1), [1, 2, 3, 4]) // returns [2, 3, 4, 5]
----

*Example*

[source,js]
----
map(&length(@), ['doe', 'nick', 'chris']) // returns [3,4, 5]
----

== max(collection) ⇒ number

Returns the highest value in the provided `collection` arguments. If all
collections are empty `null` is returned. max() can work on numbers or
strings. If a mix of numbers and strings are provided, the type of the
first value will be used.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|collection |Array.<number> | Array.<string> |array in which the maximum
element is to be calculated
|===

*Example*

[source,js]
----
max([1, 2, 3], [4, 5, 6], 7) //returns 7
----

*Example*

[source,js]
----
max(`[]`) // returns null
----

*Example*

[source,js]
----
max(['a', 'a1', 'b']) // returns 'b'
----

== merge(…args) ⇒ object

Accepts 0 or more objects as arguments, and returns a single object with
subsequent objects merged. Each subsequent object’s key/value pairs are
added to the preceding object. This function is used to combine multiple
objects into one. You can think of this as the first object being the
base object, and each subsequent argument being overrides that are
applied to the base object.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|…args |object
|===

*Example*

[source,js]
----
merge({a: 1, b: 2}, {c : 3, d: 4}) // returns {a :1, b: 2, c: 3, d: 4}
----

*Example*

[source,js]
----
merge({a: 1, b: 2}, {a : 3, d: 4}) // returns {a :3, b: 2, d: 4}
----

== min(collection) ⇒ number

Returns the lowest value in the provided `collection` arguments. If all
collections are empty `null` is returned. min() can work on numbers or
strings. If a mix of numbers and strings are provided, the type of the
first value will be used.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|collection |…Array.<number> | Array.<string> | number | string
|elements
|===

*Example*

[source,js]
----
min([1, 2, 3], [4, 5, 6], 7) //returns 1
----

*Example*

[source,js]
----
min(`[]`) // returns null
----

*Example*

[source,js]
----
min(['a', 'a1', 'b']) // returns 'a'
----

== notNull(…argument) ⇒ any

Returns the first argument that does not resolve to `null`. This
function accepts one or more arguments, and will evaluate them in order
until a non null argument is encountered. If all arguments values
resolve to null, then a value of null is returned.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|…argument |any
|===

*Example*

[source,js]
----
notNull(1, 2, 3, 4, `null`) //returns 1
----

*Example*

[source,js]
----
notNull(`null`, 2, 3, 4, `null`) //returns 2
----

== reduce(expr, elements) ⇒ any

executes a user-supplied reducer expression `expr` on each element of
the array, in order, passing in the return value from the calculation on
the preceding element. The final result of running the reducer across
all elements of the `elements` array is a single value. The expression
can access the following properties * accumulated: accumulated value
based on the previous calculations. Initial value is `null` * current:
current element to process * index: index of the `current` element in
the array * array: original array

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|expr |expression |reducer expr to be executed on each element

|elements |array |array of elements on which the expression will be
evaluated
|===

*Example*

[source,js]
----
reduce(&(accumulated + current), [1, 2, 3]) //returns 6
----

*Example*

[source,js]
----
// find maximum entry by age
reduce(
  &max(@.accumulated.age, @.current.age),
  [{age: 10, name: 'Joe'},{age: 20, name: 'John'}], @[0].age
)
----

*Example*

[source,js]
----
reduce(&if(accumulated == `null`, current, accumulated * current), [3, 3, 3]) //returns 27
----

== register(functionName, expr) ⇒ Object

Register a function to allow code re-use. The registered function may
take one parameter. If more parameters are needed, combine them in an
array or map.

*Kind*: global function +
*Returns*: Object - returns an empty object

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|functionName |string |Name of the function to register
|expr |expression |Expression to execute with this function call
|===

*Example*

[source,js]
----
register('product', &@[0] * @[1]) // can now call: product([2,21]) => returns 42
----

== reverse(argument) ⇒ array

Reverses the order of the `argument`.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|argument |string | array
|===

*Example*

[source,js]
----
reverse(['a', 'b', 'c']) //returns ['c', 'b', 'a']
----

== sort(list) ⇒ Array.<number> | Array.<string>

This function accepts an array `list` argument and returns the sorted
elements of the `list` as an array. The array must be a list of strings
or numbers. string sorting is based on code points. Locale is not taken
into account.

*Kind*: global function

[width="100%",cols="50%,50%",options="header",]
|===
|Param |Type
|list |Array.<number> | Array.<string>
|===

*Example*

[source,js]
----
sort([1, 2, 4, 3, 1]) // returns [1, 1, 2, 3, 4]
----

== sortBy(elements, expr) ⇒ array

Sort an array using an expression `expr` as the sort key. For each
element in the array of elements, the `expr` expression is applied and
the resulting value is used as the key used when sorting the elements.
If the result of evaluating the `expr` against the current array element
results in type other than a number or a string, a type error will
occur.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|elements |array
|expr |expression
|===

*Example*

[source,js]
----
sortBy(['abcd', 'e', 'def'], &length(@)) //returns ['e', 'def', 'abcd']
----

*Example*

[source,js]
----
// returns [{year: 1910}, {year: 2010}, {year: 2020}]
sortBy([{year: 2010}, {year: 2020}, {year: 1910}], &year)
----

== startsWith(subject, prefix) ⇒ boolean

Returns true if the `subject` starts with the `prefix`, otherwise
returns false.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string |subject in which the `prefix` is being searched for
|prefix |string |prefix to search in the subject
|===

*Example*

[source,js]
----
startsWith('jack is at home', 'jack') // returns true
----

== sum(collection) ⇒ number

Returns the sum of the provided `collection` array argument. An empty
array will produce a return value of 0.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|collection |Array.<number> |array whose element’s sum has to be
computed
|===

*Example*

[source,js]
----
sum([1, 2, 3]) //returns 6
----

== toArray(arg) ⇒ array

converts the passed `arg` to an array. The conversion happens as per the
following rules * array - Returns the passed in value. *
number/string/object/boolean - Returns a one element array containing
the argument.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|arg |any
|===

*Example*

[source,js]
----
toArray(1) // returns [1]
----

*Example*

[source,js]
----
toArray(null()) // returns [`null`]
----

== toNumber(arg) ⇒ number

converts the passed arg to a number. The conversion happens as per the
following rules * string - Returns the parsed number. * number - Returns
the passed in value. * array - null * object - null * boolean - 1 if
true, 0 if false * null - null

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|arg |any
|===

*Example*

[source,js]
----
toNumber(1) //returns 1
----

*Example*

[source,js]
----
toNumber('10') //returns 10
----

*Example*

[source,js]
----
toNumber({a: 1}) //returns null
----

*Example*

[source,js]
----
toNumber(true()) //returns 1
----

== toString(arg) ⇒ string

converts the passed `arg` to a string. The conversion happens as per the
following rules * string - Returns the passed in value. *
number/array/object/boolean - The JSON encoded value of the object.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|arg |any
|===

*Example*

[source,js]
----
toString(1) //returns '1'
----

*Example*

[source,js]
----
toString(true()) //returns 'true'
----

== type(subject) ⇒ string

Returns the JavaScript type of the given `subject` argument as a string
value.

The return value MUST be one of the following: * number * string *
boolean * array * object * null

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|subject |any
|===

*Example*

[source,js]
----
type(1) //returns 'number'
----

*Example*

[source,js]
----
type('') //returns 'string'
----

== values(obj) ⇒ array

Returns the values of the provided object `obj`. Note that because JSON
hashes are inherently unordered, the values associated with the provided
object obj are inherently unordered.

*Kind*: global function

[cols=",",options="header",]
|===
|Param |Type
|obj |object
|===

*Example*

[source,js]
----
values({a : 3, b : 4}) //returns [3, 4]
----

== zip(…arrays) ⇒ array

Returns a convolved (zipped) array containing grouped arrays of values
from the array arguments from index 0, 1, 2, etc. This function accepts
a variable number of arguments. The length of the returned array is
equal to the length of the shortest array.

*Kind*: global function +
*Returns*: array - An array of arrays with elements zipped together

[cols=",,",options="header",]
|===
|Param |Type |Description
|…arrays |array |array of arrays to zip together
|===

*Example*

[source,js]
----
zip([1, 2, 3], [4, 5, 6]) //returns [[1, 4], [2, 5], [3, 6]]
----

== casefold(input) ⇒ string

Returns a lower-case string of the `input` string using locale-specific
mappings. e.g. Strings with German lowercase letter `ß' can be compared
to `ss'

*Kind*: global function +
*Returns*: string - A new string converted to lower case

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |string |string to casefold
|===

*Example*

[source,js]
----
casefold('AbC') // returns 'abc'
----

== day(The) ⇒ number

Returns the day of a date, represented by a serial number. The day is
given as an integer ranging from 1 to 31.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |date of the day you are trying to find. Dates should be
entered by using the datetime function
|===

*Example*

[source,js]
----
day(datetime(2008,5,23)) //returns 23
----

== entries(obj) ⇒ Array.<any>

returns an array of a given object’s property `[key, value]` pairs.

*Kind*: global function +
*Returns*: Array.<any> - an array of [key, value] pairs

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|obj |object |Object whose `[key, value]` pairs need to be extracted
|===

*Example*

[source,js]
----
entries({a: 1, b: 2}) //returns [['a', 1], ['b', 2]]
----

== exp(x) ⇒ number

Returns e (the base of natural logarithms) raised to a power x.
(i.e. ex)

*Kind*: global function +
*Returns*: number - e (the base of natural logarithms) raised to a power
x

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|x |number |A numeric expression representing the power of e.
|===

*Example*

[source,js]
----
exp(10) //returns 22026.465794806718
----

== fromEntries(pairs) ⇒ object

returns an object by transforming a list of key-value `pairs` into an
object.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|pairs |Array.<any> |list of key-value pairs to create the object from
|===

*Example*

[source,js]
----
fromEntries([['a', 1], ['b', 2]]) //returns {a: 1, b: 2}
----

== hour(The) ⇒ number

Extract the hour (0 through 23) from a time/datetime representation

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |datetime/time for which the hour is to be returned. Dates
should be specified using the datetime or link:#time[time] function
|===

*Example*

[source,js]
----
hour(datetime(2008,5,23,12, 0, 0)) //returns 12
hour(time(12, 0, 0)) //returns 12
----

== left(subject, [elements]) ⇒ string | array

Return a selected number of text characters from the left or in case of
array selected number of elements from the start

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string | array |The text/array of characters/elements to
extract.

|[elements] |number |number of elements to pick. Defaults to 1
|===

*Example*

[source,js]
----
left('Sale Price', 4) //returns 'Sale'
----

*Example*

[source,js]
----
left('Sweden') // returns 'S'
----

*Example*

[source,js]
----
left([4, 5, 6], 2) // returns [4, 5]
----

== lower(input) ⇒ string

Converts all the alphabetic characters in a string to lowercase. If the
value is not a string it will be converted into string.

*Kind*: global function +
*Returns*: string - the lower case value of the input string

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |string |input string
|===

*Example*

[source,js]
----
lower('E. E. Cummings') //returns e. e. cummings
----

== mid(subject, startPos, length) ⇒ string | array

Returns extracted text, given an original text, starting position, and
length. or in case of array, extracts a subset of the array from start
till the length number of elements. Returns null if the `startPos` is
greater than the length of the array

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string | array |the text string or array of characters or
elements to extract.

|startPos |number |the zero-position of the first character or element
to extract. The position starts with 0

|length |number |The number of characters or elements to return from
text. If it is greater then the length of `subject` the argument is set
to the length of the subject.
|===

*Example*

[source,js]
----
mid('Fluid Flow',0,5) //returns 'Fluid'
----

*Example*

[source,js]
----
mid('Fluid Flow',6,20) //returns 'Flow'
----

*Example*

[source,js]
----
mid('Fluid Flow,20,5) //returns ''
----

== minute(The) ⇒ number

Extract the minute (0 through 59) from a time/datetime representation

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |datetime/time for which the minute is to be returned.
Dates should be specified using the datetime or link:#time[time]
function
|===

*Example*

[source,js]
----
minute(datetime(2008,5,23,12, 10, 0)) // returns 10
minute(time(12, 10, 0)) //returns 10
----

== mod(dividend, divisor) ⇒ number

Return the remainder when one number is divided by another number. The
sign is the same as divisor

*Kind*: global function +
*Returns*: number - Computes the remainder of `dividend`/`divisor`.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|dividend |number |The number for which to find the remainder.
|divisor |number |The number by which to divide number.
|===

*Example*

[source,js]
----
mod(3, 2) //returns 1
----

*Example*

[source,js]
----
mod(-3, 2) //returns -1
----

== month(The) ⇒ number

Returns the month of a date represented by a serial number. The month is
given as an integer, ranging from 1 (January) to 12 (December).

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |date for which the month is to be returned. Dates should
be entered by using the datetime function
|===

*Example*

[source,js]
----
month(datetime(2008,5,23)) //returns 5
----

== now() ⇒ number

returns the time since epoch with days as exponent and time of day as
fraction

*Kind*: global function +
*Returns*: number - representation of current time as a number +

== power(a, x) ⇒ number

Computes `a` raised to a power `x`. (ax)

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|a |number |The base number. It can be any real number.
|x |number |The exponent to which the base number is raised.
|===

*Example*

[source,js]
----
power(10, 2) //returns 100 (10 raised to power 2)
----

== proper(text) ⇒ string

Return the input string with the first letter of each word converted to
an uppercase letter and the rest of the letters in the word converted to
lowercase.

*Kind*: global function

[cols=",,",options="header",]
|===
|Param |Type |Description
|text |string |the text to partially capitalize.
|===

*Example*

[source,js]
----
proper('this is a TITLE') //returns 'This Is A Title'
----

*Example*

[source,js]
----
proper('2-way street') //returns '2-Way Street'
----

*Example*

[source,js]
----
proper('76BudGet') //returns '76Budget'
----

== random() ⇒ number

Returns a pseudo random number that is greater than or equal to zero,
and less than one.

*Kind*: global function +
*Example*

[source,js]
----
random() // 0.022585461160693265
----

== replace(text, start, length, replacement) ⇒ string

Returns text where an old text is substituted at a given start position
and length, with a new text.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|text |string |original text

|start |number |zero-based index in the original text from where to
begin the replacement.

|length |number |number of characters to be replaced

|replacement |string |string to replace at the start index
|===

*Example*

[source,js]
----
replace('abcdefghijk', 5, 5, '*') //returns abcde*k
----

*Example*

[source,js]
----
replace('2009',2,2,'10') //returns  2010
----

*Example*

[source,js]
----
replace('123456',0,3,'@') //returns @456
----

== rept(text, count) ⇒ string

Return text repeated Count times.

*Kind*: global function

[cols=",,",options="header",]
|===
|Param |Type |Description
|text |string |text to repeat
|count |number |number of times to repeat the text
|===

*Example*

[source,js]
----
rept('x', 5) //returns 'xxxxx'
----

== right(subject, [elements]) ⇒ string | array

Return a selected number of text characters from the right of a
`subject` or in case of array selected number of elements from the end
of `subject` array Returns null if the number of elements is less than 0

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|subject |string | array |The text/array containing the
characters/elements to extract.

|[elements] |number |number of elements to pick. Defaults to 1
|===

*Example*

[source,js]
----
right('Sale Price', 4) //returns 'rice'
----

*Example*

[source,js]
----
right('Sweden') // returns 'n'
----

*Example*

[source,js]
----
right([4, 5, 6], 2) // returns [5, 6]
----

== round(num, precision) ⇒ number

Round a number to a specified `precision`. ### Remarks * If `precision`
is greater than zero, round to the specified number of decimal places. *
If `precision` is 0, round to the nearest integer. * If `precision` is
less than 0, round to the left of the decimal point.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|num |number |number to round off
|precision |number |number is rounded to the specified precision.
|===

*Example*

[source,js]
----
round(2.15, 1) //returns 2.2
----

*Example*

[source,js]
----
round(626.3,-3) //returns 1000 (Rounds 626.3 to the nearest multiple of 1000)
----

*Example*

[source,js]
----
round(626.3, 0) //returns 626
----

*Example*

[source,js]
----
round(1.98,-1) //returns 0 (Rounds 1.98 to the nearest multiple of 10)
----

*Example*

[source,js]
----
round(-50.55,-2) // -100 (round -50.55 to the nearest multiple of 100)
----

== search(findText, withinText, startPos) ⇒ array

Perform a wildcard search. The search is case-sensitive and supports two
forms of wildcards: ``__” finds a a sequence of characters and ”?” finds
a single character. To use ”__'' or ``?'' as text values, precede them
with a tilde (``~'') character. Note that the wildcard search is not
greedy. e.g. search(’a*b’, `abb') will return [0, `ab'] Not [0, `abb']

*Kind*: global function +
*Returns*: array - returns an array with two values: The start position
of the found text and the text string that was found. If a match was not
found, an empty array is returned.

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|findText |string |the search string – which may include wild cards.

|withinText |string |The string to search.

|startPos |integer |The zero-based position of withinText to start
searching. Defaults to zero.
|===

*Example*

[source,js]
----
search('a?c', 'acabc') //returns [2, 'abc']
----

== second(The) ⇒ number

Extract the second (0 through 59) from a time/datetime representation

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |datetime/time for which the second is to be returned.
Dates should be specified using the datetime or link:#time[time]
function
|===

*Example*

[source,js]
----
second(datetime(2008,5,23,12, 10, 53)) //returns 53
second(time(12, 10, 53)) //returns 53
----

== split(string, separator) ⇒ Array.<string>

split a string into an array, given a separator

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|string |string |string to split
|separator |string |separator where the split should occur
|===

*Example*

[source,js]
----
split('abcdef', '') //returns ['a', 'b', 'c', 'd', 'e', 'f']
----

*Example*

[source,js]
----
split('abcdef', 'e') //returns ['abcd', 'f']
----

== sqrt(num) ⇒ number

Return the square root of a number

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|num |number |number whose square root has to be calculated
|===

*Example*

[source,js]
----
sqrt(4) //returns 2
----

== stdev(numbers) ⇒ number

Estimates standard deviation based on a sample. `stdev` assumes that its
arguments are a sample of the entire population. If your data represents
a entire population, then compute the standard deviation using
link:#stdevp[stdevp].

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|numbers |Array.<number> |The array of numbers comprising the population
|===

*Example*

[source,js]
----
stdev([1345, 1301, 1368]) //returns 34.044089061098404
stdevp([1345, 1301, 1368]) //returns 27.797
----

== stdevp(numbers) ⇒ number

Calculates standard deviation based on the entire population given as
arguments. `stdevp` assumes that its arguments are the entire
population. If your data represents a sample of the population, then
compute the standard deviation using link:#stdev[stdev].

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|numbers |Array.<number> |The array of numbers comprising the population
|===

*Example*

[source,js]
----
stdevp([1345, 1301, 1368]) //returns 27.797
stdev([1345, 1301, 1368]) //returns 34.044
----

== time(hours, minutes, seconds) ⇒ number

Construct and returns time from hours, minutes, and seconds.

*Kind*: global function +
*Returns*: number - Returns the fraction of the day consumed by the
given time

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|hours |integer |Integer value between 0 and 23 representing the hour of
the day. Defaults to 0.

|minutes |integer |Integer value representing the minute segment of a
time. The default is 0 minutes past the hour.

|seconds |integer |Integer value representing the second segment of a
time. The default is 0 seconds past the minute.
|===

*Example*

[source,js]
----
time(12, 0, 0) | [hour(@), minute(@), second(@)] //returns [12, 0, 0]
----

== today() ⇒

returns the number of days since epoch

*Kind*: global function +
*Returns*: number +

== trim(text) ⇒ string

Remove leading and trailing spaces, and replace all internal multiple
spaces with a single space.

*Kind*: global function +
*Returns*: string - removes all leading and trailing space. Any other
sequence of 2 or more spaces is replaced with a single space.

[cols=",,",options="header",]
|===
|Param |Type |Description
|text |string |string to trim
|===

*Example*

[source,js]
----
trim('   ab    c   ') //returns 'ab c'
----

== trunc(numA, [numB]) ⇒ number

Truncates a number to an integer by removing the fractional part of the
number.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|numA |number |number to truncate

|[numB] |number |A number specifying the precision of the truncation.
Default is 0
|===

*Example*

[source,js]
----
trunc(8.9) //returns 8
trunc(-8.9) //returns -8
trunc(8.912, 2) //returns 8.91
----

== unique(input) ⇒ array

takes an array and returns unique elements within it

*Kind*: global function +
*Returns*: array - array with duplicate elements removed

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |array |input array
|===

*Example*

[source,js]
----
unique([1, 2, 3, 4, 1, 1, 2]) //returns [1, 2, 3, 4]
----

== upper(input) ⇒ string

Converts all the alphabetic characters in a string to uppercase. If the
value is not a string it will be converted into string using the default
toString method

*Kind*: global function +
*Returns*: string - the upper case value of the input string

[cols=",,",options="header",]
|===
|Param |Type |Description
|input |string |input string
|===

*Example*

[source,js]
----
upper('abcd') //returns 'ABCD'
----

== weekday(The, [returnType]) ⇒ number

Extract the day of the week from a date; if text, uses current locale to
convert to a date.

*Kind*: global function +
*Returns*: number - day of the week

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |datetime for which the day of the week is to be returned.
Dates should be entered by using the datetime function

|[returnType] |number |A number that determines the numeral
representation (a number from 0 to 7) of the day of week. Default is 1.
Supports the following values * 1 : Sunday (1), Monday (2), …, Saturday
(7) * 2 : Monday (1), Tuesday (2), …, Sunday(7) * 3 : Monday (0),
Tuesday (2), …., Sunday(6)
|===

*Example*

[source,js]
----
weekday(datetime(2006,5,21)) // 1
----

*Example*

[source,js]
----
weekday(datetime(2006,5,21), 2) // 7
----

*Example*

[source,js]
----
weekday(datetime(2006,5,21), 3) // 6
----

== year(The) ⇒ number

Returns the year of a date represented by a serial number.

*Kind*: global function

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Param |Type |Description
|The |number |date for which the year is to be returned. Dates should be
entered by using the datetime function
|===

*Example*

[source,js]
----
year(datetime(2008,5,23)) //returns 2008
----
